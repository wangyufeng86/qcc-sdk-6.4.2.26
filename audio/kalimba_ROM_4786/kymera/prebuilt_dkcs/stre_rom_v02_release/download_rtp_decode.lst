
/home/svc-audio-dspsw/kymera_builds/builds/2019/kymera_1912051504/kalimba/kymera/tools/KCSMaker/out/4786/stre_rom_v02_release/download/debugbin/download_rtp_decode.elf:     file format elf32-littlekalimba

Disassembly of section .text_minim:

84200000 <$_rtp_decode_create>:
}

/* ********************************** API functions ************************************* */

bool rtp_decode_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200000:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200002:	17 00       	r5 = r0 + Null;
84200004:	1a 09       	r8 = r1 + Null;
84200006:	20 09       	r6 = r2 + Null;
84200008:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420000a:	0a f0 29 e9 	call (m) $_base_op_get_instance_data;
8420000e:	16 00       	r4 = r0 + Null;
bool rtp_decode_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
84200010:	4d 08       	r3 = r7 + Null;
84200012:	44 08       	r2 = r6 + Null;
84200014:	53 08       	r1 = r8 + Null;
84200016:	3a 00       	r0 = r5 + Null;
84200018:	ff fd 00 f0 	call (m) 0x8c;
8420001c:	35 e3 
8420001e:	10 04       	Null = r0 - Null;
84200020:	03 62       	if NE jump (m) Lc_rtp_decode_create_3;

84200022 <Lc_rtp_decode_create_2>:
    {
        return FALSE;
84200022:	02 00       	r0 = Null + Null;
84200024:	15 6e       	jump (m) Lc_rtp_decode_create_4;

84200026 <Lc_rtp_decode_create_3>:
    }

    /* Make sure the input and output buffer is null. */
    opx_data->ip_buffer = NULL;
84200026:	f0 9f       	M[r4 + 60] = Null;
    opx_data->op_buffer = NULL;
84200028:	30 ae       	M[r4 + 64] = Null;

    /* Reset the first tag logic.*/
    opx_data->continuation_for_frame = FALSE;
8420002a:	f0 8f       	M[r4 + 28] = Null;

    opx_data->latency_buffer_size = RTP_DECODE_DEFAULT_BUFFER_SIZE;
8420002c:	01 f0 00 42 	rMAC = Null + 512;
84200030:	71 af       	M[r4 + 84] = rMAC;
    opx_data->kick_on_full_output = FALSE;
84200032:	f0 be       	M[r4 + 108] = Null;

    opx_data->aac_codec = NULL;
84200034:	70 8f       	M[r4 + 20] = Null;

    opx_data->aac_utility_select = AAC_LC_OVER_LATM;
84200036:	30 ba       	MB[r4 + 24] = Null;

    opx_data->max_packet_len = 0;
84200038:	f0 af       	M[r4 + 92] = Null;
    opx_data->last_toa_valid = FALSE;
8420003a:	70 be       	M[r4 + 100] = Null;
    opx_data->last_op_tag_octets = opx_data->max_packet_len;
8420003c:	b0 be       	M[r4 + 104] = Null;

    opx_data->prev_src_id = SRC_ID_INVALID;
8420003e:	bc fa 81 f6 	rMAC = Null + -1412623820;
84200042:	34 62 
84200044:	b1 bf       	M[r4 + 120] = rMAC;
    /* Initialise specific data (was allocated and pointer to it filled by OpMgr  */
    rtp_decode_reset_working_data(op_data);
84200046:	3a 00       	r0 = r5 + Null;
84200048:	05 f0 2d e4 	call (m) Lc_rtp_decode_reset_working_data_1;

    return TRUE;
8420004c:	42 20       	r0 = Null + 1;

8420004e <Lc_rtp_decode_create_4>:
}
8420004e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200050:	d8 4c       	rts;

84200052 <$_rtp_decode_destroy>:


bool rtp_decode_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200052:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200054:	16 00       	r4 = r0 + Null;
84200056:	19 09       	r7 = r1 + Null;
84200058:	20 09       	r6 = r2 + Null;
8420005a:	2f 00       	r5 = r3 + Null;
    /* check that we are not trying to destroy a running operator */
    if (opmgr_op_is_running(op_data))
8420005c:	0a f0 3f e3 	call (m) $_opmgr_op_is_running;
84200060:	10 04       	Null = r0 - Null;
84200062:	08 60       	if EQ jump (m) Lc_rtp_decode_destroy_3;

84200064 <Lc_rtp_decode_destroy_2>:
    {
        /* We can't destroy a running operator. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200064:	03 f0 00 60 	r1 = Null + 4096;
84200068:	3c 00       	r2 = r5 + Null;
8420006a:	32 00       	r0 = r4 + Null;
8420006c:	0a f0 3b e4 	call (m) $_base_op_build_std_response_ex;
84200070:	16 6e       	jump (m) Lc_rtp_decode_destroy_4;

84200072 <Lc_rtp_decode_destroy_3>:
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200072:	32 00       	r0 = r4 + Null;
84200074:	0a f0 3f e5 	call (m) $_base_op_get_instance_data;
84200078:	12 09       	r8 = r0 + Null;
    else
    {
        RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

        /* Delete the time to play instance*/
        ttp_free(opx_data->ttp_instance);
8420007a:	a2 f0 14 88 	r0 = M[r8 + 80];
8420007e:	ff fd b5 f0 	call (m) 0x16af4;
84200082:	37 e3 

        pfree(opx_data->src_latency_map);
84200084:	a2 f0 1c 88 	r0 = M[r8 + 112];
84200088:	ff fd 27 f0 	call (m) 0x4f62;
8420008c:	3b e6 

    /* call base_op destroy that creates and fills response message, too */
        return base_op_destroy(op_data, message_data, response_id, response_data);
8420008e:	3d 00       	r3 = r5 + Null;
84200090:	44 08       	r2 = r6 + Null;
84200092:	4b 08       	r1 = r7 + Null;
84200094:	32 00       	r0 = r4 + Null;
84200096:	ff fd 00 f0 	call (m) 0xac;
8420009a:	37 e0 

8420009c <Lc_rtp_decode_destroy_4>:
    }
}
8420009c:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420009e:	d8 4c       	rts;

842000a0 <$_rtp_decode_start>:

bool rtp_decode_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842000a0:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842000a2:	16 00       	r4 = r0 + Null;
842000a4:	19 09       	r7 = r1 + Null;
842000a6:	20 09       	r6 = r2 + Null;
842000a8:	2f 00       	r5 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842000aa:	0a f0 29 e4 	call (m) $_base_op_get_instance_data;

bool rtp_decode_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA* opx_data = get_instance_data(op_data);

    if ((opx_data->mode == RTP_DECODE)  || (opx_data->mode == RTP_TTP_ONLY))
842000ae:	11 90       	rMAC = MBS[r0 + 8];
842000b0:	48 24       	Null = rMAC - 1;
842000b2:	03 60       	if EQ jump (m) Lc_rtp_decode_start_3;

842000b4 <Lc_rtp_decode_start_2>:
842000b4:	c8 24       	Null = rMAC - 3;
842000b6:	18 62       	if NE jump (m) Lc_rtp_decode_start_9;

842000b8 <Lc_rtp_decode_start_3>:
    {
        /* Check if the sample rate is different than zero. */
        if(opx_data->sample_rate == 0)
842000b8:	90 a9       	Null = M[r0 + 88];
842000ba:	08 62       	if NE jump (m) Lc_rtp_decode_start_5;

842000bc <Lc_rtp_decode_start_4>:
        {
            return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842000bc:	03 f0 00 60 	r1 = Null + 4096;
842000c0:	3c 00       	r2 = r5 + Null;
842000c2:	32 00       	r0 = r4 + Null;
842000c4:	0a f0 23 e2 	call (m) $_base_op_build_std_response_ex;
842000c8:	16 6e       	jump (m) Lc_rtp_decode_start_10;

842000ca <Lc_rtp_decode_start_5>:
        }
    }

    if((opx_data->mode == RTP_DECODE) && (opx_data->codec_type == AAC) && (opx_data->aac_codec == NULL))
842000ca:	48 24       	Null = rMAC - 1;
842000cc:	0d 62       	if NE jump (m) Lc_rtp_decode_start_9;

842000ce <Lc_rtp_decode_start_6>:
842000ce:	51 a0       	rMAC = MBS[r0 + 17];
842000d0:	08 25       	Null = rMAC - 4;
842000d2:	0a 62       	if NE jump (m) Lc_rtp_decode_start_9;

842000d4 <Lc_rtp_decode_start_7>:
842000d4:	51 89       	rMAC = M[r0 + 20];
842000d6:	08 62       	if NE jump (m) Lc_rtp_decode_start_9;

842000d8 <Lc_rtp_decode_start_8>:
    {
        /* It is very hard to decode and AAC frame to get the sample count. Therefore
         * RTP decode needs the help of a decoder which is set through the
         * OPMSG_RTP_DECODE_ID_SET_AAC_DECODER message. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842000d8:	03 f0 00 60 	r1 = Null + 4096;
842000dc:	3c 00       	r2 = r5 + Null;
842000de:	32 00       	r0 = r4 + Null;
842000e0:	0a f0 27 e1 	call (m) $_base_op_build_std_response_ex;
842000e4:	08 6e       	jump (m) Lc_rtp_decode_start_10;

842000e6 <Lc_rtp_decode_start_9>:
    }

    return base_op_start(op_data, message_data, response_id, response_data);
842000e6:	3d 00       	r3 = r5 + Null;
842000e8:	44 08       	r2 = r6 + Null;
842000ea:	4b 08       	r1 = r7 + Null;
842000ec:	32 00       	r0 = r4 + Null;
842000ee:	ef fd ff ff 	call (m) 0x4a;
842000f2:	3d ea 

842000f4 <Lc_rtp_decode_start_10>:
}
842000f4:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842000f6:	d8 4c       	rts;

842000f8 <$_rtp_decode_reset>:

bool rtp_decode_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842000f8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842000fa:	16 00       	r4 = r0 + Null;
    if (!base_op_reset(op_data, message_data, response_id, response_data))
842000fc:	ef fd ff ff 	call (m) 0x28;
84200100:	2d e9 
84200102:	10 04       	Null = r0 - Null;
84200104:	03 62       	if NE jump (m) Lc_rtp_decode_reset_3;

84200106 <Lc_rtp_decode_reset_2>:
    {
        return FALSE;
84200106:	02 00       	r0 = Null + Null;
84200108:	05 6e       	jump (m) Lc_rtp_decode_reset_4;

8420010a <Lc_rtp_decode_reset_3>:
    }

    /* now initialise specific working data */
    rtp_decode_reset_working_data(op_data);
8420010a:	32 00       	r0 = r4 + Null;
8420010c:	04 f0 29 ee 	call (m) Lc_rtp_decode_reset_working_data_1;

    return TRUE;
84200110:	42 20       	r0 = Null + 1;

84200112 <Lc_rtp_decode_reset_4>:
}
84200112:	f1 48       	popm <FP, r4, rLink>;
84200114:	d8 4c       	rts;

84200116 <$_rtp_decode_connect>:

    return buffer;
}

bool rtp_decode_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200116:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200118:	11 09       	r7 = r0 + Null;
8420011a:	18 09       	r6 = r1 + Null;
8420011c:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420011e:	0a f0 35 e0 	call (m) $_base_op_get_instance_data;
84200122:	17 00       	r5 = r0 + Null;
}

bool rtp_decode_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned*)message_data)[0];
84200124:	86 f0 00 e8 	r4 = M[r6 + Null];
    unsigned  channel;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200128:	03 00       	r1 = Null + Null;
8420012a:	54 08       	r2 = r8 + Null;
8420012c:	4a 08       	r0 = r7 + Null;
8420012e:	09 f0 39 ee 	call (m) $_base_op_build_std_response_ex;
84200132:	10 04       	Null = r0 - Null;
84200134:	03 62       	if NE jump (m) Lc_rtp_decode_connect_3;

84200136 <Lc_rtp_decode_connect_2>:
    {
        /* Shouldn't change anything if there is not enough memory for the response.*/
        return FALSE;
84200136:	02 00       	r0 = Null + Null;
84200138:	67 6e       	jump (m) Lc_rtp_decode_connect_17;

8420013a <Lc_rtp_decode_connect_3>:
    }

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
8420013a:	bf ff 61 ff 	rMAC = r4 AND 0xff7fffff;
8420013e:	ff 1f 
84200140:	07 60       	if EQ jump (m) Lc_rtp_decode_connect_5;

84200142 <Lc_rtp_decode_connect_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
84200142:	01 f0 03 60 	rMAC = Null + 4099;
84200146:	a2 f0 00 e8 	r0 = M[r8 + Null];
8420014a:	51 8e       	M[r0 + 4] = rMAC;
8420014c:	5c 6e       	jump (m) Lc_rtp_decode_connect_16;

8420014e <Lc_rtp_decode_connect_5>:
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    if (terminal_id & TERMINAL_SINK_MASK)
8420014e:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
84200152:	00 00 
84200154:	07 60       	if EQ jump (m) Lc_rtp_decode_connect_8;

84200156 <Lc_rtp_decode_connect_6>:
    {
        if (opx_data->ip_buffer == NULL)
84200156:	f9 99       	rMAC = M[r5 + 60];
84200158:	3c 62       	if NE jump (m) Lc_rtp_decode_connect_13;

8420015a <Lc_rtp_decode_connect_7>:
        {
            /* Wrap up the given buffer to achieve octet based access to it. */
            opx_data->ip_buffer = (tCbuffer*)(((uintptr_t *)message_data)[1]);
8420015a:	81 f0 01 88 	rMAC = M[r6 + 4];
8420015e:	f9 9f       	M[r5 + 60] = rMAC;
84200160:	52 6e       	jump (m) Lc_rtp_decode_connect_16;

84200162 <Lc_rtp_decode_connect_8>:
            return TRUE;
        }
    }
    else
    {
        if (opx_data->op_buffer == NULL)
84200162:	39 a8       	rMAC = M[r5 + 64];
84200164:	36 62       	if NE jump (m) Lc_rtp_decode_connect_13;

84200166 <Lc_rtp_decode_connect_9>:
        {
            tCbuffer *connection_buf = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84200166:	86 f0 01 88 	r4 = M[r6 + 4];
            /* Wrap up the given buffer to achieve octet based access to it. */
            opx_data->op_buffer = connection_buf;
8420016a:	3e ae       	M[r5 + 64] = r4;
#ifdef DATAFORMAT_32
            cbuffer_set_usable_octets(opx_data->op_buffer, NR_OF_OCTETS_IN_WORD(USE_32BIT_PER_WORD));
#else
            cbuffer_set_usable_octets(opx_data->op_buffer, NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD));
8420016c:	83 20       	r1 = Null + 2;
8420016e:	32 00       	r0 = r4 + Null;
84200170:	09 f0 2b ea 	call (m) $_cbuffer_set_usable_octets;
#endif /* DATAFORMAT_32 */
            {

                if (opx_data->pack_latency_buffer)
84200174:	78 b9       	Null = M[r5 + 116];
84200176:	33 60       	if EQ jump (m) Lc_rtp_decode_connect_14;

84200178 <Lc_rtp_decode_connect_10>:
                    opx_data->u.pack.frame_buffer = rtp_create_internal_buffer(
                            NULL,/* Create a new buffer for decoding the rtp payload. */
                            cbuffer_get_size_in_words(connection_buf),
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD)
                    );
84200178:	32 00       	r0 = r4 + Null;
8420017a:	ff fd 93 f0 	call (m) 0x12858;
8420017e:	3f e6 
84200180:	13 00       	r1 = r0 + Null;
84200182:	85 20       	r3 = Null + 2;
84200184:	74 89       	r2 = M[r4 + 20];
84200186:	02 00       	r0 = Null + Null;
84200188:	06 f0 3b e2 	call (m) Lc_rtp_create_internal_buffer_1;
8420018c:	ba ae       	M[r5 + 72] = r0;
                    if(opx_data->u.pack.frame_buffer == NULL)
8420018e:	b9 a8       	rMAC = M[r5 + 72];
84200190:	20 60       	if EQ jump (m) Lc_rtp_decode_connect_13;

84200192 <Lc_rtp_decode_connect_11>:
                    opx_data->u.pack.clone_frame_buffer = rtp_create_internal_buffer(
                            opx_data->u.pack.frame_buffer->base_addr, /* clone buffer is only used to discard corrupt frames. */
                            cbuffer_get_size_in_words(connection_buf),
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD)
                    );
84200192:	32 00       	r0 = r4 + Null;
84200194:	ff fd 93 f0 	call (m) 0x12858;
84200198:	25 e6 
8420019a:	13 00       	r1 = r0 + Null;
8420019c:	85 20       	r3 = Null + 2;
8420019e:	74 89       	r2 = M[r4 + 20];
842001a0:	b9 a8       	rMAC = M[r5 + 72];
842001a2:	ca 88       	r0 = M[rMAC + 12];
842001a4:	06 f0 3f e1 	call (m) Lc_rtp_create_internal_buffer_1;
842001a8:	7a ae       	M[r5 + 68] = r0;
                    if(opx_data->u.pack.clone_frame_buffer == NULL)
842001aa:	79 a8       	rMAC = M[r5 + 68];
842001ac:	12 60       	if EQ jump (m) Lc_rtp_decode_connect_13;

842001ae <Lc_rtp_decode_connect_12>:
                    {
                        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
                        return TRUE;
                    }
                    opx_data->u.pack.clone_frame_buffer->aux_ptr = (void*)(opx_data->u.pack.frame_buffer);
842001ae:	ba a8       	r0 = M[r5 + 72];
842001b0:	0a 8f       	M[rMAC + 16] = r0;
                    BUF_DESC_IN_PLACE_SET(opx_data->u.pack.clone_frame_buffer->descriptor); /* this is an inplace buffer. */
842001b2:	79 a8       	rMAC = M[r5 + 68];
842001b4:	09 29       	rMAC = rMAC + 20;
842001b6:	0a e8       	r0 = M[rMAC + Null];
842001b8:	d2 ce       	r0 = r0 OR 0x10000;
842001ba:	0a ee       	M[rMAC + Null] = r0;
                    opx_data->u.pack.internal_buffer = rtp_create_internal_buffer(
                            NULL, /* Create a new buffer */
                            opx_data->latency_buffer_size/2, /* Due to packing use half of the size. */
                            connection_buf->descriptor,
                            NR_OF_OCTETS_IN_WORD(USE_32BIT_PER_WORD)
                    );
842001bc:	05 21       	r3 = Null + 4;
842001be:	74 89       	r2 = M[r4 + 20];
842001c0:	7a a9       	r0 = M[r5 + 84];
842001c2:	13 50       	r1 = r0 LSHIFT -1;
842001c4:	02 00       	r0 = Null + Null;
842001c6:	06 f0 3d e0 	call (m) Lc_rtp_create_internal_buffer_1;
842001ca:	fa ae       	M[r5 + 76] = r0;
                    if(opx_data->u.pack.internal_buffer == NULL)
842001cc:	f9 a8       	rMAC = M[r5 + 76];
842001ce:	1b 62       	if NE jump (m) Lc_rtp_decode_connect_16;

842001d0 <Lc_rtp_decode_connect_13>:
842001d0:	01 f0 00 60 	rMAC = Null + 4096;
842001d4:	a2 f0 00 e8 	r0 = M[r8 + Null];
842001d8:	51 8e       	M[r0 + 4] = rMAC;
842001da:	15 6e       	jump (m) Lc_rtp_decode_connect_16;

842001dc <Lc_rtp_decode_connect_14>:
                    /* Now, clone the buffer which will be used internally. Make it an in-place
                     * buffer to save place and to avoid overwriting data. Note the output
                     * buffer is not in-place just the internal one. Also the clone buffer
                     * does not need to hold any metadata, however metadata must be allocated
                     * otherwise the buffer is treated as 32bit when running in stre rom v02. */
                    buffer_flags = connection_buf->descriptor;
842001dc:	68 f0 05 88 	r6 = M[r4 + 20];
                    BUF_DESC_IN_PLACE_SET(buffer_flags);
842001e0:	00 f1 00 f8 	r6 = r6 OR 0x10000;
842001e4:	58 d8 
                    in_place_buffer =  rtp_create_internal_buffer(
                            connection_buf->base_addr, /* clone the output buffer. */
                            cbuffer_get_size_in_words(connection_buf),
                            buffer_flags,
                            NR_OF_OCTETS_IN_WORD(USE_16BIT_PER_WORD)
                    );
842001e6:	32 00       	r0 = r4 + Null;
842001e8:	ff fd 93 f0 	call (m) 0x12858;
842001ec:	31 e3 
842001ee:	13 00       	r1 = r0 + Null;
842001f0:	85 20       	r3 = Null + 2;
842001f2:	f2 88       	r0 = M[r4 + 12];
842001f4:	44 08       	r2 = r6 + Null;
842001f6:	05 f0 2d ef 	call (m) Lc_rtp_create_internal_buffer_1;
                    if(in_place_buffer == NULL)
842001fa:	10 04       	Null = r0 - Null;
842001fc:	ea 61       	if EQ jump (m) Lc_rtp_decode_connect_13;

842001fe <Lc_rtp_decode_connect_15>:
                    {
                        base_op_change_response_status(response_data, STATUS_CMD_FAILED);

                        return TRUE;
                    }
                    opx_data->u.clone_op_buffer = in_place_buffer;
842001fe:	7a ae       	M[r5 + 68] = r0;
                    opx_data->u.clone_op_buffer->aux_ptr = (void*)opx_data->op_buffer;
84200200:	39 a8       	rMAC = M[r5 + 64];
84200202:	11 8f       	M[r0 + 16] = rMAC;

84200204 <Lc_rtp_decode_connect_16>:

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
84200204:	42 20       	r0 = Null + 1;

84200206 <Lc_rtp_decode_connect_17>:
        }
    }


    return TRUE;
}
84200206:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200208:	d8 4c       	rts;

8420020a <$_rtp_decode_disconnect>:


bool rtp_decode_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420020a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420020c:	11 09       	r7 = r0 + Null;
8420020e:	1f 00       	r5 = r1 + Null;
84200210:	28 09       	r6 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200212:	09 f0 21 e9 	call (m) $_base_op_get_instance_data;
84200216:	16 00       	r4 = r0 + Null;


bool rtp_decode_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned*)message_data)[0];
84200218:	3f e8       	r5 = M[r5 + Null];
    unsigned channel;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
8420021a:	03 00       	r1 = Null + Null;
8420021c:	44 08       	r2 = r6 + Null;
8420021e:	4a 08       	r0 = r7 + Null;
84200220:	09 f0 27 e7 	call (m) $_base_op_build_std_response_ex;
84200224:	10 04       	Null = r0 - Null;
84200226:	03 62       	if NE jump (m) Lc_rtp_decode_disconnect_3;

84200228 <Lc_rtp_decode_disconnect_2>:
    {
        /* Shouldn't change anything if there is not enough memory for the response.*/
        return FALSE;
84200228:	02 00       	r0 = Null + Null;
8420022a:	2a 6e       	jump (m) Lc_rtp_decode_disconnect_11;

8420022c <Lc_rtp_decode_disconnect_3>:
    }

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
8420022c:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
84200230:	ff 1f 
84200232:	07 60       	if EQ jump (m) Lc_rtp_decode_disconnect_5;

84200234 <Lc_rtp_decode_disconnect_4>:
84200234:	01 f0 03 60 	rMAC = Null + 4099;
84200238:	82 f0 00 e8 	r0 = M[r6 + Null];
8420023c:	51 8e       	M[r0 + 4] = rMAC;
8420023e:	1f 6e       	jump (m) Lc_rtp_decode_disconnect_10;

84200240 <Lc_rtp_decode_disconnect_5>:
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }


    if (terminal_id & TERMINAL_SINK_MASK)
84200240:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200244:	00 00 
84200246:	03 60       	if EQ jump (m) Lc_rtp_decode_disconnect_7;

84200248 <Lc_rtp_decode_disconnect_6>:
    {
        opx_data->ip_buffer = NULL;
84200248:	f0 9f       	M[r4 + 60] = Null;
8420024a:	19 6e       	jump (m) Lc_rtp_decode_disconnect_10;

8420024c <Lc_rtp_decode_disconnect_7>:
    }
    else
    {
        opx_data->op_buffer = NULL;
8420024c:	30 ae       	M[r4 + 64] = Null;
        if (opx_data->pack_latency_buffer)
8420024e:	70 b9       	Null = M[r4 + 116];
84200250:	11 60       	if EQ jump (m) Lc_rtp_decode_disconnect_9;

84200252 <Lc_rtp_decode_disconnect_8>:
        {
            /* Destroy the internal buffer */
            cbuffer_destroy(opx_data->u.pack.internal_buffer);
84200252:	f2 a8       	r0 = M[r4 + 76];
84200254:	ff fd 92 f0 	call (m) 0x12802;
84200258:	2f ed 
            opx_data->u.pack.internal_buffer = NULL;
8420025a:	f0 ae       	M[r4 + 76] = Null;

            /* Only destroy the buffer struct, the buffer be freed with opx_data->u.pack.frame_buffer */
            cbuffer_destroy_struct(opx_data->u.pack.clone_frame_buffer);
8420025c:	72 a8       	r0 = M[r4 + 68];
8420025e:	ff fd 92 f0 	call (m) 0x12834;
84200262:	37 ee 
            opx_data->u.pack.clone_frame_buffer = NULL;
84200264:	70 ae       	M[r4 + 68] = Null;

            cbuffer_destroy(opx_data->u.pack.frame_buffer);
84200266:	b2 a8       	r0 = M[r4 + 72];
84200268:	ff fd 92 f0 	call (m) 0x12802;
8420026c:	3b ec 
            opx_data->u.pack.frame_buffer = NULL;
8420026e:	b0 ae       	M[r4 + 72] = Null;
84200270:	06 6e       	jump (m) Lc_rtp_decode_disconnect_10;

84200272 <Lc_rtp_decode_disconnect_9>:
        }
        else
        {
            cbuffer_destroy_struct(opx_data->u.clone_op_buffer);
84200272:	72 a8       	r0 = M[r4 + 68];
84200274:	ff fd 92 f0 	call (m) 0x12834;
84200278:	21 ee 
            opx_data->u.clone_op_buffer = NULL;
8420027a:	70 ae       	M[r4 + 68] = Null;

8420027c <Lc_rtp_decode_disconnect_10>:

    channel = terminal_id & (~TERMINAL_SINK_MASK);
    if (channel != 0)
    {
        base_op_change_response_status(response_data, STATUS_INVALID_CMD_PARAMS);
        return TRUE;
8420027c:	42 20       	r0 = Null + 1;

8420027e <Lc_rtp_decode_disconnect_11>:
            opx_data->u.clone_op_buffer = NULL;
        }
    }

    return TRUE;
}
8420027e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200280:	d8 4c       	rts;

84200282 <$_rtp_decode_buffer_details>:


bool rtp_decode_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200282:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200284:	11 09       	r7 = r0 + Null;
84200286:	18 09       	r6 = r1 + Null;
84200288:	22 09       	r8 = r2 + Null;
8420028a:	2e 00       	r4 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420028c:	09 f0 27 e5 	call (m) $_base_op_get_instance_data;
84200290:	17 00       	r5 = r0 + Null;


bool rtp_decode_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned *)message_data)[0];
84200292:	8b f0 00 e8 	r9 = M[r6 + Null];

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200296:	35 00       	r3 = r4 + Null;
84200298:	54 08       	r2 = r8 + Null;
8420029a:	43 08       	r1 = r6 + Null;
8420029c:	4a 08       	r0 = r7 + Null;
8420029e:	ef fd ff ff 	call (m) 0xbe;
842002a2:	21 e1 
842002a4:	10 04       	Null = r0 - Null;
842002a6:	03 62       	if NE jump (m) Lc_rtp_decode_buffer_details_3;

842002a8 <Lc_rtp_decode_buffer_details_2>:
    {
        return FALSE;
842002a8:	02 00       	r0 = Null + Null;
842002aa:	25 6e       	jump (m) Lc_rtp_decode_buffer_details_10;

842002ac <Lc_rtp_decode_buffer_details_3>:
    }

    /* RTP does not reuse any of its metadata on other channels. */
    ((OP_BUF_DETAILS_RSP*)*response_data)->metadata_buffer = NULL;
842002ac:	31 e8       	rMAC = M[r4 + Null];
842002ae:	c8 8e       	M[rMAC + 12] = Null;

    /* Metadata on the output buffer is only present if the capability decodes the RTP
     * header but the working mode config message could arrive after the connect. */
    ((OP_BUF_DETAILS_RSP*)*response_data)->supports_metadata = TRUE;
842002b0:	31 e8       	rMAC = M[r4 + Null];
842002b2:	09 22       	rMAC = rMAC + 8;
842002b4:	0a e2       	r0 = MBU[rMAC + Null];
842002b6:	22 ff ef 1f 	r0 = r0 AND 0xffffffef;
842002ba:	d2 c9       	r0 = r0 OR 0x10;
842002bc:	0a ea       	MB[rMAC + Null] = r0;

    /* If the data is packed internaly, use the default output buffer size. */
    if ((!opx_data->pack_latency_buffer)&&((terminal_id & TERMINAL_SINK_MASK) == 0))
842002be:	78 b9       	Null = M[r5 + 116];
842002c0:	09 62       	if NE jump (m) Lc_rtp_decode_buffer_details_6;

842002c2 <Lc_rtp_decode_buffer_details_4>:
842002c2:	40 f0 b1 f0 	rMAC = r9 AND 0x800000;
842002c6:	00 00 
842002c8:	05 62       	if NE jump (m) Lc_rtp_decode_buffer_details_6;

842002ca <Lc_rtp_decode_buffer_details_5>:
    {
        /* Output, use the latency buffer size */
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size = opx_data->latency_buffer_size;
842002ca:	79 a9       	rMAC = M[r5 + 84];
842002cc:	32 e8       	r0 = M[r4 + Null];
842002ce:	11 8f       	M[r0 + 16] = rMAC;
842002d0:	05 6e       	jump (m) Lc_rtp_decode_buffer_details_7;

842002d2 <Lc_rtp_decode_buffer_details_6>:
    }
    else
    {
        /* Default buffer size for input terminal */
        ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size = RTP_DECODE_DEFAULT_BUFFER_SIZE;
842002d2:	01 f0 00 42 	rMAC = Null + 512;
842002d6:	32 e8       	r0 = M[r4 + Null];
842002d8:	11 8f       	M[r0 + 16] = rMAC;

842002da <Lc_rtp_decode_buffer_details_7>:
    }

    L4_DBG_MSG1("rtp_decode_buffer_details  %d \n", ((OP_BUF_DETAILS_RSP*)*response_data)->b.buffer_size  );
842002da:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842002de:	08 25       	Null = rMAC - 4;
842002e0:	09 68       	if LT jump (m) Lc_rtp_decode_buffer_details_9;

842002e2 <Lc_rtp_decode_buffer_details_8>:
842002e2:	31 e8       	rMAC = M[r4 + Null];
842002e4:	0b 89       	r1 = M[rMAC + 16];
842002e6:	55 f1 02 f0 	r0 = Null + 357564885;
842002ea:	d5 41 
842002ec:	ff fd 03 f0 	call (m) 0x9b4;
842002f0:	29 e6 

842002f2 <Lc_rtp_decode_buffer_details_9>:

    return TRUE;
842002f2:	42 20       	r0 = Null + 1;

842002f4 <Lc_rtp_decode_buffer_details_10>:
}
842002f4:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842002f6:	d8 4c       	rts;

842002f8 <$_rtp_decode_get_sched_info>:


bool rtp_decode_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842002f8:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842002fa:	17 00       	r5 = r0 + Null;
842002fc:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
842002fe:	08 f0 29 ef 	call (m) $_base_op_get_sched_info_ex;
    if (resp == NULL)
84200302:	10 04       	Null = r0 - Null;
84200304:	08 62       	if NE jump (m) Lc_rtp_decode_get_sched_info_3;

84200306 <Lc_rtp_decode_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200306:	03 f0 00 60 	r1 = Null + 4096;
8420030a:	34 00       	r2 = r4 + Null;
8420030c:	3a 00       	r0 = r5 + Null;
8420030e:	08 f0 39 ef 	call (m) $_base_op_build_std_response_ex;
84200312:	05 6e       	jump (m) Lc_rtp_decode_get_sched_info_4;

84200314 <Lc_rtp_decode_get_sched_info_3>:
    }
    *response_data = resp;
84200314:	32 ee       	M[r4 + Null] = r0;

    /* Same buffer size for sink and source.
       No additional verification needed.*/
    resp->block_size = RTP_DECODE_DEFAULT_BLOCK_SIZE;
84200316:	41 20       	rMAC = Null + 1;
84200318:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
8420031a:	0a 00       	r0 = rMAC + Null;

8420031c <Lc_rtp_decode_get_sched_info_4>:
}
8420031c:	f2 48       	popm <FP, r4, r5, rLink>;
8420031e:	d8 4c       	rts;

84200320 <$_rtp_decode_get_data_format>:


bool rtp_decode_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200320:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200322:	10 09       	r6 = r0 + Null;
84200324:	1a 09       	r8 = r1 + Null;
84200326:	21 09       	r7 = r2 + Null;
84200328:	2e 00       	r4 = r3 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420032a:	09 f0 29 e0 	call (m) $_base_op_get_instance_data;
8420032e:	17 00       	r5 = r0 + Null;

bool rtp_decode_get_data_format(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if (!base_op_get_data_format(op_data, message_data, response_id, response_data))
84200330:	35 00       	r3 = r4 + Null;
84200332:	4c 08       	r2 = r7 + Null;
84200334:	53 08       	r1 = r8 + Null;
84200336:	42 08       	r0 = r6 + Null;
84200338:	ef fd ff ff 	call (m) 0x17a;
8420033c:	23 e2 
8420033e:	10 04       	Null = r0 - Null;
84200340:	03 62       	if NE jump (m) Lc_rtp_decode_get_data_format_3;

84200342 <Lc_rtp_decode_get_data_format_2>:
    {
        return FALSE;
84200342:	02 00       	r0 = Null + Null;
84200344:	0f 6e       	jump (m) Lc_rtp_decode_get_data_format_7;

84200346 <Lc_rtp_decode_get_data_format_3>:
    }

    /* return the terminal's data format - purely based on terminal data direction flag */
    if((((unsigned*)message_data)[0] & TERMINAL_SINK_MASK) == 0)
84200346:	a1 f0 00 e8 	rMAC = M[r8 + Null];
8420034a:	40 f0 11 f0 	rMAC = rMAC AND 0x800000;
8420034e:	00 00 
84200350:	05 62       	if NE jump (m) Lc_rtp_decode_get_data_format_5;

84200352 <Lc_rtp_decode_get_data_format_4>:
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = opx_data->op_format;
84200352:	79 88       	rMAC = M[r5 + 4];
84200354:	32 e8       	r0 = M[r4 + Null];
84200356:	91 8e       	M[r0 + 8] = rMAC;
84200358:	04 6e       	jump (m) Lc_rtp_decode_get_data_format_6;

8420035a <Lc_rtp_decode_get_data_format_5>:
    }
    else
    {
        ((OP_STD_RSP*)*response_data)->resp_data.data = opx_data->ip_format;
8420035a:	39 e8       	rMAC = M[r5 + Null];
8420035c:	32 e8       	r0 = M[r4 + Null];
8420035e:	91 8e       	M[r0 + 8] = rMAC;

84200360 <Lc_rtp_decode_get_data_format_6>:
    }

    return TRUE;
84200360:	42 20       	r0 = Null + 1;

84200362 <Lc_rtp_decode_get_data_format_7>:
}
84200362:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200364:	d8 4c       	rts;

84200366 <$_rtp_decode_opmsg_set_working_mode>:

/* **************************** Operator message handlers ******************************** */


bool rtp_decode_opmsg_set_working_mode(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200366:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84200368:	1f 00       	r5 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420036a:	08 f0 29 ee 	call (m) $_base_op_get_instance_data;
8420036e:	16 00       	r4 = r0 + Null;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_WORKING_MODES wm;

    wm = (RTP_WORKING_MODES) OPMSG_FIELD_GET(message_data,
                                OPMSG_RTP_SET_WORKING_MODE, WORKING_MODE);
84200370:	f9 88       	rMAC = M[r5 + 12];
84200372:	89 c6       	rMAC = rMAC AND 0xffff;
84200374:	0f 08       	r5 = SE8 rMAC;

    if (wm >= RTP_NR_OF_MODES)
84200376:	38 25       	Null = r5 - 4;
84200378:	03 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_working_mode_3;

8420037a <Lc_rtp_decode_opmsg_set_working_mode_2>:
    {
        return FALSE;
8420037a:	02 00       	r0 = Null + Null;
8420037c:	19 6e       	jump (m) Lc_rtp_decode_opmsg_set_working_mode_9;

8420037e <Lc_rtp_decode_opmsg_set_working_mode_3>:
    }

    /* Check a new time to play instance is needed. */
    if ((wm == RTP_DECODE)||(wm == RTP_TTP_ONLY))
8420037e:	78 24       	Null = r5 - 1;
84200380:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_working_mode_5;

84200382 <Lc_rtp_decode_opmsg_set_working_mode_4>:
84200382:	f8 24       	Null = r5 - 3;
84200384:	13 62       	if NE jump (m) Lc_rtp_decode_opmsg_set_working_mode_8;

84200386 <Lc_rtp_decode_opmsg_set_working_mode_5>:
    {
        if (opx_data->ttp_instance == NULL)
84200386:	31 a9       	rMAC = M[r4 + 80];
84200388:	11 62       	if NE jump (m) Lc_rtp_decode_opmsg_set_working_mode_8;

8420038a <Lc_rtp_decode_opmsg_set_working_mode_6>:
        {
            ttp_params params;

            /* Create a new ttp instance*/
            opx_data->ttp_instance = ttp_init();
8420038a:	ff fd b1 f0 	call (m) 0x16698;
8420038e:	2f e8 
84200390:	32 af       	M[r4 + 80] = r0;
            if (opx_data->ttp_instance == NULL)
84200392:	31 a9       	rMAC = M[r4 + 80];
84200394:	f3 61       	if EQ jump (m) Lc_rtp_decode_opmsg_set_working_mode_2;

84200396 <Lc_rtp_decode_opmsg_set_working_mode_7>:
            {
                return FALSE;
            }

            ttp_get_default_params(&params, TTP_TYPE_A2DP);
84200396:	83 20       	r1 = Null + 2;
84200398:	02 11       	r0 = FP + 16;
8420039a:	ff fd b1 f0 	call (m) 0x166de;
8420039e:	25 ea 
            ttp_configure_params(opx_data->ttp_instance, &params);
842003a0:	03 11       	r1 = FP + 16;
842003a2:	32 a9       	r0 = M[r4 + 80];
842003a4:	ff fd b2 f0 	call (m) 0x16822;
842003a8:	3f e3 

842003aa <Lc_rtp_decode_opmsg_set_working_mode_8>:
        }
    }

    opx_data->mode = wm;
842003aa:	37 9a       	MB[r4 + 8] = r5;

    return TRUE;
842003ac:	42 20       	r0 = Null + 1;

842003ae <Lc_rtp_decode_opmsg_set_working_mode_9>:
}
842003ae:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
842003b0:	d8 4c       	rts;

842003b2 <$_rtp_decode_opmsg_set_codec_type>:


bool rtp_decode_opmsg_set_codec_type(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842003b2:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842003b4:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842003b6:	08 f0 3d eb 	call (m) $_base_op_get_instance_data;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_CODEC_TYPE codec_type;

    codec_type = (RTP_CODEC_TYPE) OPMSG_FIELD_GET(message_data,
                                OPMSG_RTP_SET_CODEC_TYPE, CODEC_TYPE);
842003ba:	f1 88       	rMAC = M[r4 + 12];
842003bc:	89 c6       	rMAC = rMAC AND 0xffff;
842003be:	09 08       	rMAC = SE8 rMAC;

    if (codec_type >= NR_OF_CODECS)
842003c0:	c8 25       	Null = rMAC - 7;
842003c2:	03 68       	if LT jump (m) Lc_rtp_decode_opmsg_set_codec_type_3;

842003c4 <Lc_rtp_decode_opmsg_set_codec_type_2>:
    {
        return FALSE;
842003c4:	02 00       	r0 = Null + Null;
842003c6:	05 6e       	jump (m) Lc_rtp_decode_opmsg_set_codec_type_4;

842003c8 <Lc_rtp_decode_opmsg_set_codec_type_3>:
    }

    opx_data->codec_type = codec_type;
842003c8:	51 aa       	MB[r0 + 17] = rMAC;

    rtp_set_payload_header_size(opx_data);
842003ca:	02 f0 23 ec 	call (m) Lc_rtp_set_payload_header_size_1;

    return TRUE;
842003ce:	42 20       	r0 = Null + 1;

842003d0 <Lc_rtp_decode_opmsg_set_codec_type_4>:
}
842003d0:	f1 48       	popm <FP, r4, rLink>;
842003d2:	d8 4c       	rts;

842003d4 <$_rtp_decode_opmsg_set_content_protection>:


bool rtp_decode_opmsg_set_content_protection(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842003d4:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842003d6:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842003d8:	08 f0 3b ea 	call (m) $_base_op_get_instance_data;
bool rtp_decode_opmsg_set_content_protection(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    opx_data->scms_enable = OPMSG_FIELD_GET(message_data,
                             OPMSG_RTP_SET_CONTENT_PROTECTION, CONTENT_PROTECTION_ENABLED) & 1;
842003dc:	11 a2       	rMAC = MBU[r0 + 16];
842003de:	f3 88       	r1 = M[r4 + 12];
842003e0:	11 ff fe 1f 	rMAC = rMAC AND 0xfffffffe;
842003e4:	1b c0       	r1 = r1 AND 0x1;
842003e6:	c9 12       	rMAC = rMAC OR r1;
842003e8:	11 aa       	MB[r0 + 16] = rMAC;

    return TRUE;
842003ea:	42 20       	r0 = Null + 1;

842003ec <Lc_rtp_decode_opmsg_set_content_protection_2>:
}
842003ec:	f1 48       	popm <FP, r4, rLink>;
842003ee:	d8 4c       	rts;

842003f0 <$_rtp_decode_opmsg_set_AAC_decoder>:
    }
    return NULL;
}

bool rtp_decode_opmsg_set_AAC_decoder(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842003f0:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842003f2:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842003f4:	08 f0 3f e9 	call (m) $_base_op_get_instance_data;
842003f8:	17 00       	r5 = r0 + Null;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned aac_operator_id;
    void *aac_codec;

    aac_operator_id = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_AAC_CODEC, OPERATOR_ID);
842003fa:	f1 88       	rMAC = M[r4 + 12];
842003fc:	8a c6       	r0 = rMAC AND 0xffff;

    aac_codec = get_AAC_codec(aac_operator_id);
842003fe:	06 f0 29 e9 	call (m) Lc_get_AAC_codec_1;
    if (aac_codec != NULL)
84200402:	10 04       	Null = r0 - Null;
84200404:	04 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_AAC_decoder_3;

84200406 <Lc_rtp_decode_opmsg_set_AAC_decoder_2>:
    {
        opx_data->aac_codec = aac_codec;
84200406:	7a 8f       	M[r5 + 20] = r0;
        return TRUE;
84200408:	42 20       	r0 = Null + 1;
8420040a:	02 6e       	jump (m) Lc_rtp_decode_opmsg_set_AAC_decoder_4;

8420040c <Lc_rtp_decode_opmsg_set_AAC_decoder_3>:
    }
    /* Operator not found, signal an error back. */
    return FALSE;
8420040c:	02 00       	r0 = Null + Null;

8420040e <Lc_rtp_decode_opmsg_set_AAC_decoder_4>:
}
8420040e:	f2 48       	popm <FP, r4, r5, rLink>;
84200410:	d8 4c       	rts;

84200412 <$_rtp_decode_opmsg_set_AAC_utility>:

bool rtp_decode_opmsg_set_AAC_utility(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200412:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84200414:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200416:	08 f0 3d e8 	call (m) $_base_op_get_instance_data;
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    AAC_UTILITY_SEL utility_selector;

    utility_selector = (AAC_UTILITY_SEL) OPMSG_FIELD_GET(message_data,
                        OPMSG_RTP_SET_AAC_UTILITY, UTILITY_SEL);
8420041a:	f1 88       	rMAC = M[r4 + 12];
8420041c:	89 c6       	rMAC = rMAC AND 0xffff;

    if ((utility_selector == AAC_LC_OVER_LATM)||(utility_selector == AAC_GENERIC))
8420041e:	09 08       	rMAC = SE8 rMAC;
84200420:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_AAC_utility_3;

84200422 <Lc_rtp_decode_opmsg_set_AAC_utility_2>:
84200422:	48 24       	Null = rMAC - 1;
84200424:	04 62       	if NE jump (m) Lc_rtp_decode_opmsg_set_AAC_utility_4;

84200426 <Lc_rtp_decode_opmsg_set_AAC_utility_3>:
    {
        opx_data->aac_utility_select = utility_selector;
84200426:	11 ba       	MB[r0 + 24] = rMAC;
        return TRUE;
84200428:	42 20       	r0 = Null + 1;
8420042a:	02 6e       	jump (m) Lc_rtp_decode_opmsg_set_AAC_utility_5;

8420042c <Lc_rtp_decode_opmsg_set_AAC_utility_4>:
    }
    /* Operator not found, signal an error back. */
    return FALSE;
8420042c:	02 00       	r0 = Null + Null;

8420042e <Lc_rtp_decode_opmsg_set_AAC_utility_5>:
}
8420042e:	f1 48       	popm <FP, r4, rLink>;
84200430:	d8 4c       	rts;

84200432 <$_rtp_decode_opmsg_set_max_packet_length>:

    return TRUE;
}

bool rtp_decode_opmsg_set_max_packet_length(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200432:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200434:	17 00       	r5 = r0 + Null;
84200436:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200438:	08 f0 3b e7 	call (m) $_base_op_get_instance_data;
8420043c:	10 09       	r6 = r0 + Null;
}

bool rtp_decode_opmsg_set_max_packet_length(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    if (opmgr_op_is_running(op_data))
8420043e:	3a 00       	r0 = r5 + Null;
84200440:	08 f0 3b e4 	call (m) $_opmgr_op_is_running;
84200444:	10 04       	Null = r0 - Null;
84200446:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_max_packet_length_3;

84200448 <Lc_rtp_decode_opmsg_set_max_packet_length_2>:
    {
        return FALSE;
84200448:	02 00       	r0 = Null + Null;
8420044a:	08 6e       	jump (m) Lc_rtp_decode_opmsg_set_max_packet_length_4;

8420044c <Lc_rtp_decode_opmsg_set_max_packet_length_3>:
    }
    else
    {
        opx_data->max_packet_len = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_MAX_PACKET_LENGTH, LENGTH);
8420044c:	f1 88       	rMAC = M[r4 + 12];
8420044e:	89 c6       	rMAC = rMAC AND 0xffff;
84200450:	81 f0 17 8e 	M[r6 + 92] = rMAC;
        opx_data->last_op_tag_octets = opx_data->max_packet_len;
84200454:	81 f0 1a 8e 	M[r6 + 104] = rMAC;
        return TRUE;
84200458:	42 20       	r0 = Null + 1;

8420045a <Lc_rtp_decode_opmsg_set_max_packet_length_4>:
    }
}
8420045a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420045c:	d8 4c       	rts;

8420045e <$_rtp_decode_opmsg_set_src_latency_mapping>:
bool rtp_decode_opmsg_set_src_latency_mapping(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420045e:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84200460:	17 00       	r5 = r0 + Null;
84200462:	18 09       	r6 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200464:	08 f0 2f e6 	call (m) $_base_op_get_instance_data;
84200468:	16 00       	r4 = r0 + Null;
bool rtp_decode_opmsg_set_src_latency_mapping(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    RTP_SRC_LATENCY_MAP *src_latency_map;
    unsigned count, num_entries, alloc_size;
    if (opmgr_op_is_running(op_data))
8420046a:	3a 00       	r0 = r5 + Null;
8420046c:	08 f0 2f e3 	call (m) $_opmgr_op_is_running;
84200470:	10 04       	Null = r0 - Null;
84200472:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_3;

84200474 <Lc_rtp_decode_opmsg_set_src_latency_mapping_2>:
    {
        return FALSE;
84200474:	02 00       	r0 = Null + Null;
84200476:	2f 6e       	jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_9;

84200478 <Lc_rtp_decode_opmsg_set_src_latency_mapping_3>:
    }
    num_entries = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, COUNT);
84200478:	81 f0 03 88 	rMAC = M[r6 + 12];
8420047c:	8f c6       	r5 = rMAC AND 0xffff;
    alloc_size = sizeof(RTP_SRC_LATENCY_MAP) + num_entries * sizeof(RTP_SRC_LATENCY_MAP_ENTRY);
8420047e:	ba 54       	r0 = r5 LSHIFT 3;
84200480:	12 21       	r0 = r0 + 4;
    src_latency_map = (RTP_SRC_LATENCY_MAP *)xpmalloc(alloc_size);
84200482:	c3 20       	r1 = Null + 3;
84200484:	ff fd 24 f0 	call (m) 0x4e2e;
84200488:	2b ed 
8420048a:	11 09       	r7 = r0 + Null;
    if (src_latency_map == NULL)
8420048c:	f4 61       	if EQ jump (m) Lc_rtp_decode_opmsg_set_src_latency_mapping_2;

8420048e <Lc_rtp_decode_opmsg_set_src_latency_mapping_4>:
    {
        return FALSE;
    }
    src_latency_map->num_entries = num_entries;
8420048e:	97 f0 00 ee 	M[r7 + Null] = r5;
    for (count = 0; count < num_entries; count++)
84200492:	03 00       	r1 = Null + Null;
84200494:	91 f0 04 20 	rMAC = r7 + 4;
84200498:	82 f0 10 20 	r0 = r6 + 16;
8420049c:	d8 05       	Null = r1 - r5;
8420049e:	02 f0 a9 e0 	if C jump (m) Lc__loop0;

842004a2 <Lc_rtp_decode_opmsg_set_src_latency_mapping_5>:
842004a2:	3c 09       	r10 = r5 + Null;
842004a4:	11 4c       	do (m) Lc__loop0;

842004a6 <Lc_rtp_decode_opmsg_set_src_latency_mapping_6>:
    {
        src_latency_map->entries[count].source_id =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 1);
842004a6:	13 e8       	r1 = M[r0 + Null];
842004a8:	54 88       	r2 = M[r0 + 4];
842004aa:	9b c6       	r1 = r1 AND 0xffff;
842004ac:	a4 c6       	r2 = r2 AND 0xffff;
842004ae:	9b 56       	r1 = r1 LSHIFT 16;
842004b0:	e3 00       	r1 = r2 + r1;
842004b2:	0b ee       	M[rMAC + Null] = r1;
        src_latency_map->entries[count].target_latency =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 2) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 3);
842004b4:	93 88       	r1 = M[r0 + 8];
842004b6:	d4 88       	r2 = M[r0 + 12];
842004b8:	9b c6       	r1 = r1 AND 0xffff;
842004ba:	a4 c6       	r2 = r2 AND 0xffff;
842004bc:	12 28       	r0 = r0 + 16;
842004be:	9b 56       	r1 = r1 LSHIFT 16;
842004c0:	e3 00       	r1 = r2 + r1;
842004c2:	4b 8e       	M[rMAC + 4] = r1;
842004c4:	09 22       	rMAC = rMAC + 8;

842004c6 <Lc__loop0>:
    if (src_latency_map == NULL)
    {
        return FALSE;
    }
    src_latency_map->num_entries = num_entries;
    for (count = 0; count < num_entries; count++)
842004c6:	32 b9       	r0 = M[r4 + 112];
842004c8:	ff fd 25 f0 	call (m) 0x4f62;
842004cc:	3b e4 
        src_latency_map->entries[count].target_latency =
            (OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 2) << 16) +
             OPMSG_FIELD_GET_FROM_OFFSET(message_data, OPMSG_RTP_SET_SRC_LATENCY_MAPPING, ENTRIES, 4*count + 3);
    }
    pfree(opx_data->src_latency_map);
    opx_data->src_latency_map = src_latency_map;
842004ce:	69 f0 1c 8e 	M[r4 + 112] = r7;
    return TRUE;
842004d2:	42 20       	r0 = Null + 1;

842004d4 <Lc_rtp_decode_opmsg_set_src_latency_mapping_9>:
}
842004d4:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842004d6:	d8 4c       	rts;

842004d8 <$_rtp_decode_opmsg_set_packing>:


bool rtp_decode_opmsg_set_packing(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842004d8:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842004da:	17 00       	r5 = r0 + Null;
842004dc:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842004de:	08 f0 35 e2 	call (m) $_base_op_get_instance_data;
842004e2:	10 09       	r6 = r0 + Null;
    L2_DBG_MSG("rtp_decode_opmsg_set_packing: DATAFORMAT_32 is enabled, there is no need to pack");
    return TRUE;
#else
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned packing;
    if (opmgr_op_is_running(op_data))
842004e4:	3a 00       	r0 = r5 + Null;
842004e6:	07 f0 35 ef 	call (m) $_opmgr_op_is_running;
842004ea:	10 04       	Null = r0 - Null;
842004ec:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_packing_3;

842004ee <Lc_rtp_decode_opmsg_set_packing_2>:
    {
        return FALSE;
842004ee:	02 00       	r0 = Null + Null;
842004f0:	09 6e       	jump (m) Lc_rtp_decode_opmsg_set_packing_4;

842004f2 <Lc_rtp_decode_opmsg_set_packing_3>:
    }
    else
    {
        packing = OPMSG_FIELD_GET(message_data, OPMSG_RTP_SET_PACKING, PACKING);
842004f2:	f1 88       	rMAC = M[r4 + 12];
        if (packing != 0)
        {
            opx_data->pack_latency_buffer = TRUE;
842004f4:	02 00       	r0 = Null + Null;
842004f6:	89 c6       	rMAC = rMAC AND 0xffff;
842004f8:	21 f0 42 ce 	if NE r0 = Null + 1;
842004fc:	82 f0 1d 8e 	M[r6 + 116] = r0;
        }
        else
        {
            opx_data->pack_latency_buffer = FALSE;
        }
        return TRUE;
84200500:	42 20       	r0 = Null + 1;

84200502 <Lc_rtp_decode_opmsg_set_packing_4>:
    }
#endif
}
84200502:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200504:	d8 4c       	rts;

84200506 <$_rtp_decode_opmsg_set_ttp_latency>:
    /* Operator not found, signal an error back. */
    return FALSE;
}

bool rtp_decode_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200506:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200508:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420050a:	08 f0 29 e1 	call (m) $_base_op_get_instance_data;
8420050e:	17 00       	r5 = r0 + Null;

bool rtp_decode_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    if ((opx_data->mode !=RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200510:	39 90       	rMAC = MBS[r5 + 8];
84200512:	48 24       	Null = rMAC - 1;
84200514:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_4;

84200516 <Lc_rtp_decode_opmsg_set_ttp_latency_2>:
84200516:	c8 24       	Null = rMAC - 3;
84200518:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_4;

8420051a <Lc_rtp_decode_opmsg_set_ttp_latency_3>:
    {
        return FALSE;
8420051a:	02 00       	r0 = Null + Null;
8420051c:	0b 6e       	jump (m) Lc_rtp_decode_opmsg_set_ttp_latency_5;

8420051e <Lc_rtp_decode_opmsg_set_ttp_latency_4>:
    }

    ttp_configure_latency(opx_data->ttp_instance, ttp_get_msg_latency(message_data));
8420051e:	32 00       	r0 = r4 + Null;
84200520:	ff fd b0 f0 	call (m) 0x16706;
84200524:	27 ef 
84200526:	13 00       	r1 = r0 + Null;
84200528:	3a a9       	r0 = M[r5 + 80];
8420052a:	ff fd b1 f0 	call (m) 0x167da;
8420052e:	31 e5 
    return TRUE;
84200530:	42 20       	r0 = Null + 1;

84200532 <Lc_rtp_decode_opmsg_set_ttp_latency_5>:
}
84200532:	f2 48       	popm <FP, r4, r5, rLink>;
84200534:	d8 4c       	rts;

84200536 <$_rtp_decode_opmsg_set_latency_limits>:

bool rtp_decode_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200536:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84200538:	1f 00       	r5 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
8420053a:	07 f0 39 ef 	call (m) $_base_op_get_instance_data;
8420053e:	16 00       	r4 = r0 + Null;
bool rtp_decode_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    TIME_INTERVAL min_latency, max_latency;

    if ((opx_data->mode !=RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200540:	31 90       	rMAC = MBS[r4 + 8];
84200542:	48 24       	Null = rMAC - 1;
84200544:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_latency_limits_4;

84200546 <Lc_rtp_decode_opmsg_set_latency_limits_2>:
84200546:	c8 24       	Null = rMAC - 3;
84200548:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_latency_limits_4;

8420054a <Lc_rtp_decode_opmsg_set_latency_limits_3>:
    {
        return FALSE;
8420054a:	02 00       	r0 = Null + Null;
8420054c:	0e 6e       	jump (m) Lc_rtp_decode_opmsg_set_latency_limits_5;

8420054e <Lc_rtp_decode_opmsg_set_latency_limits_4>:
    }
    ttp_get_msg_latency_limits(message_data, &min_latency, &max_latency);
8420054e:	44 11       	r2 = FP + 20;
84200550:	03 11       	r1 = FP + 16;
84200552:	3a 00       	r0 = r5 + Null;
84200554:	ff fd b0 f0 	call (m) 0x1673c;
84200558:	29 ef 
    ttp_configure_latency_limits(opx_data->ttp_instance, min_latency, max_latency);
8420055a:	2c d8       	r2 = M[FP + 20];
8420055c:	23 d8       	r1 = M[FP + 16];
8420055e:	32 a9       	r0 = M[r4 + 80];
84200560:	ff fd b1 f0 	call (m) 0x167fa;
84200564:	3b e4 

    return TRUE;
84200566:	42 20       	r0 = Null + 1;

84200568 <Lc_rtp_decode_opmsg_set_latency_limits_5>:
}
84200568:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420056a:	d8 4c       	rts;

8420056c <$_rtp_decode_opmsg_set_ttp_params>:

bool rtp_decode_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420056c:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
8420056e:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200570:	07 f0 23 ee 	call (m) $_base_op_get_instance_data;
84200574:	17 00       	r5 = r0 + Null;
bool rtp_decode_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    ttp_params params;

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
84200576:	39 90       	rMAC = MBS[r5 + 8];
84200578:	48 24       	Null = rMAC - 1;
8420057a:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_params_4;

8420057c <Lc_rtp_decode_opmsg_set_ttp_params_2>:
8420057c:	c8 24       	Null = rMAC - 3;
8420057e:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_ttp_params_4;

84200580 <Lc_rtp_decode_opmsg_set_ttp_params_3>:
    {
        return FALSE;
84200580:	02 00       	r0 = Null + Null;
84200582:	0c 6e       	jump (m) Lc_rtp_decode_opmsg_set_ttp_params_5;

84200584 <Lc_rtp_decode_opmsg_set_ttp_params_4>:
    }

    ttp_get_msg_params(&params, message_data);
84200584:	02 11       	r0 = FP + 16;
84200586:	33 00       	r1 = r4 + Null;
84200588:	ff fd b0 f0 	call (m) 0x16786;
8420058c:	3f ef 
    ttp_configure_params(opx_data->ttp_instance, &params);
8420058e:	03 11       	r1 = FP + 16;
84200590:	3a a9       	r0 = M[r5 + 80];
84200592:	ff fd b1 f0 	call (m) 0x16822;
84200596:	31 e4 

    return TRUE;
84200598:	42 20       	r0 = Null + 1;

8420059a <Lc_rtp_decode_opmsg_set_ttp_params_5>:
}
8420059a:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
8420059c:	d8 4c       	rts;

8420059e <$_rtp_decode_opmsg_set_sample_rate>:


bool rtp_decode_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420059e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842005a0:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842005a2:	07 f0 31 ec 	call (m) $_base_op_get_instance_data;


bool rtp_decode_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned sample_rate = 25 * OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_SAMPLE_RATE, SAMPLE_RATE);
842005a6:	f1 88       	rMAC = M[r4 + 12];
842005a8:	89 c6       	rMAC = rMAC AND 0xffff;
842005aa:	4b 46       	r1 = rMAC * 25 (int);

    if ((opx_data->mode != RTP_DECODE) && (opx_data->mode != RTP_TTP_ONLY))
842005ac:	11 90       	rMAC = MBS[r0 + 8];
842005ae:	48 24       	Null = rMAC - 1;
842005b0:	05 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_sample_rate_4;

842005b2 <Lc_rtp_decode_opmsg_set_sample_rate_2>:
842005b2:	c8 24       	Null = rMAC - 3;
842005b4:	03 60       	if EQ jump (m) Lc_rtp_decode_opmsg_set_sample_rate_4;

842005b6 <Lc_rtp_decode_opmsg_set_sample_rate_3>:
    {
        return FALSE;
842005b6:	02 00       	r0 = Null + Null;
842005b8:	07 6e       	jump (m) Lc_rtp_decode_opmsg_set_sample_rate_5;

842005ba <Lc_rtp_decode_opmsg_set_sample_rate_4>:
    }

    opx_data->sample_rate = sample_rate;
842005ba:	93 af       	M[r0 + 88] = r1;
    ttp_configure_rate(opx_data->ttp_instance, sample_rate);
842005bc:	12 a9       	r0 = M[r0 + 80];
842005be:	ff fd b1 f0 	call (m) 0x1684c;
842005c2:	2f e4 

    return TRUE;
842005c4:	42 20       	r0 = Null + 1;

842005c6 <Lc_rtp_decode_opmsg_set_sample_rate_5>:
}
842005c6:	f1 48       	popm <FP, r4, rLink>;
842005c8:	d8 4c       	rts;

842005ca <$_rtp_decode_opmsg_set_buffer_size>:

bool rtp_decode_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005ca:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842005cc:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842005ce:	07 f0 25 eb 	call (m) $_base_op_get_instance_data;
}

bool rtp_decode_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    opx_data->latency_buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_BUFFER_SIZE, BUFFER_SIZE);
842005d2:	f1 88       	rMAC = M[r4 + 12];
842005d4:	89 c6       	rMAC = rMAC AND 0xffff;
842005d6:	51 af       	M[r0 + 84] = rMAC;

    if (opx_data->latency_buffer_size > RTP_DECODE_DEFAULT_BUFFER_SIZE)
842005d8:	10 f0 00 26 	Null = rMAC - 512;
842005dc:	09 f0 89 e0 	if LS jump (m) Lc_rtp_decode_opmsg_set_buffer_size_3;

842005e0 <Lc_rtp_decode_opmsg_set_buffer_size_2>:
    {
        opx_data->kick_on_full_output = TRUE;
842005e0:	41 20       	rMAC = Null + 1;
842005e2:	d1 be       	M[r0 + 108] = rMAC;

842005e4 <Lc_rtp_decode_opmsg_set_buffer_size_3>:
    }

    return TRUE;
842005e4:	42 20       	r0 = Null + 1;

842005e6 <Lc_rtp_decode_opmsg_set_buffer_size_4>:
}
842005e6:	f1 48       	popm <FP, r4, rLink>;
842005e8:	d8 4c       	rts;

842005ea <$_rtp_decode_opmsg_set_latency_change_notification>:
    }
#endif
}

bool rtp_decode_opmsg_set_latency_change_notification(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842005ea:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842005ec:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
842005ee:	07 f0 25 ea 	call (m) $_base_op_get_instance_data;
bool rtp_decode_opmsg_set_latency_change_notification(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    opx_data->latency_change_notify_enable = OPMSG_FIELD_GET(message_data,
                                             OPMSG_RTP_SET_LATENCY_CHANGE_NOTIFICATION, ENABLE_LATENCY_NOTIFY) & 1;
842005f2:	11 a2       	rMAC = MBU[r0 + 16];
842005f4:	f3 88       	r1 = M[r4 + 12];
842005f6:	11 ff fd 1f 	rMAC = rMAC AND 0xfffffffd;
842005fa:	1b c0       	r1 = r1 AND 0x1;
842005fc:	1b 54       	r1 = r1 LSHIFT 1;
842005fe:	c9 12       	rMAC = rMAC OR r1;
84200600:	11 aa       	MB[r0 + 16] = rMAC;

    return TRUE;
84200602:	42 20       	r0 = Null + 1;

84200604 <Lc_rtp_decode_opmsg_set_latency_change_notification_2>:
}
84200604:	f1 48       	popm <FP, r4, rLink>;
84200606:	d8 4c       	rts;

84200608 <$_rtp_decode_process_data>:
    }
}


void rtp_decode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200608:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
8420060a:	54 4c       	SP = SP + 80;
8420060c:	42 de       	M[FP + 32] = r0;
8420060e:	4b de       	M[FP + 36] = r1;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200610:	07 f0 23 e9 	call (m) $_base_op_get_instance_data;
84200614:	17 00       	r5 = r0 + Null;
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);

    unsigned packet_size;
    tCbuffer *clone_buffer;
    tCbuffer *buffer;
    tCbuffer *ip_buffer = opx_data->ip_buffer;
84200616:	7a f0 0f 88 	r8 = M[r5 + 60];
    tCbuffer *op_buffer = opx_data->op_buffer;
8420061a:	39 a8       	rMAC = M[r5 + 64];
8420061c:	51 de       	M[FP + 40] = rMAC;
    unsigned available_octets, available_space;
    unsigned rtp_header_size = RTP_MINIMUM_HEADER_SIZE +
                   (opx_data->scms_enable ? SCMS_HEADER_SIZE : 0);
8420061e:	39 a2       	rMAC = MBU[r5 + 16];
84200620:	42 23       	r0 = Null + 13;
84200622:	03 23       	r1 = Null + 12;
84200624:	09 c0       	rMAC = rMAC AND 0x1;
84200626:	01 f2 03 c0 	if NE r1 = r0 + Null;
8420062a:	5b de       	M[FP + 44] = r1;
    metadata_tag* tag;

    patch_fn(rtp_decode_process_data);

    if ((ip_buffer == NULL) || (op_buffer == NULL))
8420062c:	0f fa 00 c2 	Null = r8 - Null;
84200630:	00 f0 97 e6 	if EQ jump (m) Lc_rtp_decode_process_data_60;

84200634 <Lc_rtp_decode_process_data_2>:
84200634:	51 d8       	rMAC = M[FP + 40];
84200636:	00 f0 91 e6 	if EQ jump (m) Lc_rtp_decode_process_data_60;

8420063a <Lc_rtp_decode_process_data_3>:
    {
        return;
    }

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
8420063a:	78 b9       	Null = M[r5 + 116];
8420063c:	06 60       	if EQ jump (m) Lc_rtp_decode_process_data_5;

8420063e <Lc_rtp_decode_process_data_4>:
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
8420063e:	79 a8       	rMAC = M[r5 + 68];
84200640:	61 de       	M[FP + 48] = rMAC;
        buffer = opx_data->u.pack.frame_buffer;
84200642:	b9 a8       	rMAC = M[r5 + 72];
84200644:	69 de       	M[FP + 52] = rMAC;
84200646:	05 6e       	jump (m) Lc_rtp_decode_process_data_6;

84200648 <Lc_rtp_decode_process_data_5>:
    }
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
84200648:	79 a8       	rMAC = M[r5 + 68];
8420064a:	61 de       	M[FP + 48] = rMAC;
        buffer = opx_data->op_buffer;
8420064c:	51 d8       	rMAC = M[FP + 40];
8420064e:	69 de       	M[FP + 52] = rMAC;

84200650 <Lc_rtp_decode_process_data_6>:
     */
    /* TODO There could be an octet difference between _ex (used by a2dp endpoint)
     * and cbuffer (used by octet_buffer therefore by RTP) when asking for available data.
     * To avoid that difference use the buff_metadata_available_octets until RTP is not
     * convert to _ex buffer. NOTE  _ex buffer does not support unaligned copy yet.  */
    available_octets = buff_metadata_available_octets(ip_buffer);
84200650:	52 08       	r0 = r8 + Null;
84200652:	ff fd 8b f0 	call (m) 0x11d04;
84200656:	33 e5 
84200658:	13 09       	r9 = r0 + Null;
    available_space = cbuffer_calc_amount_space_ex(op_buffer);
8420065a:	52 d8       	r0 = M[FP + 40];
8420065c:	08 f0 21 ed 	call (m) $_cbuffer_calc_amount_space_ex;
84200660:	16 00       	r4 = r0 + Null;

    L4_DBG_MSG2("RTP START available data (octets) = %d, available space (octets) = %d",
            cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));
84200662:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200666:	08 25       	Null = rMAC - 4;
84200668:	10 68       	if LT jump (m) Lc_rtp_decode_process_data_8;

8420066a <Lc_rtp_decode_process_data_7>:
8420066a:	52 08       	r0 = r8 + Null;
8420066c:	08 f0 21 ea 	call (m) $_cbuffer_calc_amount_data_ex;
84200670:	10 09       	r6 = r0 + Null;
84200672:	52 d8       	r0 = M[FP + 40];
84200674:	08 f0 29 ec 	call (m) $_cbuffer_calc_amount_space_ex;
84200678:	14 00       	r2 = r0 + Null;
8420067a:	55 f1 02 f0 	r0 = Null + 357565082;
8420067e:	9a 42 
84200680:	43 08       	r1 = r6 + Null;
84200682:	ff fd 01 f0 	call (m) 0x9c8;
84200686:	27 ea 

84200688 <Lc_rtp_decode_process_data_8>:

    if (opx_data->kick_on_full_output && (available_octets > available_space))
84200688:	f8 b8       	Null = M[r5 + 108];
8420068a:	08 60       	if EQ jump (m) Lc_rtp_decode_process_data_11;

8420068c <Lc_rtp_decode_process_data_9>:
8420068c:	6f fb 00 c2 	Null = r9 - r4;
84200690:	09 f0 8b e0 	if LS jump (m) Lc_rtp_decode_process_data_11;

84200694 <Lc_rtp_decode_process_data_10>:
    {
        /* Kick forwards to keep data flowing in case the next operator is a splitter */
        touched->sources = TOUCHED_SOURCE_0;
84200694:	41 20       	rMAC = Null + 1;
84200696:	4a d8       	r0 = M[FP + 36];
84200698:	11 ee       	M[r0 + Null] = rMAC;

8420069a <Lc_rtp_decode_process_data_11>:
    }

    if(opx_data->mode == RTP_PASSTHROUGH)
8420069a:	39 90       	rMAC = MBS[r5 + 8];
8420069c:	1c 62       	if NE jump (m) Lc_rtp_decode_process_data_16;

8420069e <Lc_rtp_decode_process_data_12>:
    {
        unsigned octets_copied = cbuffer_copy_ex(op_buffer, ip_buffer, available_octets);
8420069e:	5c 08       	r2 = r9 + Null;
842006a0:	53 08       	r1 = r8 + Null;
842006a2:	52 d8       	r0 = M[FP + 40];
842006a4:	06 f0 25 e9 	call (m) $_cbuffer_copy_ex;

        /* copy as many data as possible to the output buffer.*/
        if (octets_copied > 0)
842006a8:	10 04       	Null = r0 - Null;
842006aa:	0a 60       	if EQ jump (m) Lc_rtp_decode_process_data_14;

842006ac <Lc_rtp_decode_process_data_13>:
        {
            /* Propagate any metadata to the output.*/
            metadata_strict_transport(ip_buffer, op_buffer, octets_copied);
842006ac:	14 00       	r2 = r0 + Null;
842006ae:	52 08       	r0 = r8 + Null;
842006b0:	53 d8       	r1 = M[FP + 40];
842006b2:	ff fd 8c f0 	call (m) 0x12076;
842006b6:	25 ee 
            touched->sources = TOUCHED_SOURCE_0;
842006b8:	41 20       	rMAC = Null + 1;
842006ba:	4a d8       	r0 = M[FP + 36];
842006bc:	11 ee       	M[r0 + Null] = rMAC;

842006be <Lc_rtp_decode_process_data_14>:
        }

        if (cbuffer_calc_amount_data_ex(ip_buffer) == 0)
842006be:	52 08       	r0 = r8 + Null;
842006c0:	08 f0 2d e7 	call (m) $_cbuffer_calc_amount_data_ex;
842006c4:	10 04       	Null = r0 - Null;
842006c6:	01 f0 81 e5 	if NE jump (m) Lc_rtp_decode_process_data_60;

842006ca <Lc_rtp_decode_process_data_15>:
        {
            touched->sinks = TOUCHED_SINK_0;
842006ca:	41 20       	rMAC = Null + 1;
842006cc:	4a d8       	r0 = M[FP + 36];
842006ce:	51 8e       	M[r0 + 4] = rMAC;
842006d0:	0f f0 f7 e4 	jump (m) Lc_rtp_decode_process_data_60;

842006d4 <Lc_rtp_decode_process_data_16>:
        }
        return;
    }
    else if ((opx_data->mode == RTP_TTP_ONLY) && (opx_data->codec_type == APTX))
842006d4:	c8 24       	Null = rMAC - 3;
842006d6:	2b 62       	if NE jump (m) Lc_rtp_decode_process_data_26;

842006d8 <Lc_rtp_decode_process_data_17>:
842006d8:	79 a0       	rMAC = MBS[r5 + 17];
842006da:	29 62       	if NE jump (m) Lc_rtp_decode_process_data_26;

842006dc <Lc_rtp_decode_process_data_18>:
    {

        unsigned octets_copied = MIN(available_octets, available_space);
842006dc:	6f fb 00 c2 	Null = r9 - r4;
842006e0:	02 f0 89 e0 	if C jump (m) Lc_rtp_decode_process_data_20;

842006e4 <Lc_rtp_decode_process_data_19>:
842006e4:	5e 08       	r4 = r9 + Null;
842006e6:	01 6e       	jump (m) Lc_rtp_decode_process_data_20;

842006e8 <Lc_rtp_decode_process_data_20>:
         * actually exists. It can only ever process 4 octets at a time,
         * so rounding down here should always be safe
         */
        octets_copied &= ~1;

        if (octets_copied > 0)
842006e8:	66 ff fe 1f 	r4 = r4 AND 0xfffffffe;
842006ec:	19 60       	if EQ jump (m) Lc_rtp_decode_process_data_25;

842006ee <Lc_rtp_decode_process_data_22>:
        {
            metadata_transport_with_ttp(opx_data, octets_copied);
842006ee:	33 00       	r1 = r4 + Null;
842006f0:	3a 00       	r0 = r5 + Null;
842006f2:	04 f0 25 e7 	call (m) Lc_metadata_transport_with_ttp_1;
            if (opx_data->pack_latency_buffer)
842006f6:	78 b9       	Null = M[r5 + 116];
842006f8:	0b 60       	if EQ jump (m) Lc_rtp_decode_process_data_24;

842006fa <Lc_rtp_decode_process_data_23>:
            {
                /* Pack to internal buffer. */
                cbuffer_copy_ex(opx_data->u.pack.internal_buffer, ip_buffer, octets_copied);
842006fa:	fa a8       	r0 = M[r5 + 76];
842006fc:	34 00       	r2 = r4 + Null;
842006fe:	53 08       	r1 = r8 + Null;
84200700:	06 f0 29 e6 	call (m) $_cbuffer_copy_ex;
                /* Copy as much as possible to the output. */
                rtp_decode_empty_internal_buffers(opx_data,touched);
84200704:	3a 00       	r0 = r5 + Null;
84200706:	4b d8       	r1 = M[FP + 36];
84200708:	04 f0 2d ee 	call (m) Lc_rtp_decode_empty_internal_buffers_1;
8420070c:	09 6e       	jump (m) Lc_rtp_decode_process_data_25;

8420070e <Lc_rtp_decode_process_data_24>:
            }
            else
            {
                /* Copy to output. */
                cbuffer_copy_ex(op_buffer, ip_buffer, octets_copied);
8420070e:	34 00       	r2 = r4 + Null;
84200710:	53 08       	r1 = r8 + Null;
84200712:	52 d8       	r0 = M[FP + 40];
84200714:	06 f0 35 e5 	call (m) $_cbuffer_copy_ex;
                touched->sources = TOUCHED_SOURCE_0;
84200718:	41 20       	rMAC = Null + 1;
8420071a:	4a d8       	r0 = M[FP + 36];
8420071c:	11 ee       	M[r0 + Null] = rMAC;

8420071e <Lc_rtp_decode_process_data_25>:
            }
        }

        /* Kick back if less than one whole word in the input buffer */
        if (cbuffer_calc_amount_data_ex(ip_buffer) < 2)
8420071e:	52 08       	r0 = r8 + Null;
84200720:	08 f0 2d e4 	call (m) $_cbuffer_calc_amount_data_ex;
84200724:	90 24       	Null = r0 - 2;
84200726:	d2 65       	if NC jump (m) Lc_rtp_decode_process_data_15;

84200728 <Lc_18>:
84200728:	0f f0 9f e4 	jump (m) Lc_rtp_decode_process_data_60;

8420072c <Lc_rtp_decode_process_data_26>:
        }
        return;
    }

    /* Get the next from the input buffer.*/
    tag = buff_metadata_peek(ip_buffer);
8420072c:	52 08       	r0 = r8 + Null;
8420072e:	ff fd 8a f0 	call (m) 0x11cc6;
84200732:	39 ec 
84200734:	16 00       	r4 = r0 + Null;
    packet_size = get_tag_size (tag);
84200736:	02 f0 3b e1 	call (m) Lc_get_tag_size_1;
8420073a:	10 09       	r6 = r0 + Null;

    /* Empty the internal buffers to create some space. */
    rtp_decode_empty_internal_buffers(opx_data,touched);
8420073c:	3a 00       	r0 = r5 + Null;
8420073e:	4b d8       	r1 = M[FP + 36];
84200740:	04 f0 35 ec 	call (m) Lc_rtp_decode_empty_internal_buffers_1;
84200744:	41 20       	rMAC = Null + 1;
84200746:	71 de       	M[FP + 56] = rMAC;
84200748:	3e 6e       	jump (m) Lc_rtp_decode_process_data_34;

8420074a <Lc_rtp_decode_process_data_27>:
                        (opx_data->sample_rate/2)) / opx_data->sample_rate);
                }
#endif
                else
                {
                    cbuffer_advance_read_ptr_ex(ip_buffer, header_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH);
8420074a:	33 25       	r1 = r4 - 4;
8420074c:	52 08       	r0 = r8 + Null;
8420074e:	08 f0 35 ee 	call (m) $_cbuffer_advance_read_ptr_ex;

84200752 <Lc_rtp_decode_process_data_28>:
                }

                /* Copy the payload without the padding to the clone buffer. There the
                 * decoded frame is analysed to see how many sample is in it.  */
                cbuffer_copy_ex(clone_buffer, ip_buffer, payload_size);
84200752:	4c 08       	r2 = r7 + Null;
84200754:	53 08       	r1 = r8 + Null;
84200756:	62 d8       	r0 = M[FP + 48];
84200758:	06 f0 31 e3 	call (m) $_cbuffer_copy_ex;

                /* Partially decode the frame to get a robust sample count determination
                 * for the time to play. */
                get_samples_in_packet(opx_data, &frame_data);
8420075c:	03 15       	r1 = FP + 80;
8420075e:	3a 00       	r0 = r5 + Null;
84200760:	04 f0 3d ef 	call (m) $_get_samples_in_packet;

                if(opx_data->mode == RTP_STRIP)
84200764:	39 90       	rMAC = MBS[r5 + 8];
84200766:	88 24       	Null = rMAC - 2;
84200768:	cd 62       	if NE jump (m) Lc_rtp_decode_process_data_55;

8420076a <Lc_rtp_decode_process_data_29>:
                {
                    /* Make the data available in the frame buffer. */
                    cbuffer_advance_write_ptr_ex(buffer, payload_size);
8420076a:	4b 08       	r1 = r7 + Null;
8420076c:	6a d8       	r0 = M[FP + 52];
8420076e:	08 f0 2f ea 	call (m) $_cbuffer_advance_write_ptr_ex;
                    /* Remove all the encoded data from the clone buffer. */
                    cbuffer_advance_read_ptr(clone_buffer, payload_size);
84200772:	4b 08       	r1 = r7 + Null;
84200774:	62 d8       	r0 = M[FP + 48];
84200776:	ff fd 5d f1 	call (m) 0x2c216;
8420077a:	21 e5 
                    /* Delete the tag as it is not used any more.  */
                    delete_consumed_metadata_tag(ip_buffer, packet_size);
8420077c:	43 08       	r1 = r6 + Null;
8420077e:	52 08       	r0 = r8 + Null;
84200780:	01 f0 3d ef 	call (m) Lc_delete_consumed_metadata_tag_1;
                    /* Update the metadata in the output buffer.*/
                    buff_metadata_append(buffer, NULL, payload_size, 0);
84200784:	05 00       	r3 = Null + Null;
84200786:	03 00       	r1 = Null + Null;
84200788:	4c 08       	r2 = r7 + Null;
8420078a:	6a d8       	r0 = M[FP + 52];
8420078c:	ff fd 89 f0 	call (m) 0x11adc;
84200790:	31 ea 

84200792 <Lc_rtp_decode_process_data_30>:
                    /* Kick forward. */
                    touched->sources = TOUCHED_SOURCE_0;
84200792:	72 d8       	r0 = M[FP + 56];
84200794:	49 d8       	rMAC = M[FP + 36];
84200796:	0a ee       	M[rMAC + Null] = r0;

84200798 <Lc_rtp_decode_process_data_31>:
                        touched->sources = TOUCHED_SOURCE_0;
                    }
                }

#ifdef DEBUG_RTP_DECODE
                opx_data->rtp_decode_packet_count++;
84200798:	39 99       	rMAC = M[r5 + 48];
8420079a:	49 20       	rMAC = rMAC + 1;
8420079c:	39 9f       	M[r5 + 48] = rMAC;
#endif
                /* discard any padding */
                if (padding_amount != 0)
8420079e:	7b d8       	r1 = M[FP + 60];
842007a0:	04 60       	if EQ jump (m) Lc_rtp_decode_process_data_33;

842007a2 <Lc_rtp_decode_process_data_32>:
                {
                    cbuffer_advance_read_ptr_ex(ip_buffer, padding_amount);
842007a2:	52 08       	r0 = r8 + Null;
842007a4:	08 f0 3f eb 	call (m) $_cbuffer_advance_read_ptr_ex;

842007a8 <Lc_rtp_decode_process_data_33>:
                }

            }
        }
        available_octets -= packet_size;
842007a8:	00 f8 3b c2 	r9 = r9 - r6;

        /* unpack to output if possible. */
        rtp_decode_empty_internal_buffers(opx_data,touched);
842007ac:	3a 00       	r0 = r5 + Null;
842007ae:	4b d8       	r1 = M[FP + 36];
842007b0:	04 f0 25 e9 	call (m) Lc_rtp_decode_empty_internal_buffers_1;

        /* Read the next packet tag. */
        tag = buff_metadata_peek(ip_buffer);
842007b4:	52 08       	r0 = r8 + Null;
842007b6:	ff fd 8a f0 	call (m) 0x11cc6;
842007ba:	31 e8 
842007bc:	16 00       	r4 = r0 + Null;
        packet_size = get_tag_size (tag);
842007be:	01 f0 33 ed 	call (m) Lc_get_tag_size_1;
842007c2:	10 09       	r6 = r0 + Null;

842007c4 <Lc_rtp_decode_process_data_34>:
    packet_size = get_tag_size (tag);

    /* Empty the internal buffers to create some space. */
    rtp_decode_empty_internal_buffers(opx_data,touched);

    while ( (packet_size != 0) && (available_octets >= packet_size))
842007c4:	0f f8 00 c2 	Null = r6 - Null;
842007c8:	a9 60       	if EQ jump (m) Lc_rtp_decode_process_data_58;

842007ca <Lc_rtp_decode_process_data_35>:
842007ca:	8f fb 00 c2 	Null = r9 - r6;
842007ce:	a6 64       	if NC jump (m) Lc_rtp_decode_process_data_58;

842007d0 <Lc_rtp_decode_process_data_36>:
    {
        if(!tag_valid(tag, opx_data))
842007d0:	3b 00       	r1 = r5 + Null;
842007d2:	32 00       	r0 = r4 + Null;
842007d4:	01 f0 3f e9 	call (m) Lc_tag_valid_1;
842007d8:	10 04       	Null = r0 - Null;
842007da:	b6 60       	if EQ jump (m) Lc_rtp_decode_process_data_60;

842007dc <Lc_rtp_decode_process_data_37>:
        }
        /* Is there space in the sink for the unpacked data?
         * this needs to be a quick check and hence don't worry
         * about calculating the header size which isn't copied.
         */
        if ((cbuffer_calc_amount_space_ex(clone_buffer) - 4 ) < packet_size)
842007dc:	62 d8       	r0 = M[FP + 48];
842007de:	08 f0 3f e0 	call (m) $_cbuffer_calc_amount_space_ex;
842007e2:	11 25       	rMAC = r0 - 4;
842007e4:	8f f1 00 c2 	Null = rMAC - r6;
842007e8:	02 f0 ad e0 	if C jump (m) Lc_rtp_decode_process_data_40;

842007ec <Lc_rtp_decode_process_data_38>:
        {
            L4_DBG_MSG2("RTP END  available data (octets) = %d, available space (octets) = %d !!output space smaller than packet size!!",
                    cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));
842007ec:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842007f0:	08 25       	Null = rMAC - 4;
842007f2:	aa 68       	if LT jump (m) Lc_rtp_decode_process_data_60;

842007f4 <Lc_rtp_decode_process_data_39>:
842007f4:	52 08       	r0 = r8 + Null;
842007f6:	07 f0 37 ed 	call (m) $_cbuffer_calc_amount_data_ex;
842007fa:	16 00       	r4 = r0 + Null;
842007fc:	52 d8       	r0 = M[FP + 40];
842007fe:	07 f0 3f ef 	call (m) $_cbuffer_calc_amount_space_ex;
84200802:	14 00       	r2 = r0 + Null;
84200804:	55 f1 02 f0 	r0 = Null + 357565152;
84200808:	e0 42 
8420080a:	33 00       	r1 = r4 + Null;
8420080c:	ff fd 00 f0 	call (m) 0x9c8;
84200810:	3d ed 
84200812:	9a 6e       	jump (m) Lc_rtp_decode_process_data_60;

84200814 <Lc_rtp_decode_process_data_40>:
            return;
        }

        if (packet_size < (rtp_header_size +
                opx_data->payload_header_size))
84200814:	79 98       	rMAC = M[r5 + 36];
84200816:	5a d8       	r0 = M[FP + 44];
84200818:	51 00       	rMAC = r0 + rMAC;
8420081a:	1f f8 00 c2 	Null = r6 - rMAC;
8420081e:	02 f0 97 e0 	if C jump (m) Lc_rtp_decode_process_data_42;

84200822 <Lc_rtp_decode_process_data_41>:
        {
            /* packet is too small to contain header so discard it.*/
            cbuffer_advance_read_ptr_ex(ip_buffer, packet_size);
84200822:	43 08       	r1 = r6 + Null;
84200824:	52 08       	r0 = r8 + Null;
84200826:	08 f0 3d e7 	call (m) $_cbuffer_advance_read_ptr_ex;
            delete_consumed_metadata_tag(ip_buffer, packet_size);
8420082a:	43 08       	r1 = r6 + Null;
8420082c:	52 08       	r0 = r8 + Null;
8420082e:	01 f0 2f ea 	call (m) Lc_delete_consumed_metadata_tag_1;
84200832:	bb 6f       	jump (m) Lc_rtp_decode_process_data_33;

84200834 <Lc_rtp_decode_process_data_42>:
        }
        else
        {
            unsigned int fixed_header_first_part[RTP_FIXED_HEADER_FIRST_PART_LENGTH];
            /* read in first few bytes of RTP header */
            unpack_cbuff_to_array((int*)fixed_header_first_part, ip_buffer, RTP_FIXED_HEADER_FIRST_PART_LENGTH);
84200834:	04 21       	r2 = Null + 4;
84200836:	02 14       	r0 = FP + 64;
84200838:	53 08       	r1 = r8 + Null;
8420083a:	05 f0 31 e6 	call (m) $_unpack_cbuff_to_array;

            /* validate version */
            if ((fixed_header_first_part[0] & RTP0_VERSION_MASK) != RTP0_VERSION_2)
8420083e:	81 d8       	rMAC = M[FP + 64];
84200840:	12 f0 c0 00 	r0 = rMAC AND 0xc0;
84200844:	20 f0 80 24 	Null = r0 - 128;
84200848:	0e 60       	if EQ jump (m) Lc_rtp_decode_process_data_44;

8420084a <Lc_rtp_decode_process_data_43>:
            {
                /* Unsupported version - discard */
                cbuffer_advance_read_ptr_ex(ip_buffer, packet_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH);
8420084a:	83 f0 04 24 	r1 = r6 - 4;
8420084e:	52 08       	r0 = r8 + Null;
84200850:	08 f0 33 e6 	call (m) $_cbuffer_advance_read_ptr_ex;
                delete_consumed_metadata_tag(ip_buffer, packet_size);
84200854:	43 08       	r1 = r6 + Null;
84200856:	52 08       	r0 = r8 + Null;
84200858:	01 f0 25 e9 	call (m) Lc_delete_consumed_metadata_tag_1;
#ifdef DEBUG_RTP_DECODE
                /* Increment decode lost */
                opx_data->rtp_decode_lost++;
8420085c:	f9 98       	rMAC = M[r5 + 44];
8420085e:	49 20       	rMAC = rMAC + 1;
84200860:	f9 9e       	M[r5 + 44] = rMAC;
84200862:	a3 6f       	jump (m) Lc_rtp_decode_process_data_33;

84200864 <Lc_rtp_decode_process_data_44>:
#endif
            }
            else
            {
                unsigned csrc_count = (fixed_header_first_part[0] & RTP0_CSRC_COUNT_MASK);
84200864:	8e c1       	r4 = rMAC AND 0xf;
                unsigned seq = fixed_header_first_part[3] | (fixed_header_first_part[2]<<8);
84200866:	92 d8       	r0 = M[FP + 72];
84200868:	99 d8       	rMAC = M[FP + 76];
8420086a:	d2 55       	r0 = r0 LSHIFT 8;
8420086c:	1f f2 49 c8 	r7 = r0 OR rMAC;
                unsigned padding_amount = 0;
84200870:	78 de       	M[FP + 60] = Null;
                unsigned header_size;
                unsigned payload_size;
                RTP_FRAME_DECODE_DATA frame_data = {FALSE, 0, 0, 0, 0};
84200872:	07 f0 03 f0 	r1 = Null + 7340240;
84200876:	d0 40 
84200878:	02 15       	r0 = FP + 80;
8420087a:	44 21       	r2 = Null + 5;
8420087c:	ff fd b4 f0 	call (m) 0x17116;
84200880:	3b e4 
                /* Set the frame header decode structure to remove gcc warnings. */

                /* check the sequence number unless local value is 0 which
                 * means initialisation. */
                if ((opx_data->sequence_number != 0) &&
                    (seq != (opx_data->sequence_number + 1)))
84200882:	f9 88       	rMAC = M[r5 + 12];
84200884:	0a 60       	if EQ jump (m) Lc_rtp_decode_process_data_47;

84200886 <Lc_rtp_decode_process_data_45>:
84200886:	4a 20       	r0 = rMAC + 1;
84200888:	2f f9 00 c2 	Null = r7 - r0;
8420088c:	06 60       	if EQ jump (m) Lc_rtp_decode_process_data_47;

8420088e <Lc_rtp_decode_process_data_46>:
                {
#ifdef DEBUG_RTP_DECODE
                    opx_data->rtp_decode_late += seq - (opx_data->sequence_number + 1);
8420088e:	ba 98       	r0 = M[r5 + 40];
84200890:	4a 0c       	r0 = r7 + r0;
84200892:	52 24       	r0 = r0 - 1;
84200894:	51 04       	rMAC = r0 - rMAC;
84200896:	b9 9e       	M[r5 + 40] = rMAC;

84200898 <Lc_rtp_decode_process_data_47>:
                    /* TODO - insert dummy frame when data is lost? (TODO This is an old comment) */
#endif
                }

                /* update sequence number */
                opx_data->sequence_number = seq;
84200898:	79 f0 03 8e 	M[r5 + 12] = r7;

                /* Calculate the header size */
                header_size = rtp_header_size + (csrc_count * 4) +
                             opx_data->payload_header_size;
8420089c:	72 54       	r0 = r4 LSHIFT 2;
8420089e:	79 98       	rMAC = M[r5 + 36];
842008a0:	51 00       	rMAC = r0 + rMAC;
842008a2:	5a d8       	r0 = M[FP + 44];
842008a4:	8e 00       	r4 = rMAC + r0;

                if ((fixed_header_first_part[0] & RTP0_PADDING) != 0)
842008a6:	81 d8       	rMAC = M[FP + 64];
842008a8:	49 c2       	rMAC = rMAC AND 0x20;
842008aa:	0f 60       	if EQ jump (m) Lc_rtp_decode_process_data_50;

842008ac <Lc_rtp_decode_process_data_48>:
                {
                    /* padding amount is the last byte in the buffer. The first part
                     * of the header is already read. The current read offset is
                     * RTP_FIXED_HEADER_FIRST_PART_LENGTH. */
                    unpack_cbuff_to_array_from_offset((int*) &padding_amount, ip_buffer,
                            packet_size - RTP_FIXED_HEADER_FIRST_PART_LENGTH - 1, 1);
842008ac:	45 20       	r3 = Null + 1;
842008ae:	84 f3 fb 3b 	r2 = r6 + -5;
842008b2:	c2 13       	r0 = FP + 60;
842008b4:	53 08       	r1 = r8 + Null;
842008b6:	05 f0 39 e4 	call (m) $_unpack_cbuff_to_array_from_offset;

                    /* ignore rogue values  */
                    if (padding_amount > (packet_size - header_size))
842008ba:	79 d8       	rMAC = M[FP + 60];
842008bc:	6f f8 02 c2 	r0 = r6 - r4;
842008c0:	88 04       	Null = rMAC - r0;
842008c2:	09 f0 87 e0 	if LS jump (m) Lc_rtp_decode_process_data_50;

842008c6 <Lc_rtp_decode_process_data_49>:
                    {
                        padding_amount = 0;
842008c6:	78 de       	M[FP + 60] = Null;

842008c8 <Lc_rtp_decode_process_data_50>:
                    }
                }

                /* calc size of the frame that needs to be written to DSP  */
                payload_size = packet_size - header_size - padding_amount;
842008c8:	6f f8 01 c2 	rMAC = r6 - r4;
842008cc:	7a d8       	r0 = M[FP + 60];
842008ce:	2f f1 09 c2 	r7 = rMAC - r0;

                /* The RTP timestamp field is actually a sample count which is
                 * only reliable for APTX adaptive. For other decoders the header is discarded. */
                if (opx_data->mode == RTP_DECODE && opx_data->codec_type == APTXADAPTIVE)
842008d2:	39 90       	rMAC = MBS[r5 + 8];
842008d4:	48 24       	Null = rMAC - 1;
842008d6:	3a 63       	if NE jump (m) Lc_rtp_decode_process_data_27;

842008d8 <Lc_rtp_decode_process_data_51>:
842008d8:	79 a0       	rMAC = MBS[r5 + 17];
842008da:	88 25       	Null = rMAC - 6;
842008dc:	37 63       	if NE jump (m) Lc_rtp_decode_process_data_27;

842008de <Lc_rtp_decode_process_data_52>:
                {
                    rtp_header_decode(opx_data, header_size, &rtp_header);
842008de:	44 16       	r2 = FP + 100;
842008e0:	33 00       	r1 = r4 + Null;
842008e2:	3a 00       	r0 = r5 + Null;
842008e4:	50 4e       	call (m) Lc_rtp_header_decode_1;
                    frame_data.rtp_timestamp = rtp_header.timestamp;
842008e6:	d2 d8       	r0 = M[FP + 104];
842008e8:	c2 de       	M[FP + 96] = r0;
                    TIME_INTERVAL ttp_adj = RTP_TIMESTAMP_APTX_AD_GET_TTP_ADJ(rtp_header.timestamp);
842008ea:	92 52       	r0 = r0 LSHIFT -16;
842008ec:	14 0c       	r2 = SE16 r0;
                    
                    if (rtp_header.source != opx_data->prev_src_id || opx_data->rtp_ttp_adjust != ttp_adj)
842008ee:	db d8       	r1 = M[FP + 108];
842008f0:	b9 b9       	rMAC = M[r5 + 120];
842008f2:	58 04       	Null = r1 - rMAC;
842008f4:	04 62       	if NE jump (m) Lc_rtp_decode_process_data_54;

842008f6 <Lc_rtp_decode_process_data_53>:
842008f6:	f9 b9       	rMAC = M[r5 + 124];
842008f8:	08 05       	Null = rMAC - r2;
842008fa:	2c 61       	if EQ jump (m) Lc_rtp_decode_process_data_28;

842008fc <Lc_rtp_decode_process_data_54>:
                    {
                        rtp_source_changed(op_data, rtp_header.source, ttp_adj );
842008fc:	42 d8       	r0 = M[FP + 32];
842008fe:	9b 4e       	call (m) Lc_rtp_source_changed_1;
84200900:	29 6f       	jump (m) Lc_rtp_decode_process_data_28;

84200902 <Lc_rtp_decode_process_data_55>:
                    /* Update the metadata in the output buffer.*/
                    buff_metadata_append(buffer, NULL, payload_size, 0);
                    /* Kick forward. */
                    touched->sources = TOUCHED_SOURCE_0;
                }
                else if (opx_data->mode == RTP_DECODE)
84200902:	48 24       	Null = rMAC - 1;
84200904:	4a 63       	if NE jump (m) Lc_rtp_decode_process_data_31;

84200906 <Lc_rtp_decode_process_data_56>:
                {
                    /* Timestamp and transport the tag. */
                    transport_metadata_tag(opx_data, &frame_data, packet_size);
84200906:	03 15       	r1 = FP + 80;
84200908:	44 08       	r2 = r6 + Null;
8420090a:	3a 00       	r0 = r5 + Null;
8420090c:	01 f0 25 e7 	call (m) Lc_transport_metadata_tag_1;
                    if ((frame_data.nr_of_frames > 0)&&(!opx_data->pack_latency_buffer))
84200910:	b8 d8       	Null = M[FP + 92];
84200912:	43 61       	if EQ jump (m) Lc_rtp_decode_process_data_31;

84200914 <Lc_rtp_decode_process_data_57>:
84200914:	78 b9       	Null = M[r5 + 116];
84200916:	41 63       	if NE jump (m) Lc_rtp_decode_process_data_31;

84200918 <Lc_19>:
84200918:	3d 6f       	jump (m) Lc_rtp_decode_process_data_30;

8420091a <Lc_rtp_decode_process_data_58>:
    }

    /*
     * Consumed all the available data -> kick backwards.
     */
    touched->sinks = TOUCHED_SINK_0;
8420091a:	41 20       	rMAC = Null + 1;
8420091c:	4a d8       	r0 = M[FP + 36];
8420091e:	51 8e       	M[r0 + 4] = rMAC;

    L4_DBG_MSG2("RTP END available data (octets) = %d, available space (octets) = %d",
            cbuffer_calc_amount_data_ex(ip_buffer), cbuffer_calc_amount_space_ex(op_buffer));
84200920:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200924:	08 25       	Null = rMAC - 4;
84200926:	10 68       	if LT jump (m) Lc_rtp_decode_process_data_60;

84200928 <Lc_rtp_decode_process_data_59>:
84200928:	52 08       	r0 = r8 + Null;
8420092a:	07 f0 23 e4 	call (m) $_cbuffer_calc_amount_data_ex;
8420092e:	16 00       	r4 = r0 + Null;
84200930:	52 d8       	r0 = M[FP + 40];
84200932:	07 f0 2b e6 	call (m) $_cbuffer_calc_amount_space_ex;
84200936:	14 00       	r2 = r0 + Null;
84200938:	55 f1 02 f0 	r0 = Null + 357565263;
8420093c:	4f 43 
8420093e:	33 00       	r1 = r4 + Null;
84200940:	ff fd 00 f0 	call (m) 0x9c8;
84200944:	29 e4 

84200946 <Lc_rtp_decode_process_data_60>:
}
84200946:	6c 4c       	SP = SP + -80;
84200948:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420094a:	d8 4c       	rts;

8420094c <Lc_rtp_set_payload_header_size_1>:
 * potentially other parameters in the future) will be set according to the codec type.
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
8420094c:	c8 1c       	pushm <FP(=SP), rLink>;
    switch (opx_data->codec_type)
8420094e:	51 a0       	rMAC = MBS[r0 + 17];
84200950:	11 60       	if EQ jump (m) Lc_rtp_set_payload_header_size_9;

84200952 <Lc_rtp_set_payload_header_size_2>:
84200952:	08 24       	Null = rMAC - 0;
84200954:	11 6c       	if LE jump (m) Lc_rtp_set_payload_header_size_10;

84200956 <Lc_rtp_set_payload_header_size_3>:
84200956:	88 24       	Null = rMAC - 2;
84200958:	04 6a       	if GT jump (m) Lc_rtp_set_payload_header_size_5;

8420095a <Lc_rtp_set_payload_header_size_4>:
    {
        case SBC:
        {
            opx_data->payload_header_size = SBC_PAYLOAD_HEADER_SIZE;
8420095a:	41 20       	rMAC = Null + 1;
8420095c:	51 9e       	M[r0 + 36] = rMAC;
8420095e:	11 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

84200960 <Lc_rtp_set_payload_header_size_5>:
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
    switch (opx_data->codec_type)
84200960:	c8 24       	Null = rMAC - 3;
84200962:	04 62       	if NE jump (m) Lc_rtp_set_payload_header_size_7;

84200964 <Lc_rtp_set_payload_header_size_6>:
            opx_data->payload_header_size = ATRAC_PAYLOAD_HEADER_SIZE;
            break;
        }
        case MP3:
        {
            opx_data->payload_header_size = MP3_PAYLOAD_HEADER_SIZE;
84200964:	01 21       	rMAC = Null + 4;
84200966:	51 9e       	M[r0 + 36] = rMAC;
            break;
84200968:	0c 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

8420096a <Lc_rtp_set_payload_header_size_7>:
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_set_payload_header_size(RTP_DECODE_OP_DATA *opx_data)
{
    switch (opx_data->codec_type)
8420096a:	08 25       	Null = rMAC - 4;
8420096c:	05 68       	if LT jump (m) Lc_rtp_set_payload_header_size_10;

8420096e <Lc_rtp_set_payload_header_size_8>:
8420096e:	88 25       	Null = rMAC - 6;
84200970:	03 6a       	if GT jump (m) Lc_rtp_set_payload_header_size_10;

84200972 <Lc_rtp_set_payload_header_size_9>:
            opx_data->payload_header_size = MP3_PAYLOAD_HEADER_SIZE;
            break;
        }
        case APTX:
        {
            opx_data->payload_header_size = APTX_PAYLOAD_HEADER_SIZE;
84200972:	50 9e       	M[r0 + 36] = Null;
84200974:	06 6e       	jump (m) Lc_rtp_set_payload_header_size_11;

84200976 <Lc_rtp_set_payload_header_size_10>:
            break;
        }
        default:
        {
            /*mode not supported yet*/
            panic(PANIC_AUDIO_RTP_UNSUPPORTED_CODEC);
84200976:	02 f0 7a 40 	r0 = Null + 122;
8420097a:	ff fd 9a f0 	call (m) 0x13f08;
8420097e:	2f ec 

84200980 <Lc_rtp_set_payload_header_size_11>:
            break;
        }
    }

}
84200980:	c8 48       	popm <FP, rLink>;
84200982:	d8 4c       	rts;

84200984 <Lc_rtp_header_decode_1>:
 *
 * \param opx_data Pointer to the RTP operator data.
 * \param header_size RTP header size.
 */
static void rtp_header_decode(RTP_DECODE_OP_DATA *opx_data, unsigned header_size, RTP_HEADER_DATA *header)
{
84200984:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84200986:	1a 09       	r8 = r1 + Null;
84200988:	21 09       	r7 = r2 + Null;

    tCbuffer *ip_buffer = opx_data->ip_buffer;
8420098a:	28 f0 0f 88 	r6 = M[r0 + 60];
    TIME rtp_timestamp;
    uint32 rtp_source;

    /* Get the sequence number */
    unpack_cbuff_to_array((int*)fixed_header, ip_buffer,
        RTP_FIXED_HEADER_TIMESTAMP_PART_LENGTH + RTP_FIXED_HEADER_SOURCE_PART_LENGTH);
8420098e:	04 22       	r2 = Null + 8;
84200990:	c2 11       	r0 = FP + 28;
84200992:	43 08       	r1 = r6 + Null;
84200994:	04 f0 37 eb 	call (m) $_unpack_cbuff_to_array;

    /* The RTP timestamp field is actually a sample count.
     * This sample count should be used to generate the time to play
     * timestamp . */
    rtp_timestamp = (((uint32)fixed_header[0])<<24) + (fixed_header[1]<<16) + (fixed_header[2]<<8) + fixed_header[3];
84200998:	3a d8       	r0 = M[FP + 28];
8420099a:	4b d8       	r1 = M[FP + 36];
8420099c:	44 d8       	r2 = M[FP + 32];
8420099e:	52 57       	r0 = r0 LSHIFT 24;
842009a0:	db 55       	r1 = r1 LSHIFT 8;
842009a2:	a4 56       	r2 = r2 LSHIFT 16;
842009a4:	19 01       	rMAC = r1 + r2;
842009a6:	51 00       	rMAC = r0 + rMAC;
842009a8:	52 d8       	r0 = M[FP + 40];
842009aa:	8e 00       	r4 = rMAC + r0;
    rtp_source = (((uint32)fixed_header[4])<<24) + (fixed_header[5]<<16) + (fixed_header[6]<<8) + fixed_header[7];
842009ac:	5a d8       	r0 = M[FP + 44];
842009ae:	6b d8       	r1 = M[FP + 52];
842009b0:	64 d8       	r2 = M[FP + 48];
842009b2:	52 57       	r0 = r0 LSHIFT 24;
842009b4:	db 55       	r1 = r1 LSHIFT 8;
842009b6:	a4 56       	r2 = r2 LSHIFT 16;
842009b8:	19 01       	rMAC = r1 + r2;
842009ba:	51 00       	rMAC = r0 + rMAC;
842009bc:	72 d8       	r0 = M[FP + 56];
842009be:	8f 00       	r5 = rMAC + r0;

    /* Protected from the rtp timestamp overflow.*/

    /* TODO make this a L4 log*/
    L4_DBG_MSG2("RTP decode: rtp_timestamp = %u source = %u", rtp_timestamp, rtp_source);
842009c0:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842009c4:	08 25       	Null = rMAC - 4;
842009c6:	09 68       	if LT jump (m) Lc_rtp_header_decode_3;

842009c8 <Lc_rtp_header_decode_2>:
842009c8:	55 f1 02 f0 	r0 = Null + 357564416;
842009cc:	00 40 
842009ce:	3c 00       	r2 = r5 + Null;
842009d0:	33 00       	r1 = r4 + Null;
842009d2:	ef fd ff ff 	call (m) 0x9c8;
842009d6:	37 ef 

842009d8 <Lc_rtp_header_decode_3>:

    /* Save the RTP timestamp */

    /* Discard the rest of the header. */
    cbuffer_advance_read_ptr_ex(ip_buffer, header_size -
            (RTP_FIXED_HEADER_FIRST_PART_LENGTH + RTP_FIXED_HEADER_TIMESTAMP_PART_LENGTH + RTP_FIXED_HEADER_SOURCE_PART_LENGTH));
842009d8:	a3 f3 f4 3b 	r1 = r8 + -12;
842009dc:	42 08       	r0 = r6 + Null;
842009de:	07 f0 25 ea 	call (m) $_cbuffer_advance_read_ptr_ex;
    header->timestamp = rtp_timestamp;
842009e2:	96 f0 01 8e 	M[r7 + 4] = r4;
    header->source = rtp_source;
842009e6:	97 f0 02 8e 	M[r7 + 8] = r5;

842009ea <Lc_rtp_header_decode_4>:
}
842009ea:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
842009ec:	d8 4c       	rts;

842009ee <Lc_rtp_notify_latency_change_1>:


static void rtp_notify_latency_change(OPERATOR_DATA *op_data, uint32 source, TIME_INTERVAL latency)
{
842009ee:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
842009f0:	16 00       	r4 = r0 + Null;
842009f2:	1f 00       	r5 = r1 + Null;
842009f4:	20 09       	r6 = r2 + Null;
    unsigned latency_changed_msg[OPMSG_REPLY_LATENCY_CHANGED_WORD_SIZE];

    L4_DBG_MSG2( "RTP decode target latency change %d for source %u is notified", latency, source );
842009f6:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842009fa:	08 25       	Null = rMAC - 4;
842009fc:	09 68       	if LT jump (m) Lc_rtp_notify_latency_change_3;

842009fe <Lc_rtp_notify_latency_change_2>:
842009fe:	55 f1 02 f0 	r0 = Null + 357564459;
84200a02:	2b 40 
84200a04:	3c 00       	r2 = r5 + Null;
84200a06:	43 08       	r1 = r6 + Null;
84200a08:	ef fd ff ff 	call (m) 0x9c8;
84200a0c:	21 ee 

84200a0e <Lc_rtp_notify_latency_change_3>:

    latency_changed_msg[0] =   source & 0xffff;
84200a0e:	b9 c6       	rMAC = r5 AND 0xffff;
84200a10:	29 de       	M[FP + 20] = rMAC;
    latency_changed_msg[1] =   source >> 16;
84200a12:	ba 52       	r0 = r5 LSHIFT -16;
84200a14:	32 de       	M[FP + 24] = r0;
    latency_changed_msg[2] =   (uint32)latency & 0xffff;
84200a16:	81 f7 ff 1f 	rMAC = r6 AND 0xffff;
84200a1a:	39 de       	M[FP + 28] = rMAC;
    latency_changed_msg[3] =   (uint32)latency >> 16;
84200a1c:	78 f8 d2 c8 	r0 = r6 LSHIFT -16;
84200a20:	42 de       	M[FP + 32] = r0;

    common_send_unsolicited_message( op_data, (unsigned)OPMSG_REPLY_ID_LATENCY_CHANGED,
                                     OPMSG_REPLY_LATENCY_CHANGED_WORD_SIZE,
                                     (unsigned*)latency_changed_msg);
84200a22:	45 11       	r3 = FP + 20;
84200a24:	04 21       	r2 = Null + 4;
84200a26:	43 21       	r1 = Null + 5;
84200a28:	32 00       	r0 = r4 + Null;
84200a2a:	ef fd fc ff 	call (m) 0x25e;
84200a2e:	35 e1 

84200a30 <Lc_rtp_notify_latency_change_4>:
}
84200a30:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84200a32:	d8 4c       	rts;

84200a34 <Lc_rtp_source_changed_1>:
   Only reset on an SSRC change, as this is the step change in TTP
   The ttp_adjust change should just be applied so the TTP module can dynamically adjust
   ttp_adjust is being validate by the AOSP source device.
   */
static void rtp_source_changed(OPERATOR_DATA *op_data, uint32 source, TIME_INTERVAL ttp_adjust)
{
84200a34:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200a36:	12 09       	r8 = r0 + Null;
84200a38:	1e 00       	r4 = r1 + Null;
84200a3a:	21 09       	r7 = r2 + Null;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200a3c:	05 f0 37 e7 	call (m) $_base_op_get_instance_data;
84200a40:	10 09       	r6 = r0 + Null;
static void rtp_source_changed(OPERATOR_DATA *op_data, uint32 source, TIME_INTERVAL ttp_adjust)
{
    RTP_DECODE_OP_DATA *opx_data = get_instance_data(op_data);
    TIME_INTERVAL new_latency;
    unsigned count;
    bool reset = (opx_data->prev_src_id == source) ? FALSE : TRUE; // Reset only of SSRC change
84200a42:	81 f0 1e 88 	rMAC = M[r6 + 120];
84200a46:	03 09       	r9 = Null + Null;
84200a48:	88 05       	Null = rMAC - r4;
84200a4a:	21 f0 4b ce 	if NE r9 = Null + 1;
    opx_data->prev_src_id = source;
84200a4e:	86 f0 1e 8e 	M[r6 + 120] = r4;
    opx_data->rtp_ttp_adjust = ttp_adjust;
84200a52:	89 f0 1f 8e 	M[r6 + 124] = r7;

    if (opx_data->src_latency_map != NULL)
84200a56:	84 f0 1c 88 	r2 = M[r6 + 112];
84200a5a:	34 60       	if EQ jump (m) Lc_rtp_source_changed_10;

84200a5c <Lc_rtp_source_changed_2>:
84200a5c:	23 e8       	r1 = M[r2 + Null];
    {
        for (count = 0; count < opx_data->src_latency_map->num_entries; count++)
84200a5e:	02 00       	r0 = Null + Null;
84200a60:	21 21       	rMAC = r2 + 4;
84200a62:	03 6e       	jump (m) Lc_rtp_source_changed_4;

84200a64 <Lc_rtp_source_changed_3>:
84200a64:	52 20       	r0 = r0 + 1;
84200a66:	09 22       	rMAC = rMAC + 8;

84200a68 <Lc_rtp_source_changed_4>:
84200a68:	d0 04       	Null = r0 - r1;
84200a6a:	02 f0 d9 e0 	if C jump (m) Lc_rtp_source_changed_10;

84200a6e <Lc_rtp_source_changed_5>:
        {
            if (opx_data->src_latency_map->entries[count].source_id == source)
84200a6e:	6f f1 00 c3 	Null = M[rMAC] - r4;
84200a72:	f9 63       	if NE jump (m) Lc_rtp_source_changed_3;

84200a74 <Lc_rtp_source_changed_6>:
            {
                new_latency = opx_data->src_latency_map->entries[count].target_latency;
84200a74:	92 54       	r0 = r0 LSHIFT 3;
84200a76:	14 01       	r2 = r0 + r2;
84200a78:	a7 88       	r5 = M[r2 + 8];
                new_latency += opx_data->rtp_ttp_adjust * MILLISECOND;
84200a7a:	03 f0 e8 f9 	rMAC = r7 * 1000 (int);
84200a7e:	91 d9 
84200a80:	cf 01       	r5 = rMAC + r5;
                L2_DBG_MSG2("RTP decode target latency changed to %d for source %u", new_latency, source);
84200a82:	55 f1 02 f0 	r0 = Null + 357564521;
84200a86:	69 40 
84200a88:	34 00       	r2 = r4 + Null;
84200a8a:	3b 00       	r1 = r5 + Null;
84200a8c:	ef fd ff ff 	call (m) 0x9c8;
84200a90:	3d e9 
                /* Notify the latency change */
                if( opx_data->latency_change_notify_enable == 1)
84200a92:	82 f0 10 82 	r0 = MBU[r6 + 16];
84200a96:	12 50       	r0 = r0 LSHIFT -1;
84200a98:	11 c0       	rMAC = r0 AND 0x1;
84200a9a:	05 60       	if EQ jump (m) Lc_rtp_source_changed_8;

84200a9c <Lc_rtp_source_changed_7>:
                {
                    rtp_notify_latency_change( op_data, source, new_latency );
84200a9c:	3c 00       	r2 = r5 + Null;
84200a9e:	33 00       	r1 = r4 + Null;
84200aa0:	52 08       	r0 = r8 + Null;
84200aa2:	a6 4f       	call (m) Lc_rtp_notify_latency_change_1;

84200aa4 <Lc_rtp_source_changed_8>:
                }

                ttp_configure_latency(opx_data->ttp_instance, new_latency);
84200aa4:	82 f0 14 88 	r0 = M[r6 + 80];
84200aa8:	3b 00       	r1 = r5 + Null;
84200aaa:	ff fd ae f0 	call (m) 0x167da;
84200aae:	31 e9 
                if (reset)
84200ab0:	0f fb 00 c2 	Null = r9 - Null;
84200ab4:	0e 60       	if EQ jump (m) Lc_rtp_source_changed_11;

84200ab6 <Lc_rtp_source_changed_9>:
                    ttp_reset(opx_data->ttp_instance);
84200ab6:	82 f0 14 88 	r0 = M[r6 + 80];
84200aba:	ff fd ae f0 	call (m) 0x166c0;
84200abe:	27 e0 
84200ac0:	08 6e       	jump (m) Lc_rtp_source_changed_11;

84200ac2 <Lc_rtp_source_changed_10>:
                return;
            }
        }
    }
    L2_DBG_MSG1("RTP decode: no latency target for source %u, target unchanged", source);
84200ac2:	55 f1 02 f0 	r0 = Null + 357564575;
84200ac6:	9f 40 
84200ac8:	33 00       	r1 = r4 + Null;
84200aca:	ef fd ff ff 	call (m) 0x9b4;
84200ace:	2b e7 

84200ad0 <Lc_rtp_source_changed_11>:
84200ad0:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200ad2:	d8 4c       	rts;

84200ad4 <Lc_rtp_decode_reset_working_data_1>:
 * Initialise various working data parameters for the RTP operator.
 *
 * \param opx_data Pointer to the RTP operator data.
 */
static void rtp_decode_reset_working_data(OPERATOR_DATA *op_data)
{
84200ad4:	f1 1c       	pushm <FP(=SP), r4, rLink>;
Private Function Declarations
*/
/* ******************************* Helper functions ************************************ */
static inline RTP_DECODE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (RTP_DECODE_OP_DATA *) base_op_get_instance_data(op_data);
84200ad6:	05 f0 3d e2 	call (m) $_base_op_get_instance_data;
84200ada:	16 00       	r4 = r0 + Null;

#ifdef DATAFORMAT_32
    opx_data->ip_format = AUDIO_DATA_FORMAT_32_BIT;
    opx_data->op_format = AUDIO_DATA_FORMAT_32_BIT;
#else
    opx_data->ip_format = AUDIO_DATA_FORMAT_16_BIT;
84200adc:	30 ee       	M[r4 + Null] = Null;
    opx_data->op_format = AUDIO_DATA_FORMAT_16_BIT;
84200ade:	70 8e       	M[r4 + 4] = Null;
#endif /* DATAFORMAT_32 */

    /* Set the default working mode as RTP header stripping. */
    opx_data->mode = RTP_STRIP;
84200ae0:	81 20       	rMAC = Null + 2;
84200ae2:	31 9a       	MB[r4 + 8] = rMAC;

    /* Disable content protection by default. */
    opx_data->scms_enable = 0;
84200ae4:	31 a2       	rMAC = MBU[r4 + 16];
84200ae6:	11 ff fe 1f 	rMAC = rMAC AND 0xfffffffe;

    /* disable letency notification */
    opx_data->latency_change_notify_enable = 0;
84200aea:	11 ff fd 1f 	rMAC = rMAC AND 0xfffffffd;
84200aee:	31 aa       	MB[r4 + 16] = rMAC;

    /* For the moment the default code is SBC. */
    opx_data->codec_type = SBC;
84200af0:	41 20       	rMAC = Null + 1;
84200af2:	71 aa       	MB[r4 + 17] = rMAC;

    rtp_set_payload_header_size(opx_data);
84200af4:	2c 4f       	call (m) Lc_rtp_set_payload_header_size_1;
#ifdef DEBUG_RTP_DECODE
    opx_data->rtp_decode_last_tag_index = -1;
84200af6:	41 24       	rMAC = Null - 1;
84200af8:	71 9f       	M[r4 + 52] = rMAC;
    opx_data->rtp_decode_last_tag_length = -1;
84200afa:	b1 9f       	M[r4 + 56] = rMAC;

84200afc <Lc_rtp_decode_reset_working_data_2>:
#endif
}
84200afc:	f1 48       	popm <FP, r4, rLink>;
84200afe:	d8 4c       	rts;

84200b00 <Lc_get_read_index_from_buff_1>:
/*
 * Returns the read index for a buffer. Supports 32-bit packed and
 * 16-bit unpacked data.
 */
static unsigned int get_read_index_from_buff(tCbuffer *cbuffer)
{
84200b00:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned int read_index;
#ifndef DATAFORMAT_32
    unsigned int offset;
#endif /* !DATAFORMAT_32 */
    read_index = cbuffer_get_read_offset_ex(cbuffer);
84200b02:	04 f0 23 e5 	call (m) $_cbuffer_get_read_offset_ex;

#ifndef DATAFORMAT_32
    offset = read_index & 0x1;
84200b06:	11 c0       	rMAC = r0 AND 0x1;
    /*Convert the adresses to words. */
    read_index = read_index >> LOG2_ADDR_PER_WORD;
84200b08:	52 50       	r0 = r0 LSHIFT -2;

    /* Convert the words to usable octets. */
    read_index = read_index << 1;
84200b0a:	12 54       	r0 = r0 LSHIFT 1;
    read_index += offset;
84200b0c:	8a 00       	r0 = rMAC + r0;

84200b0e <Lc_get_read_index_from_buff_2>:
#endif /* !DATAFORMAT_32 */

    return read_index;
84200b0e:	c8 48       	popm <FP, rLink>;
84200b10:	d8 4c       	rts;

84200b12 <Lc_tag_valid_1>:
 *
 * \param tag Pointer to the metadata tag read from the input buffer.
 * \param opx_data Pointer to the RTP operator data.
 */
static bool tag_valid(metadata_tag* tag, RTP_DECODE_OP_DATA *opx_data )
{
84200b12:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84200b14:	17 00       	r5 = r0 + Null;
84200b16:	1e 00       	r4 = r1 + Null;

    if (get_read_index_from_buff(opx_data->ip_buffer) != tag->index )
84200b18:	f2 99       	r0 = M[r4 + 60];
84200b1a:	f3 4f       	call (m) Lc_get_read_index_from_buff_1;
84200b1c:	b9 88       	rMAC = M[r5 + 8];
84200b1e:	50 04       	Null = r0 - rMAC;
84200b20:	22 60       	if EQ jump (m) Lc_tag_valid_3;

84200b22 <Lc_tag_valid_2>:
        unsigned discard_buffer;
        unsigned discard_metadata;
        unsigned octets_2_first_tag, octets_post_last_tag;
        metadata_tag  *tag_list;
        /* Probably the metadata and the buffer will have different amount of data. */
        discard_buffer = cbuffer_calc_amount_data_ex(opx_data->ip_buffer);
84200b22:	f2 99       	r0 = M[r4 + 60];
84200b24:	06 f0 29 e4 	call (m) $_cbuffer_calc_amount_data_ex;
84200b28:	10 09       	r6 = r0 + Null;
        cbuffer_advance_read_ptr_ex(opx_data->ip_buffer, discard_buffer);
84200b2a:	f2 99       	r0 = M[r4 + 60];
84200b2c:	43 08       	r1 = r6 + Null;
84200b2e:	06 f0 35 ef 	call (m) $_cbuffer_advance_read_ptr_ex;

        discard_metadata = buff_metadata_available_octets(opx_data->ip_buffer);
84200b32:	f2 99       	r0 = M[r4 + 60];
84200b34:	ff fd 88 f0 	call (m) 0x11d04;
84200b38:	31 ee 
84200b3a:	17 00       	r5 = r0 + Null;
        tag_list = buff_metadata_remove(opx_data->ip_buffer, discard_metadata, &octets_2_first_tag, &octets_post_last_tag);
84200b3c:	85 11       	r3 = FP + 24;
84200b3e:	44 11       	r2 = FP + 20;
84200b40:	f2 99       	r0 = M[r4 + 60];
84200b42:	3b 00       	r1 = r5 + Null;
84200b44:	ff fd 89 f0 	call (m) 0x11d7a;
84200b48:	37 e1 
        buff_metadata_tag_list_delete(tag_list);
84200b4a:	ff fd 86 f0 	call (m) 0x11906;
84200b4e:	3d ed 

        L2_DBG_MSG2("RTP Decode buffer out of sink. discard_buffer = %d, discard_metadata =%d",
                discard_buffer, discard_metadata);
84200b50:	55 f1 02 f0 	r0 = Null + 357564637;
84200b54:	dd 40 
84200b56:	3c 00       	r2 = r5 + Null;
84200b58:	43 08       	r1 = r6 + Null;
84200b5a:	ef fd ff ff 	call (m) 0x9c8;
84200b5e:	2f e3 
        return FALSE;
84200b60:	02 00       	r0 = Null + Null;
84200b62:	05 6e       	jump (m) Lc_tag_valid_4;

84200b64 <Lc_tag_valid_3>:
    }
#ifdef DEBUG_RTP_DECODE
    opx_data->rtp_decode_last_tag_index = tag->index;
84200b64:	71 9f       	M[r4 + 52] = rMAC;
    opx_data->rtp_decode_last_tag_length = tag->length;
84200b66:	f9 88       	rMAC = M[r5 + 12];
84200b68:	b1 9f       	M[r4 + 56] = rMAC;
#endif
    return TRUE;
84200b6a:	42 20       	r0 = Null + 1;

84200b6c <Lc_tag_valid_4>:
}
84200b6c:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84200b6e:	d8 4c       	rts;

84200b70 <Lc_get_tag_size_1>:
 *
 * \param tag Pointer to the metadata tag read from the input buffer.
 */
static unsigned int get_tag_size(metadata_tag* tag)
{
    if (tag == NULL)
84200b70:	10 04       	Null = r0 - Null;
84200b72:	03 62       	if NE jump (m) Lc_get_tag_size_3;

84200b74 <Lc_get_tag_size_2>:
    {
        return 0;
84200b74:	02 00       	r0 = Null + Null;
84200b76:	02 6e       	jump (m) Lc_get_tag_size_4;

84200b78 <Lc_get_tag_size_3>:
    }
    return tag->length;
84200b78:	d2 88       	r0 = M[r0 + 12];

84200b7a <Lc_get_tag_size_4>:
84200b7a:	d8 4c       	rts;

84200b7c <Lc_delete_consumed_metadata_tag_1>:
 *
 * \param o_buff Pointer to the octet buffer from which the tag will be consumed.
 * \param octets_consumed Octets consumed from the buffer. Must be only one tag.
 */
static void delete_consumed_metadata_tag(tCbuffer *o_buff, unsigned int  octets_consumed)
{
84200b7c:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
84200b7e:	1e 00       	r4 = r1 + Null;

    unsigned int octets_b4idx, octets_afteridx;

    metadata_tag *tag = buff_metadata_remove(o_buff, octets_consumed, &octets_b4idx , &octets_afteridx);
84200b80:	05 11       	r3 = FP + 16;
84200b82:	c4 10       	r2 = FP + 12;
84200b84:	ff fd 88 f0 	call (m) 0x11d7a;
84200b88:	37 ef 

    /* get_next_tag_size checks if the tag is at the beginning of the buffer. Therefore
     * octets_b4idx will be 0.*/
    /* Check metadata is synced */
    PL_ASSERT(tag != NULL);
84200b8a:	10 04       	Null = r0 - Null;
84200b8c:	09 62       	if NE jump (m) Lc_delete_consumed_metadata_tag_3;

84200b8e <Lc_delete_consumed_metadata_tag_2>:
84200b8e:	03 f0 7d 41 	r1 = Null + 381;
84200b92:	02 f0 13 60 	r0 = Null + 4115;
84200b96:	ff fd 99 f0 	call (m) 0x13f12;
84200b9a:	3d eb 
84200b9c:	1a 6e       	jump (m) Lc_delete_consumed_metadata_tag_8;

84200b9e <Lc_delete_consumed_metadata_tag_3>:
    PL_ASSERT(octets_b4idx == 0);
84200b9e:	18 d8       	Null = M[FP + 12];
84200ba0:	09 60       	if EQ jump (m) Lc_delete_consumed_metadata_tag_5;

84200ba2 <Lc_delete_consumed_metadata_tag_4>:
84200ba2:	03 f0 7e 41 	r1 = Null + 382;
84200ba6:	02 f0 13 60 	r0 = Null + 4115;
84200baa:	ff fd 99 f0 	call (m) 0x13f12;
84200bae:	29 eb 
84200bb0:	10 6e       	jump (m) Lc_delete_consumed_metadata_tag_8;

84200bb2 <Lc_delete_consumed_metadata_tag_5>:
    PL_ASSERT(octets_afteridx == octets_consumed);
84200bb2:	21 d8       	rMAC = M[FP + 16];
84200bb4:	88 05       	Null = rMAC - r4;
84200bb6:	09 60       	if EQ jump (m) Lc_delete_consumed_metadata_tag_7;

84200bb8 <Lc_delete_consumed_metadata_tag_6>:
84200bb8:	03 f0 7f 41 	r1 = Null + 383;
84200bbc:	02 f0 13 60 	r0 = Null + 4115;
84200bc0:	ff fd 99 f0 	call (m) 0x13f12;
84200bc4:	33 ea 
84200bc6:	05 6e       	jump (m) Lc_delete_consumed_metadata_tag_8;

84200bc8 <Lc_delete_consumed_metadata_tag_7>:

    buff_metadata_delete_tag(tag, TRUE);
84200bc8:	43 20       	r1 = Null + 1;
84200bca:	ff fd 86 f0 	call (m) 0x118b2;
84200bce:	29 e7 

84200bd0 <Lc_delete_consumed_metadata_tag_8>:
}
84200bd0:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
84200bd2:	d8 4c       	rts;

84200bd4 <Lc_get_time_of_arrival_1>:
/**
 * Returns the time of arrival of the tag. If the time of arrival is not set for the tag
 * the hal get time is used.
 */
static unsigned get_time_of_arrival( metadata_tag* tag)
{
84200bd4:	c8 1c       	pushm <FP(=SP), rLink>;
    if (IS_TIME_OF_ARRIVAL_TAG(tag))
84200bd6:	51 88       	rMAC = M[r0 + 4];
84200bd8:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84200bdc:	10 f0 40 24 	Null = rMAC - 64;
84200be0:	03 62       	if NE jump (m) Lc_get_time_of_arrival_3;

84200be2 <Lc_get_time_of_arrival_2>:
    {
        return tag->timestamp;
84200be2:	12 89       	r0 = M[r0 + 16];
84200be4:	04 6e       	jump (m) Lc_get_time_of_arrival_4;

84200be6 <Lc_get_time_of_arrival_3>:
    }
    else
    {
        /* Maybe we are connected to a tester/file endpoint.*/
        return time_get_time();
84200be6:	ff fd 86 f1 	call (m) 0x317e8;
84200bea:	23 e0 

84200bec <Lc_get_time_of_arrival_4>:
    }
}
84200bec:	c8 48       	popm <FP, rLink>;
84200bee:	d8 4c       	rts;

84200bf0 <Lc_transport_metadata_tag_1>:
 * \param frame_data Pointer frame header decode data.
 * \param packet_size Size of the tag from the input buffer.
 */
static void transport_metadata_tag(RTP_DECODE_OP_DATA *opx_data, RTP_FRAME_DECODE_DATA* frame_data,
        unsigned packet_size)
{
84200bf0:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200bf2:	4c 4c       	SP = SP + 48;
84200bf4:	12 09       	r8 = r0 + Null;
84200bf6:	19 09       	r7 = r1 + Null;
84200bf8:	26 00       	r4 = r2 + Null;
    tCbuffer *clone_buffer;
    tCbuffer *buffer;
    tCbuffer* ip_buffer = opx_data->ip_buffer;
84200bfa:	a2 f0 0f 88 	r0 = M[r8 + 60];
    unsigned octets_2_first_tag, octets_post_last_tag;
    unsigned frame_length = frame_data->frame_length;
84200bfe:	9b f0 01 88 	r9 = M[r7 + 4];
    metadata_tag  *tag;
    ttp_status status;

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84200c02:	a0 f0 1d 88 	Null = M[r8 + 116];
84200c06:	08 60       	if EQ jump (m) Lc_transport_metadata_tag_3;

84200c08 <Lc_transport_metadata_tag_2>:
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84200c08:	a1 f0 11 88 	rMAC = M[r8 + 68];
84200c0c:	41 de       	M[FP + 32] = rMAC;
        buffer = opx_data->u.pack.frame_buffer;
84200c0e:	a1 f0 12 88 	rMAC = M[r8 + 72];
84200c12:	49 de       	M[FP + 36] = rMAC;
84200c14:	07 6e       	jump (m) Lc_transport_metadata_tag_4;

84200c16 <Lc_transport_metadata_tag_3>:
    }
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
84200c16:	a1 f0 11 88 	rMAC = M[r8 + 68];
84200c1a:	41 de       	M[FP + 32] = rMAC;
        buffer = opx_data->op_buffer;
84200c1c:	a1 f0 10 88 	rMAC = M[r8 + 64];
84200c20:	49 de       	M[FP + 36] = rMAC;

84200c22 <Lc_transport_metadata_tag_4>:



    /* Remove the tag consumed in this cycle.
     */
    tag = buff_metadata_remove(ip_buffer, packet_size, &octets_2_first_tag, &octets_post_last_tag);
84200c22:	45 13       	r3 = FP + 52;
84200c24:	04 13       	r2 = FP + 48;
84200c26:	33 00       	r1 = r4 + Null;
84200c28:	ff fd 88 f0 	call (m) 0x11d7a;
84200c2c:	33 ea 
84200c2e:	52 de       	M[FP + 40] = r0;

    PL_ASSERT(octets_2_first_tag == 0);
84200c30:	60 d8       	Null = M[FP + 48];
84200c32:	09 60       	if EQ jump (m) Lc_transport_metadata_tag_6;

84200c34 <Lc_transport_metadata_tag_5>:
84200c34:	03 f0 c1 41 	r1 = Null + 449;
84200c38:	02 f0 13 60 	r0 = Null + 4115;
84200c3c:	ff fd 99 f0 	call (m) 0x13f12;
84200c40:	37 e6 
84200c42:	cd 6e       	jump (m) Lc_transport_metadata_tag_32;

84200c44 <Lc_transport_metadata_tag_6>:
    PL_ASSERT(octets_post_last_tag == packet_size);
84200c44:	69 d8       	rMAC = M[FP + 52];
84200c46:	88 05       	Null = rMAC - r4;
84200c48:	09 60       	if EQ jump (m) Lc_transport_metadata_tag_8;

84200c4a <Lc_transport_metadata_tag_7>:
84200c4a:	03 f0 c2 41 	r1 = Null + 450;
84200c4e:	02 f0 13 60 	r0 = Null + 4115;
84200c52:	ff fd 99 f0 	call (m) 0x13f12;
84200c56:	21 e6 
84200c58:	c2 6e       	jump (m) Lc_transport_metadata_tag_32;

84200c5a <Lc_transport_metadata_tag_8>:
    PL_ASSERT((tag != NULL) && (tag->next == NULL));
84200c5a:	51 d8       	rMAC = M[FP + 40];
84200c5c:	3e 60       	if EQ jump (m) Lc_transport_metadata_tag_21;

84200c5e <Lc_transport_metadata_tag_9>:
84200c5e:	51 d8       	rMAC = M[FP + 40];
84200c60:	09 e8       	rMAC = M[rMAC + Null];
84200c62:	3b 62       	if NE jump (m) Lc_transport_metadata_tag_21;

84200c64 <Lc_transport_metadata_tag_10>:

    if (opx_data->codec_type == AAC)
84200c64:	a1 f0 11 80 	rMAC = MBS[r8 + 17];
84200c68:	08 25       	Null = rMAC - 4;
84200c6a:	26 62       	if NE jump (m) Lc_transport_metadata_tag_17;

84200c6c <Lc_transport_metadata_tag_11>:
    {
        unsigned clone_buf_avail_octets = cbuffer_calc_amount_data_ex(clone_buffer);
84200c6c:	42 d8       	r0 = M[FP + 32];
84200c6e:	05 f0 3f e9 	call (m) $_cbuffer_calc_amount_data_ex;
84200c72:	16 00       	r4 = r0 + Null;
        /* There shouln't be more than one AAC frames in the clone buffer. */
        if (frame_data->nr_of_frames > 1)
84200c74:	93 f0 03 88 	r1 = M[r7 + 12];
84200c78:	58 24       	Null = r1 - 1;
84200c7a:	09 f0 97 e0 	if LS jump (m) Lc_transport_metadata_tag_13;

84200c7e <Lc_transport_metadata_tag_12>:
        {
            L2_DBG_MSG1("RTP decode: Number of AAC frames grater than 1! nr frames = %d",
                    frame_data->nr_of_frames);
84200c7e:	55 f1 02 f0 	r0 = Null + 357564710;
84200c82:	26 41 
84200c84:	ef fd fe ff 	call (m) 0x9b4;
84200c88:	31 e9 
            frame_data->nr_of_frames = 1;
84200c8a:	41 20       	rMAC = Null + 1;
84200c8c:	91 f0 03 8e 	M[r7 + 12] = rMAC;

84200c90 <Lc_transport_metadata_tag_13>:
        /* Mark the frame as invalid if the frame length is different from the available
         * octets in the clone buffer. Note: Only do this if the frame data is valid
         * and if we have at least one frames in the clone buffer. */
        if ((frame_data->valid) &&
            (frame_data->nr_of_frames > 0) &&
            (frame_length != clone_buf_avail_octets) )
84200c90:	90 f0 00 e8 	Null = M[r7 + Null];
84200c94:	93 60       	if EQ jump (m) Lc_transport_metadata_tag_31;

84200c96 <Lc_transport_metadata_tag_14>:
84200c96:	90 f0 03 88 	Null = M[r7 + 12];
84200c9a:	0e 60       	if EQ jump (m) Lc_transport_metadata_tag_17;

84200c9c <Lc_transport_metadata_tag_15>:
84200c9c:	6f fb 00 c2 	Null = r9 - r4;
84200ca0:	0b 60       	if EQ jump (m) Lc_transport_metadata_tag_17;

84200ca2 <Lc_transport_metadata_tag_16>:
        {
            L2_DBG_MSG2("RTP decode: AAC frame length = %d is different from the payload length= %d",
                frame_length, clone_buf_avail_octets);
84200ca2:	55 f1 02 f0 	r0 = Null + 357564773;
84200ca6:	65 41 
84200ca8:	34 00       	r2 = r4 + Null;
84200caa:	5b 08       	r1 = r9 + Null;
84200cac:	ef fd fe ff 	call (m) 0x9c8;
84200cb0:	3d e8 
            frame_data->valid = FALSE;
84200cb2:	90 f0 00 ee 	M[r7 + Null] = Null;

84200cb6 <Lc_transport_metadata_tag_17>:
        }
    }

    if ((frame_data->valid) && (frame_data->nr_of_frames > 0))
84200cb6:	90 f0 00 e8 	Null = M[r7 + Null];
84200cba:	80 60       	if EQ jump (m) Lc_transport_metadata_tag_31;

84200cbc <Lc_transport_metadata_tag_18>:
84200cbc:	91 f0 03 88 	rMAC = M[r7 + 12];
84200cc0:	70 60       	if EQ jump (m) Lc_transport_metadata_tag_30;

84200cc2 <Lc_transport_metadata_tag_19>:
        unsigned count;
        unsigned total_encoded_data;
        metadata_tag *last_tag, *tag_list, *new_tag;
        unsigned time_of_arrival;

        total_encoded_data = frame_length * frame_data->nr_of_frames;
84200cc2:	00 fb b1 c9 	rMAC = rMAC * r9 (int);
84200cc6:	59 de       	M[FP + 44] = rMAC;

        if (opx_data->continuation_for_frame)
84200cc8:	a0 f0 07 88 	Null = M[r8 + 28];
84200ccc:	0e 60       	if EQ jump (m) Lc_transport_metadata_tag_22;

84200cce <Lc_transport_metadata_tag_20>:
        {
            time_of_arrival = opx_data->first_tag_time_of_arrival;
84200cce:	a3 f0 08 88 	r1 = M[r8 + 32];
            opx_data->continuation_for_frame = FALSE;
84200cd2:	a0 f0 07 8e 	M[r8 + 28] = Null;
84200cd6:	0c 6e       	jump (m) Lc_transport_metadata_tag_23;

84200cd8 <Lc_transport_metadata_tag_21>:
     */
    tag = buff_metadata_remove(ip_buffer, packet_size, &octets_2_first_tag, &octets_post_last_tag);

    PL_ASSERT(octets_2_first_tag == 0);
    PL_ASSERT(octets_post_last_tag == packet_size);
    PL_ASSERT((tag != NULL) && (tag->next == NULL));
84200cd8:	03 f0 c3 41 	r1 = Null + 451;
84200cdc:	02 f0 13 60 	r0 = Null + 4115;
84200ce0:	ff fd 99 f0 	call (m) 0x13f12;
84200ce4:	33 e1 
84200ce6:	7b 6e       	jump (m) Lc_transport_metadata_tag_32;

84200ce8 <Lc_transport_metadata_tag_22>:
            time_of_arrival = opx_data->first_tag_time_of_arrival;
            opx_data->continuation_for_frame = FALSE;
        }
        else
        {
            time_of_arrival = get_time_of_arrival(tag);
84200ce8:	52 d8       	r0 = M[FP + 40];
84200cea:	75 4f       	call (m) Lc_get_time_of_arrival_1;
84200cec:	13 00       	r1 = r0 + Null;

84200cee <Lc_transport_metadata_tag_23>:
        }

        /* Get the timestamp and sp adjust from the TTP module. Cannot put these two calls
         * to the for loop because the compiler gives status potentially unitialised. */
#ifndef TTP_SOURCE_TIME_TEST
        if (frame_data->frame_samples != 0)
84200cee:	91 f0 02 88 	rMAC = M[r7 + 8];
84200cf2:	0b 60       	if EQ jump (m) Lc_transport_metadata_tag_25;

84200cf4 <Lc_transport_metadata_tag_24>:
        {
        ttp_update_ttp(opx_data->ttp_instance, time_of_arrival,
                frame_data->nr_of_frames * frame_data->frame_samples, &status);
84200cf4:	85 13       	r3 = FP + 56;
84200cf6:	92 f0 03 88 	r0 = M[r7 + 12];
84200cfa:	54 1a       	r2 = r0 * rMAC (int);
84200cfc:	a2 f0 14 88 	r0 = M[r8 + 80];
84200d00:	ff fd ad f0 	call (m) 0x16860;
84200d04:	21 eb 
84200d06:	09 6e       	jump (m) Lc_transport_metadata_tag_26;

84200d08 <Lc_transport_metadata_tag_25>:
        }
        else
#endif
        {
            ttp_update_ttp_from_source_time(opx_data->ttp_instance, time_of_arrival,
                    frame_data->rtp_timestamp, &status);
84200d08:	85 13       	r3 = FP + 56;
84200d0a:	94 f0 04 88 	r2 = M[r7 + 16];
84200d0e:	a2 f0 14 88 	r0 = M[r8 + 80];
84200d12:	ff ff 17 f0 	call (m) 0x4003c2e;
84200d16:	3d e8 

84200d18 <Lc_transport_metadata_tag_26>:
        }
        new_tag = tag_list = last_tag = tag;
84200d18:	e8 f0 0a 88 	r6 = M[FP + 40];
84200d1c:	41 08       	rMAC = r6 + Null;


        METADATA_TIME_OF_ARRIVAL_UNSET(tag);
84200d1e:	0a 00       	r0 = rMAC + Null;
84200d20:	49 88       	rMAC = M[rMAC + 4];
84200d22:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84200d26:	51 8e       	M[r0 + 4] = rMAC;
        /* Populate the new metadata tag. */
        ttp_utils_populate_tag(new_tag, &status);
84200d28:	83 13       	r1 = FP + 56;
84200d2a:	ef fd fd ff 	call (m) 0x8d0;
84200d2e:	27 ed 
84200d30:	41 08       	rMAC = r6 + Null;

        /* Make sure only one tag gets the stream start flag */
        status.stream_restart = FALSE;
84200d32:	88 de       	M[FP + 68] = Null;

        new_tag->length = frame_length;
84200d34:	1b f0 03 8e 	M[rMAC + 12] = r9;

        /* Extrapolate the timestamps to the newly added tags. For one sbc frame only
         * there is no need to do anything. */
        for(count = 1; count < frame_data->nr_of_frames; count++)
84200d38:	47 20       	r5 = Null + 1;

84200d3a <Lc_transport_metadata_tag_27>:
84200d3a:	91 f0 03 88 	rMAC = M[r7 + 12];
84200d3e:	78 04       	Null = r5 - rMAC;
84200d40:	02 f0 c1 e0 	if C jump (m) Lc_transport_metadata_tag_29;

84200d44 <Lc_transport_metadata_tag_28>:
        {
            /* The first tag is allocated outside the for loop.*/
            new_tag = buff_metadata_new_tag();
84200d44:	ff fd 85 f0 	call (m) 0x11862;
84200d48:	3f e8 
84200d4a:	16 00       	r4 = r0 + Null;
            status.ttp = ttp_get_next_timestamp(status.ttp, frame_data->frame_samples,
                opx_data->sample_rate, status.sp_adjustment);
84200d4c:	7d d8       	r3 = M[FP + 60];
84200d4e:	a4 f0 16 88 	r2 = M[r8 + 88];
84200d52:	93 f0 02 88 	r1 = M[r7 + 8];
84200d56:	72 d8       	r0 = M[FP + 56];
84200d58:	ff fd ae f0 	call (m) 0x16aa2;
84200d5c:	2b ea 
84200d5e:	72 de       	M[FP + 56] = r0;

            /* Populate the new metadata tag. */
            ttp_utils_populate_tag(new_tag, &status);
84200d60:	83 13       	r1 = FP + 56;
84200d62:	32 00       	r0 = r4 + Null;
84200d64:	ef fd fd ff 	call (m) 0x8d0;
84200d68:	2d eb 
            METADATA_PACKET_START_SET(new_tag);
84200d6a:	71 88       	rMAC = M[r4 + 4];
84200d6c:	c9 c8       	rMAC = rMAC OR 0x4;
            METADATA_PACKET_END_SET(new_tag);
84200d6e:	49 c9       	rMAC = rMAC OR 0x8;
84200d70:	71 8e       	M[r4 + 4] = rMAC;
            new_tag->length = frame_length;
84200d72:	6b f0 03 8e 	M[r4 + 12] = r9;

            /* Add the new tag to the list. */
            last_tag->next = new_tag;
84200d76:	86 f0 00 ee 	M[r6 + Null] = r4;
            last_tag = new_tag;
84200d7a:	30 09       	r6 = r4 + Null;

        new_tag->length = frame_length;

        /* Extrapolate the timestamps to the newly added tags. For one sbc frame only
         * there is no need to do anything. */
        for(count = 1; count < frame_data->nr_of_frames; count++)
84200d7c:	7f 20       	r5 = r5 + 1;
84200d7e:	de 6f       	jump (m) Lc_transport_metadata_tag_27;

84200d80 <Lc_transport_metadata_tag_29>:

        }

        /* Append the tag to the frame buffer. Note: the after index is only the data
         * after the last index. */
        buff_metadata_append(buffer, tag_list, 0, frame_length);
84200d80:	04 00       	r2 = Null + Null;
84200d82:	5d 08       	r3 = r9 + Null;
84200d84:	53 d8       	r1 = M[FP + 40];
84200d86:	4a d8       	r0 = M[FP + 36];
84200d88:	ff fd 86 f0 	call (m) 0x11adc;
84200d8c:	35 ea 
        /* Make the data available in the output buffer. */
        cbuffer_advance_write_ptr_ex(buffer, total_encoded_data);
84200d8e:	5b d8       	r1 = M[FP + 44];
84200d90:	4a d8       	r0 = M[FP + 36];
84200d92:	05 f0 2b e9 	call (m) $_cbuffer_advance_write_ptr_ex;
        /* Remove all the encoded data from the clone buffer. */
        cbuffer_advance_read_ptr_ex(clone_buffer, total_encoded_data);
84200d96:	5b d8       	r1 = M[FP + 44];
84200d98:	42 d8       	r0 = M[FP + 32];
84200d9a:	05 f0 29 ec 	call (m) $_cbuffer_advance_read_ptr_ex;
84200d9e:	1f 6e       	jump (m) Lc_transport_metadata_tag_32;

84200da0 <Lc_transport_metadata_tag_30>:
    }
    else if (frame_data->valid)
    {
        opx_data->continuation_for_frame = TRUE;
84200da0:	41 20       	rMAC = Null + 1;
84200da2:	a1 f0 07 8e 	M[r8 + 28] = rMAC;
        opx_data->first_tag_time_of_arrival = get_time_of_arrival(tag);
84200da6:	52 d8       	r0 = M[FP + 40];
84200da8:	16 4f       	call (m) Lc_get_time_of_arrival_1;
84200daa:	a2 f0 08 8e 	M[r8 + 32] = r0;
        /* TODO can any information hold in the tag get lost. My concern is the end of
         * file marker. */
        buff_metadata_delete_tag(tag, TRUE);
84200dae:	43 20       	r1 = Null + 1;
84200db0:	52 d8       	r0 = M[FP + 40];
84200db2:	ff fd 85 f0 	call (m) 0x118b2;
84200db6:	21 e8 
84200db8:	12 6e       	jump (m) Lc_transport_metadata_tag_32;

84200dba <Lc_transport_metadata_tag_31>:
    }
    else
    {
        opx_data->continuation_for_frame = FALSE;
84200dba:	a0 f0 07 8e 	M[r8 + 28] = Null;
        /* A corrupt frame is in the input buffer. Discard it. Note we discard everything
         * accumulated in the clone buffer. */
        clone_buffer->write_ptr = buffer->write_ptr;
84200dbe:	49 d8       	rMAC = M[FP + 36];
84200dc0:	42 d8       	r0 = M[FP + 32];
84200dc2:	89 88       	rMAC = M[rMAC + 8];
84200dc4:	91 8e       	M[r0 + 8] = rMAC;
        buff_metadata_delete_tag(tag, TRUE);
84200dc6:	43 20       	r1 = Null + 1;
84200dc8:	52 d8       	r0 = M[FP + 40];
84200dca:	ff fd 85 f0 	call (m) 0x118b2;
84200dce:	29 e7 

        L2_DBG_MSG("RTP decode corrupt frame discarded! ");
84200dd0:	55 f1 02 f0 	r0 = Null + 357564848;
84200dd4:	b0 41 
84200dd6:	ef fd fd ff 	call (m) 0x9a2;
84200dda:	2d ee 

84200ddc <Lc_transport_metadata_tag_32>:
84200ddc:	74 4c       	SP = SP + -48;
84200dde:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200de0:	d8 4c       	rts;

84200de2 <Lc_rtp_create_internal_buffer_1>:

    return TRUE;
}

static tCbuffer *rtp_create_internal_buffer(int *base_addr, unsigned size, unsigned buffer_flags, unsigned usable_octets)
{
84200de2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200de4:	19 00       	rMAC = r1 + Null;
84200de6:	2e 00       	r4 = r3 + Null;
    tCbuffer *buffer;

    /* unset the metadata flag otherwise cbuffer create will fail. */
    BUF_DESC_METADATA_UNSET(buffer_flags);
84200de8:	44 fb ff 1f 	r2 = r2 AND 0xffff7fff;
    if (base_addr != NULL)
84200dec:	10 04       	Null = r0 - Null;
84200dee:	06 60       	if EQ jump (m) Lc_rtp_create_internal_buffer_3;

84200df0 <Lc_rtp_create_internal_buffer_2>:
    {
        /* reuse the base */
        buffer = cbuffer_create(base_addr,
                size, buffer_flags);
84200df0:	ff fd 8c f0 	call (m) 0x12762;
84200df4:	33 eb 
84200df6:	17 00       	r5 = r0 + Null;
84200df8:	07 6e       	jump (m) Lc_rtp_create_internal_buffer_4;

84200dfa <Lc_rtp_create_internal_buffer_3>:
    }
    else
    {
        /* create a new buffer */
        buffer = cbuffer_create_with_malloc(size, buffer_flags);
84200dfa:	23 00       	r1 = r2 + Null;
84200dfc:	0a 00       	r0 = rMAC + Null;
84200dfe:	ff fd 8c f0 	call (m) 0x12790;
84200e02:	33 ec 
84200e04:	17 00       	r5 = r0 + Null;

84200e06 <Lc_rtp_create_internal_buffer_4>:
    }
    if (buffer == NULL)
84200e06:	38 04       	Null = r5 - Null;
84200e08:	03 62       	if NE jump (m) Lc_rtp_create_internal_buffer_6;

84200e0a <Lc_rtp_create_internal_buffer_5>:
    {
        return NULL;
84200e0a:	02 00       	r0 = Null + Null;
84200e0c:	18 6e       	jump (m) Lc_rtp_create_internal_buffer_8;

84200e0e <Lc_rtp_create_internal_buffer_6>:
    }
    /* Allocate the metadta buffer. */
    buffer->metadata = xzpnew(metadata_list);
84200e0e:	c3 20       	r1 = Null + 3;
84200e10:	02 2a       	r0 = Null + 24;
84200e12:	ff fd 20 f0 	call (m) 0x4f2a;
84200e16:	39 e8 
    if (buffer->metadata == NULL)
84200e18:	ba 8f       	M[r5 + 24] = r0;
84200e1a:	f8 61       	if EQ jump (m) Lc_rtp_create_internal_buffer_5;

84200e1c <Lc_rtp_create_internal_buffer_7>:
    {
        return NULL;
    }
    /* make the metadata circular */
    buffer->metadata->next = buffer->metadata; /*only one metadata buffer. */
84200e1c:	12 8f       	M[r0 + 16] = r0;
    buffer->metadata->ref_cnt = 1;/* only one user */
84200e1e:	b9 89       	rMAC = M[r5 + 24];
84200e20:	09 29       	rMAC = rMAC + 20;
84200e22:	0a e8       	r0 = M[rMAC + Null];
84200e24:	22 ff c0 1f 	r0 = r0 AND 0xffffffc0;
84200e28:	12 c8       	r0 = r0 OR 0x1;
84200e2a:	0a ee       	M[rMAC + Null] = r0;
    BUF_DESC_METADATA_SET(buffer->descriptor);
84200e2c:	79 89       	rMAC = M[r5 + 20];
84200e2e:	49 ce       	rMAC = rMAC OR 0x8000;
84200e30:	79 8f       	M[r5 + 20] = rMAC;
    /* Note cbuffer_set_usable_octets will set the buffer size too. */
    cbuffer_set_usable_octets(buffer, usable_octets);
84200e32:	33 00       	r1 = r4 + Null;
84200e34:	3a 00       	r0 = r5 + Null;
84200e36:	03 f0 25 e4 	call (m) $_cbuffer_set_usable_octets;

    return buffer;
84200e3a:	3a 00       	r0 = r5 + Null;

84200e3c <Lc_rtp_create_internal_buffer_8>:
}
84200e3c:	f2 48       	popm <FP, r4, r5, rLink>;
84200e3e:	d8 4c       	rts;

84200e40 <Lc_metadata_transport_with_ttp_reframe_1>:
/* Transport metadata from input to output, reframing output tags
 * to a fixed length to constrain the maximum packet size
 * This is required when using TWS with aptX input
 */
static void metadata_transport_with_ttp_reframe(RTP_DECODE_OP_DATA *opx_data, unsigned octets_copied)
{
84200e40:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200e42:	11 09       	r7 = r0 + Null;
84200e44:	1a 09       	r8 = r1 + Null;
    metadata_tag *mtag_op, *mtag_ip, *mtag_ip_list = NULL;
84200e46:	40 de       	M[FP + 32] = Null;
    unsigned b4idx, afteridx, out_tagged_octets, append_length = 0;
    TIME base_toa, base_ttp;
    ttp_status status;

    if (BUFF_METADATA(opx_data->ip_buffer))
84200e48:	92 f0 0f 88 	r0 = M[r7 + 60];
84200e4c:	51 89       	rMAC = M[r0 + 20];
84200e4e:	49 c6       	rMAC = rMAC AND 0x8000;
84200e50:	08 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_3;

84200e52 <Lc_metadata_transport_with_ttp_reframe_2>:
    {
        mtag_ip_list = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
84200e52:	c5 12       	r3 = FP + 44;
84200e54:	84 12       	r2 = FP + 40;
84200e56:	ff fd 87 f0 	call (m) 0x11d7a;
84200e5a:	25 e9 
84200e5c:	42 de       	M[FP + 32] = r0;
84200e5e:	02 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_4;

84200e60 <Lc_metadata_transport_with_ttp_reframe_3>:
    }
    else
    {
        b4idx = 0;
84200e60:	50 de       	M[FP + 40] = Null;

84200e62 <Lc_metadata_transport_with_ttp_reframe_4>:
    }

    /* It's not worth doing anything if the output doesn't have metadata */
    if (BUFF_METADATA(opx_data->op_buffer))
84200e62:	91 f0 10 88 	rMAC = M[r7 + 64];
84200e66:	49 89       	rMAC = M[rMAC + 20];
84200e68:	49 c6       	rMAC = rMAC AND 0x8000;
84200e6a:	b0 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_31;

84200e6c <Lc_metadata_transport_with_ttp_reframe_5>:
    {
        /* Find the first ToA tag */
        mtag_ip = mtag_ip_list;
84200e6c:	46 d8       	r4 = M[FP + 32];

84200e6e <Lc_metadata_transport_with_ttp_reframe_6>:
        while ((mtag_ip != NULL) && (!IS_TIME_OF_ARRIVAL_TAG(mtag_ip)))
84200e6e:	30 04       	Null = r4 - Null;
84200e70:	42 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_15;

84200e72 <Lc_metadata_transport_with_ttp_reframe_7>:
84200e72:	71 88       	rMAC = M[r4 + 4];
84200e74:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84200e78:	10 f0 40 24 	Null = rMAC - 64;
84200e7c:	07 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_9;

84200e7e <Lc_metadata_transport_with_ttp_reframe_8>:
        {
            b4idx += mtag_ip->length;
84200e7e:	f1 88       	rMAC = M[r4 + 12];
84200e80:	52 d8       	r0 = M[FP + 40];
84200e82:	51 00       	rMAC = r0 + rMAC;
84200e84:	51 de       	M[FP + 40] = rMAC;
            mtag_ip = mtag_ip->next;
84200e86:	36 e8       	r4 = M[r4 + Null];
    /* It's not worth doing anything if the output doesn't have metadata */
    if (BUFF_METADATA(opx_data->op_buffer))
    {
        /* Find the first ToA tag */
        mtag_ip = mtag_ip_list;
        while ((mtag_ip != NULL) && (!IS_TIME_OF_ARRIVAL_TAG(mtag_ip)))
84200e88:	f3 6f       	jump (m) Lc_metadata_transport_with_ttp_reframe_6;

84200e8a <Lc_metadata_transport_with_ttp_reframe_9>:
        {
            b4idx += mtag_ip->length;
            mtag_ip = mtag_ip->next;
        }

        if ((b4idx == 0) && (mtag_ip != NULL))
84200e8a:	50 d8       	Null = M[FP + 40];
84200e8c:	34 62       	if NE jump (m) Lc_metadata_transport_with_ttp_reframe_15;

84200e8e <Lc_metadata_transport_with_ttp_reframe_10>:
        {
            /* If the old tag is already at the start of the input data,
             * Just use its timestamp directly
             */
            base_toa = mtag_ip->timestamp;
84200e8e:	31 89       	rMAC = M[r4 + 16];
84200e90:	49 de       	M[FP + 36] = rMAC;
            L3_DBG_MSG1("RTP reframe : tag at start, ToA = %d", base_toa);
84200e92:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200e96:	c8 24       	Null = rMAC - 3;
84200e98:	4f 68       	if LT jump (m) Lc_metadata_transport_with_ttp_reframe_20;

84200e9a <Lc_metadata_transport_with_ttp_reframe_11>:
84200e9a:	55 f1 02 f0 	r0 = Null + 357564917;
84200e9e:	f5 41 
84200ea0:	4b d8       	r1 = M[FP + 36];
84200ea2:	ef fd fd ff 	call (m) 0x9b4;
84200ea6:	33 e8 

84200ea8 <Lc_metadata_transport_with_ttp_reframe_12>:
        }

        if (mtag_ip != NULL)
        {
            /* Save the timestamp info from the incoming metadata */
            opx_data->last_tag_timestamp = mtag_ip->timestamp;
84200ea8:	31 89       	rMAC = M[r4 + 16];
84200eaa:	91 f0 18 8e 	M[r7 + 96] = rMAC;
            opx_data->last_toa_valid = TRUE;
84200eae:	41 20       	rMAC = Null + 1;
84200eb0:	91 f0 19 8e 	M[r7 + 100] = rMAC;

84200eb4 <Lc_metadata_transport_with_ttp_reframe_13>:
        }

        ttp_update_ttp(opx_data->ttp_instance, base_toa, octets_copied, &status);
84200eb4:	05 13       	r3 = FP + 48;
84200eb6:	92 f0 14 88 	r0 = M[r7 + 80];
84200eba:	54 08       	r2 = r8 + Null;
84200ebc:	4b d8       	r1 = M[FP + 36];
84200ebe:	ff fd ac f0 	call (m) 0x16860;
84200ec2:	23 ed 
        base_ttp = status.ttp;
84200ec4:	eb f0 0c 88 	r9 = M[FP + 48];

        /* Distance to the first tag */
        out_tagged_octets = opx_data->max_packet_len - opx_data->last_op_tag_octets;
84200ec8:	91 f0 17 88 	rMAC = M[r7 + 92];
84200ecc:	92 f0 1a 88 	r0 = M[r7 + 104];
84200ed0:	8f 04       	r5 = rMAC - r0;

        if (out_tagged_octets >= octets_copied)
84200ed2:	af f7 00 c2 	Null = r5 - r8;
84200ed6:	33 64       	if NC jump (m) Lc_metadata_transport_with_ttp_reframe_21;

84200ed8 <Lc_metadata_transport_with_ttp_reframe_14>:
        {
            /* No new tag in this chunk of data */
            buff_metadata_append(opx_data->op_buffer, NULL, octets_copied, 0);
84200ed8:	92 f0 10 88 	r0 = M[r7 + 64];
84200edc:	05 00       	r3 = Null + Null;
84200ede:	03 00       	r1 = Null + Null;
84200ee0:	54 08       	r2 = r8 + Null;
84200ee2:	ff fd 85 f0 	call (m) 0x11adc;
84200ee6:	3b ef 
            opx_data->last_op_tag_octets += octets_copied;
84200ee8:	91 f0 1a 88 	rMAC = M[r7 + 104];
84200eec:	51 0c       	rMAC = r8 + rMAC;
84200eee:	91 f0 1a 8e 	M[r7 + 104] = rMAC;
84200ef2:	6c 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_31;

84200ef4 <Lc_metadata_transport_with_ttp_reframe_15>:
            L3_DBG_MSG1("RTP reframe : tag at start, ToA = %d", base_toa);
        }
        else
        {
            /* Otherwise, use the previously-stashed timestamp if there is one */
            if (opx_data->last_toa_valid)
84200ef4:	90 f0 19 88 	Null = M[r7 + 100];
84200ef8:	10 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_18;

84200efa <Lc_metadata_transport_with_ttp_reframe_16>:
            {
                base_toa = opx_data->last_tag_timestamp;
84200efa:	91 f0 18 88 	rMAC = M[r7 + 96];
84200efe:	49 de       	M[FP + 36] = rMAC;
                L3_DBG_MSG1("RTP reframe : old ToA = %d", base_toa);
84200f00:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200f04:	c8 24       	Null = rMAC - 3;
84200f06:	18 68       	if LT jump (m) Lc_metadata_transport_with_ttp_reframe_20;

84200f08 <Lc_metadata_transport_with_ttp_reframe_17>:
84200f08:	55 f1 02 f0 	r0 = Null + 357564954;
84200f0c:	1a 42 
84200f0e:	4b d8       	r1 = M[FP + 36];
84200f10:	ef fd fd ff 	call (m) 0x9b4;
84200f14:	25 e5 
84200f16:	10 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_20;

84200f18 <Lc_metadata_transport_with_ttp_reframe_18>:
            }
            else
            {
                /* Just use the current TIMER_TIME */
                base_toa = time_get_time();
84200f18:	ff fd 84 f1 	call (m) 0x317e8;
84200f1c:	31 e6 
84200f1e:	4a de       	M[FP + 36] = r0;
                L3_DBG_MSG1("RTP reframe : no tag, ToA = %d", base_toa);
84200f20:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200f24:	c8 24       	Null = rMAC - 3;
84200f26:	08 68       	if LT jump (m) Lc_metadata_transport_with_ttp_reframe_20;

84200f28 <Lc_metadata_transport_with_ttp_reframe_19>:
84200f28:	55 f1 02 f0 	r0 = Null + 357564981;
84200f2c:	35 42 
84200f2e:	4b d8       	r1 = M[FP + 36];
84200f30:	ef fd fd ff 	call (m) 0x9b4;
84200f34:	25 e4 

84200f36 <Lc_metadata_transport_with_ttp_reframe_20>:
            }
        }

        if (mtag_ip != NULL)
84200f36:	30 04       	Null = r4 - Null;
84200f38:	b8 63       	if NE jump (m) Lc_metadata_transport_with_ttp_reframe_12;

84200f3a <Lc_20>:
84200f3a:	bd 6f       	jump (m) Lc_metadata_transport_with_ttp_reframe_13;

84200f3c <Lc_metadata_transport_with_ttp_reframe_21>:
            buff_metadata_append(opx_data->op_buffer, NULL, octets_copied, 0);
            opx_data->last_op_tag_octets += octets_copied;
        }
        else
        {
            b4idx = out_tagged_octets;
84200f3c:	57 de       	M[FP + 40] = r5;

84200f3e <Lc_metadata_transport_with_ttp_reframe_22>:

            /* Make a new list of tags for the output */
            while (out_tagged_octets < octets_copied)
            {
                mtag_op = buff_metadata_new_tag();
84200f3e:	ff fd 84 f0 	call (m) 0x11862;
84200f42:	25 e9 
84200f44:	16 00       	r4 = r0 + Null;

                if (mtag_op != NULL)
84200f46:	28 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_reframe_26;

84200f48 <Lc_metadata_transport_with_ttp_reframe_23>:
                {
                    mtag_op->length = opx_data->max_packet_len;
84200f48:	91 f0 17 88 	rMAC = M[r7 + 92];
84200f4c:	f1 8e       	M[r4 + 12] = rMAC;
                    METADATA_PACKET_START_SET(mtag_op);
84200f4e:	71 88       	rMAC = M[r4 + 4];
84200f50:	c9 c8       	rMAC = rMAC OR 0x4;
                    METADATA_PACKET_END_SET(mtag_op);
84200f52:	49 c9       	rMAC = rMAC OR 0x8;
84200f54:	71 8e       	M[r4 + 4] = rMAC;
                    status.ttp = ttp_get_next_timestamp(base_ttp, out_tagged_octets, opx_data->sample_rate, status.sp_adjustment);
84200f56:	6d d8       	r3 = M[FP + 52];
84200f58:	94 f0 16 88 	r2 = M[r7 + 88];
84200f5c:	3b 00       	r1 = r5 + Null;
84200f5e:	5a 08       	r0 = r9 + Null;
84200f60:	ff fd ad f0 	call (m) 0x16aa2;
84200f64:	23 ea 
84200f66:	62 de       	M[FP + 48] = r0;
                    ttp_utils_populate_tag(mtag_op, &status);
84200f68:	03 13       	r1 = FP + 48;
84200f6a:	32 00       	r0 = r4 + Null;
84200f6c:	ef fd fc ff 	call (m) 0x8d0;
84200f70:	25 eb 
                    L3_DBG_MSG5("RTP reframe tag, ToA = %d, base = %d, TTP = %d, len = %d, offset = %d", base_toa, base_ttp, status.ttp, mtag_op->length, out_tagged_octets);
84200f72:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84200f76:	c8 24       	Null = rMAC - 3;
84200f78:	0e 68       	if LT jump (m) Lc_metadata_transport_with_ttp_reframe_25;

84200f7a <Lc_metadata_transport_with_ttp_reframe_24>:
84200f7a:	39 1c       	pushm <r5>;
84200f7c:	f1 88       	rMAC = M[r4 + 12];
84200f7e:	09 1c       	pushm <rMAC>;
84200f80:	65 d8       	r3 = M[FP + 48];
84200f82:	55 f1 02 f0 	r0 = Null + 357565012;
84200f86:	54 42 
84200f88:	5c 08       	r2 = r9 + Null;
84200f8a:	4b d8       	r1 = M[FP + 36];
84200f8c:	ef fd fd ff 	call (m) 0xa12;
84200f90:	27 e4 
84200f92:	7e 4c       	SP = SP + -8;

84200f94 <Lc_metadata_transport_with_ttp_reframe_25>:
                    /* Make sure only one tag gets the stream start flag */
                    status.stream_restart = FALSE;
84200f94:	78 de       	M[FP + 60] = Null;

84200f96 <Lc_metadata_transport_with_ttp_reframe_26>:
                }
                out_tagged_octets += opx_data->max_packet_len;
84200f96:	98 f0 17 88 	r6 = M[r7 + 92];
84200f9a:	47 0c       	r5 = r6 + r5;
                if (out_tagged_octets > octets_copied)
84200f9c:	af f7 00 c2 	Null = r5 - r8;
84200fa0:	09 f0 8f e0 	if LS jump (m) Lc_metadata_transport_with_ttp_reframe_28;

84200fa4 <Lc_metadata_transport_with_ttp_reframe_27>:
                {
                    /* Partial tag, so constrain the append to the copied amount */
                    append_length = opx_data->max_packet_len - (out_tagged_octets - octets_copied);
84200fa4:	af f8 01 c0 	rMAC = r6 + r8;
84200fa8:	7f f1 08 c2 	r6 = rMAC - r5;
84200fac:	01 6e       	jump (m) Lc_metadata_transport_with_ttp_reframe_28;

84200fae <Lc_metadata_transport_with_ttp_reframe_28>:
                else
                {
                    append_length = opx_data->max_packet_len;
                }

                buff_metadata_append(opx_data->op_buffer, mtag_op, b4idx, append_length);
84200fae:	54 d8       	r2 = M[FP + 40];
84200fb0:	92 f0 10 88 	r0 = M[r7 + 64];
84200fb4:	45 08       	r3 = r6 + Null;
84200fb6:	33 00       	r1 = r4 + Null;
84200fb8:	ff fd 85 f0 	call (m) 0x11adc;
84200fbc:	25 e9 
                b4idx = 0;
84200fbe:	50 de       	M[FP + 40] = Null;
        else
        {
            b4idx = out_tagged_octets;

            /* Make a new list of tags for the output */
            while (out_tagged_octets < octets_copied)
84200fc0:	af f7 00 c2 	Null = r5 - r8;
84200fc4:	bd 65       	if NC jump (m) Lc_metadata_transport_with_ttp_reframe_22;

84200fc6 <Lc_metadata_transport_with_ttp_reframe_30>:
                }

                buff_metadata_append(opx_data->op_buffer, mtag_op, b4idx, append_length);
                b4idx = 0;
            }
            opx_data->last_op_tag_octets = append_length;
84200fc6:	98 f0 1a 8e 	M[r7 + 104] = r6;

84200fca <Lc_metadata_transport_with_ttp_reframe_31>:
        }
    }
    buff_metadata_tag_list_delete(mtag_ip_list);
84200fca:	42 d8       	r0 = M[FP + 32];
84200fcc:	ff fd 84 f0 	call (m) 0x11906;
84200fd0:	3b e9 

84200fd2 <Lc_metadata_transport_with_ttp_reframe_32>:
}
84200fd2:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200fd4:	d8 4c       	rts;

84200fd6 <Lc_metadata_transport_with_ttp_1>:
 * either adding time-to-play on existing tags or creating new ones if none are present
 * This is only used by the "TTP ONLY" mode with aptX, because it relies on
 * a known fixed compression ratio. This is not used in aptX HD
 */
static void metadata_transport_with_ttp(RTP_DECODE_OP_DATA *opx_data, unsigned octets_copied)
{
84200fd6:	f5 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x20;
84200fd8:	11 09       	r7 = r0 + Null;
84200fda:	1e 00       	r4 = r1 + Null;
    metadata_tag *mtag = NULL;
    unsigned b4idx, afteridx;
    tCbuffer *buffer;
    PL_ASSERT(opx_data->codec_type == APTX);
84200fdc:	91 f0 11 80 	rMAC = MBS[r7 + 17];
84200fe0:	09 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_3;

84200fe2 <Lc_metadata_transport_with_ttp_2>:
84200fe2:	03 f0 45 48 	r1 = Null + 1093;
84200fe6:	02 f0 13 60 	r0 = Null + 4115;
84200fea:	ff fd 97 f0 	call (m) 0x13f12;
84200fee:	29 e9 
84200ff0:	70 6e       	jump (m) Lc_metadata_transport_with_ttp_21;

84200ff2 <Lc_metadata_transport_with_ttp_3>:

    if (opx_data->max_packet_len != 0)
84200ff2:	90 f0 17 88 	Null = M[r7 + 92];
84200ff6:	03 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_5;

84200ff8 <Lc_metadata_transport_with_ttp_4>:
    {
        metadata_transport_with_ttp_reframe(opx_data, octets_copied);
84200ff8:	24 4f       	call (m) Lc_metadata_transport_with_ttp_reframe_1;
        return;
84200ffa:	6b 6e       	jump (m) Lc_metadata_transport_with_ttp_21;

84200ffc <Lc_metadata_transport_with_ttp_5>:
    }

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84200ffc:	90 f0 1d 88 	Null = M[r7 + 116];
84201000:	04 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_7;

84201002 <Lc_metadata_transport_with_ttp_6>:
    {
        buffer = opx_data->u.pack.internal_buffer;
84201002:	9a f0 13 88 	r8 = M[r7 + 76];
84201006:	03 6e       	jump (m) Lc_metadata_transport_with_ttp_8;

84201008 <Lc_metadata_transport_with_ttp_7>:
    }
    else
    {
        buffer = opx_data->op_buffer;
84201008:	9a f0 10 88 	r8 = M[r7 + 64];

8420100c <Lc_metadata_transport_with_ttp_8>:
    }

    if (BUFF_METADATA(opx_data->ip_buffer))
8420100c:	92 f0 0f 88 	r0 = M[r7 + 60];
84201010:	51 89       	rMAC = M[r0 + 20];
84201012:	49 c6       	rMAC = rMAC AND 0x8000;
84201014:	14 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_12;

84201016 <Lc_metadata_transport_with_ttp_9>:
    {
        /* transport metadata, first (attempt to) consume tag associated with src */
        mtag = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
84201016:	05 12       	r3 = FP + 32;
84201018:	c4 11       	r2 = FP + 28;
8420101a:	ff fd 86 f0 	call (m) 0x11d7a;
8420101e:	21 eb 
84201020:	10 09       	r6 = r0 + Null;
        {
            mtag->length = octets_copied;
        }
    }

    if (mtag != NULL)
84201022:	16 62       	if NE jump (m) Lc_metadata_transport_with_ttp_14;

84201024 <Lc_metadata_transport_with_ttp_10>:
            list_samples += list_tag->length;
            list_tag = list_tag->next;
        }
    }

    if (BUFF_METADATA(buffer))
84201024:	a1 f0 05 88 	rMAC = M[r8 + 20];
84201028:	49 c6       	rMAC = rMAC AND 0x8000;
8420102a:	4f 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_20;

8420102c <Lc_metadata_transport_with_ttp_11>:
    {
        buff_metadata_append(buffer, mtag, b4idx, afteridx);
8420102c:	45 d8       	r3 = M[FP + 32];
8420102e:	3c d8       	r2 = M[FP + 28];
84201030:	43 08       	r1 = r6 + Null;
84201032:	52 08       	r0 = r8 + Null;
84201034:	ff fd 85 f0 	call (m) 0x11adc;
84201038:	29 e5 
8420103a:	4b 6e       	jump (m) Lc_metadata_transport_with_ttp_21;

8420103c <Lc_metadata_transport_with_ttp_12>:
        mtag = buff_metadata_remove(opx_data->ip_buffer, octets_copied, &b4idx, &afteridx);
    }
    else
    {
        /* Create a new tag for the output */
        b4idx = 0;
8420103c:	38 de       	M[FP + 28] = Null;
        afteridx = octets_copied;
8420103e:	46 de       	M[FP + 32] = r4;
        mtag = buff_metadata_new_tag();
84201040:	ff fd 84 f0 	call (m) 0x11862;
84201044:	23 e1 
84201046:	10 09       	r6 = r0 + Null;
        if (mtag != NULL)
84201048:	ee 61       	if EQ jump (m) Lc_metadata_transport_with_ttp_10;

8420104a <Lc_metadata_transport_with_ttp_13>:
        {
            mtag->length = octets_copied;
8420104a:	86 f0 03 8e 	M[r6 + 12] = r4;

8420104e <Lc_metadata_transport_with_ttp_14>:
    }

    if (mtag != NULL)
    {
        ttp_status status;
        metadata_tag *list_tag = mtag->next;
8420104e:	87 f0 00 e8 	r5 = M[r6 + Null];
        unsigned list_samples = mtag->length;
84201052:	86 f0 03 88 	r4 = M[r6 + 12];
        unsigned time_of_arrival;

        time_of_arrival = get_time_of_arrival(mtag);
84201056:	fd ff 3f eb 	call (m) Lc_get_time_of_arrival_1;
8420105a:	13 00       	r1 = r0 + Null;
        /* the tag will be reused for timestamp, so unset the time of arrival flag. */
        METADATA_TIME_OF_ARRIVAL_UNSET(mtag);
8420105c:	81 f0 01 88 	rMAC = M[r6 + 4];
84201060:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84201064:	81 f0 01 8e 	M[r6 + 4] = rMAC;

84201068 <Lc_metadata_transport_with_ttp_15>:

        /* Calculate the total tags length. to avoid losing data when no tags are read
         * from the input buffer. */
        while (list_tag != NULL)
84201068:	38 04       	Null = r5 - Null;
8420106a:	09 60       	if EQ jump (m) Lc_metadata_transport_with_ttp_17;

8420106c <Lc_metadata_transport_with_ttp_16>:
        {
            METADATA_TIME_OF_ARRIVAL_UNSET(list_tag);
8420106c:	79 88       	rMAC = M[r5 + 4];
8420106e:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
84201072:	79 8e       	M[r5 + 4] = rMAC;
            list_samples += list_tag->length;
84201074:	f9 88       	rMAC = M[r5 + 12];
84201076:	8e 01       	r4 = rMAC + r4;
            list_tag = list_tag->next;
84201078:	3f e8       	r5 = M[r5 + Null];
        /* the tag will be reused for timestamp, so unset the time of arrival flag. */
        METADATA_TIME_OF_ARRIVAL_UNSET(mtag);

        /* Calculate the total tags length. to avoid losing data when no tags are read
         * from the input buffer. */
        while (list_tag != NULL)
8420107a:	f7 6f       	jump (m) Lc_metadata_transport_with_ttp_15;

8420107c <Lc_metadata_transport_with_ttp_17>:
        }

        /* For aptX, each stereo pair of samples is encoded as one octet
         * This means the sample count for TTP is the same as the number of encoded octets
         */
        ttp_update_ttp(opx_data->ttp_instance, time_of_arrival, list_samples, &status);
8420107c:	45 12       	r3 = FP + 36;
8420107e:	92 f0 14 88 	r0 = M[r7 + 80];
84201082:	34 00       	r2 = r4 + Null;
84201084:	ff fd ab f0 	call (m) 0x16860;
84201088:	3d ee 

        /* Populate the metadata tag from the TTP status */
        ttp_utils_populate_tag(mtag, &status);
8420108a:	43 12       	r1 = FP + 36;
8420108c:	42 08       	r0 = r6 + Null;
8420108e:	ef fd fc ff 	call (m) 0x8d0;
84201092:	23 e2 

        /* Make sure only one tag gets the stream start flag */
        status.stream_restart = FALSE;
84201094:	60 de       	M[FP + 48] = Null;

        /* In case there were multiple metadata tags on the input,
         * extrapolate the timestamps to any subsequent tags
         */
        list_tag = mtag->next;
84201096:	86 f0 00 e8 	r4 = M[r6 + Null];
        list_samples = mtag->length;
8420109a:	87 f0 03 88 	r5 = M[r6 + 12];

8420109e <Lc_metadata_transport_with_ttp_18>:
        while (list_tag != NULL)
8420109e:	30 04       	Null = r4 - Null;
842010a0:	c2 61       	if EQ jump (m) Lc_metadata_transport_with_ttp_10;

842010a2 <Lc_metadata_transport_with_ttp_19>:
        {
            status.ttp = ttp_get_next_timestamp(mtag->timestamp, list_samples, opx_data->sample_rate, status.sp_adjustment);
842010a2:	55 d8       	r3 = M[FP + 40];
842010a4:	94 f0 16 88 	r2 = M[r7 + 88];
842010a8:	82 f0 04 88 	r0 = M[r6 + 16];
842010ac:	3b 00       	r1 = r5 + Null;
842010ae:	ff fd ac f0 	call (m) 0x16aa2;
842010b2:	35 ef 
842010b4:	4a de       	M[FP + 36] = r0;
            ttp_utils_populate_tag(list_tag, &status);
842010b6:	43 12       	r1 = FP + 36;
842010b8:	32 00       	r0 = r4 + Null;
842010ba:	ef fd fc ff 	call (m) 0x8d0;
842010be:	37 e0 
            list_samples += list_tag->length;
842010c0:	f1 88       	rMAC = M[r4 + 12];
842010c2:	cf 01       	r5 = rMAC + r5;
            list_tag = list_tag->next;
842010c4:	36 e8       	r4 = M[r4 + Null];
        /* In case there were multiple metadata tags on the input,
         * extrapolate the timestamps to any subsequent tags
         */
        list_tag = mtag->next;
        list_samples = mtag->length;
        while (list_tag != NULL)
842010c6:	ec 6f       	jump (m) Lc_metadata_transport_with_ttp_18;

842010c8 <Lc_metadata_transport_with_ttp_20>:
    {
        buff_metadata_append(buffer, mtag, b4idx, afteridx);
    }
    else
    {
        buff_metadata_tag_list_delete(mtag);
842010c8:	42 08       	r0 = r6 + Null;
842010ca:	ff fd 84 f0 	call (m) 0x11906;
842010ce:	3d e1 

842010d0 <Lc_metadata_transport_with_ttp_21>:
    }

}
842010d0:	f5 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, rLink>;
842010d2:	d8 4c       	rts;

842010d4 <Lc_rtp_decode_empty_internal_buffers_1>:
/**
 * Function which tries to empty the internal buffers of the RTP decode
 * by copying to output.
 */
static void rtp_decode_empty_internal_buffers(RTP_DECODE_OP_DATA *opx_data,TOUCHED_TERMINALS *touched)
{
842010d4:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842010d6:	16 00       	r4 = r0 + Null;
842010d8:	1f 00       	r5 = r1 + Null;
    unsigned data;
    if (!opx_data->pack_latency_buffer)
842010da:	70 b9       	Null = M[r4 + 116];
842010dc:	23 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_6;

842010de <Lc_rtp_decode_empty_internal_buffers_2>:
    {
        return;
    }
    data = buff_metadata_available_octets(opx_data->u.pack.frame_buffer);
842010de:	b2 a8       	r0 = M[r4 + 72];
842010e0:	ff fd 86 f0 	call (m) 0x11d04;
842010e4:	25 e1 
842010e6:	14 00       	r2 = r0 + Null;
    if (data > 0)
842010e8:	0b 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_4;

842010ea <Lc_rtp_decode_empty_internal_buffers_3>:
    {
        data = cbuffer_copy_ex(opx_data->u.pack.internal_buffer, opx_data->u.pack.frame_buffer, data);
842010ea:	b3 a8       	r1 = M[r4 + 72];
842010ec:	f2 a8       	r0 = M[r4 + 76];
842010ee:	01 f0 3b e6 	call (m) $_cbuffer_copy_ex;
842010f2:	14 00       	r2 = r0 + Null;
        metadata_strict_transport(opx_data->u.pack.frame_buffer, opx_data->u.pack.internal_buffer, data);
842010f4:	f3 a8       	r1 = M[r4 + 76];
842010f6:	b2 a8       	r0 = M[r4 + 72];
842010f8:	ff fd 87 f0 	call (m) 0x12076;
842010fc:	3f eb 

842010fe <Lc_rtp_decode_empty_internal_buffers_4>:
    }
    data = buff_metadata_available_octets(opx_data->u.pack.internal_buffer);
842010fe:	f2 a8       	r0 = M[r4 + 76];
84201100:	ff fd 86 f0 	call (m) 0x11d04;
84201104:	25 e0 
84201106:	14 00       	r2 = r0 + Null;
    if (data > 0)
84201108:	0d 60       	if EQ jump (m) Lc_rtp_decode_empty_internal_buffers_6;

8420110a <Lc_rtp_decode_empty_internal_buffers_5>:
    {

        data = cbuffer_copy_ex(opx_data->op_buffer, opx_data->u.pack.internal_buffer, data);
8420110a:	f3 a8       	r1 = M[r4 + 76];
8420110c:	32 a8       	r0 = M[r4 + 64];
8420110e:	01 f0 3b e5 	call (m) $_cbuffer_copy_ex;
84201112:	14 00       	r2 = r0 + Null;
        metadata_strict_transport(opx_data->u.pack.internal_buffer, opx_data->op_buffer, data);
84201114:	33 a8       	r1 = M[r4 + 64];
84201116:	f2 a8       	r0 = M[r4 + 76];
84201118:	ff fd 87 f0 	call (m) 0x12076;
8420111c:	3f ea 
        /* Kick forward if there was any valid frames in the RTP packet. */
        touched->sources = TOUCHED_SOURCE_0;
8420111e:	41 20       	rMAC = Null + 1;
84201120:	39 ee       	M[r5 + Null] = rMAC;

84201122 <Lc_rtp_decode_empty_internal_buffers_6>:
    }
}
84201122:	f2 48       	popm <FP, r4, r5, rLink>;
84201124:	d8 4c       	rts;

84201126 <Lc_get_AAC_codec_1>:
 *
 * \param ext_op_id Operator id.
 * \returns AAC codec needed to decode and AAC frame.
 */
static void* get_AAC_codec(unsigned ext_op_id)
{
84201126:	f1 1c       	pushm <FP(=SP), r4, rLink>;
    OPERATOR_DATA *op_data = get_op_data_from_id(EXT_TO_INT_OPID(ext_op_id));
84201128:	ff fd 07 f0 	call (m) 0x1f52;
8420112c:	2b e1 
8420112e:	ff fd 08 f0 	call (m) 0x217e;
84201132:	31 e2 
84201134:	16 00       	r4 = r0 + Null;
    if (op_data != NULL)
84201136:	10 60       	if EQ jump (m) Lc_get_AAC_codec_5;

84201138 <Lc_get_AAC_codec_2>:
    {
        if ((base_op_get_cap_id(op_data) == CAP_ID_AAC_DECODER) || (base_op_get_cap_id(op_data) == CAP_ID_DOWNLOAD_AAC_DECODER))
84201138:	01 f0 3f ef 	call (m) $_base_op_get_cap_id;
8420113c:	10 2e       	Null = r0 - 24;
8420113e:	08 60       	if EQ jump (m) Lc_get_AAC_codec_4;

84201140 <Lc_get_AAC_codec_3>:
84201140:	32 00       	r0 = r4 + Null;
84201142:	01 f0 35 ef 	call (m) $_base_op_get_cap_id;
84201146:	01 f0 20 f0 	Null = r0 - 16463;
8420114a:	4f 24 
8420114c:	05 62       	if NE jump (m) Lc_get_AAC_codec_5;

8420114e <Lc_get_AAC_codec_4>:
             * happens to be the extra op data because the decoder is the first field
             * in the structure. More details: AAC_DEC_OP_DATA first field is decoder_data
             * which first filed is codec of the type DECODER. The decoder is used to
             * decode the aac frame so if the hierarchy is not true any more this
             * function need changes. */
            return base_op_get_instance_data(op_data);
8420114e:	32 00       	r0 = r4 + Null;
84201150:	01 f0 23 ef 	call (m) $_base_op_get_instance_data;
84201154:	02 6e       	jump (m) Lc_get_AAC_codec_6;

84201156 <Lc_get_AAC_codec_5>:
        }
        else
        {
            return NULL;
84201156:	02 00       	r0 = Null + Null;

84201158 <Lc_get_AAC_codec_6>:
        }
    }
    return NULL;
}
84201158:	f1 48       	popm <FP, r4, rLink>;
8420115a:	d8 4c       	rts;

8420115c <$_get_samples_in_packet>:
8420115c:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
        fault_diatribe(FAULT_RTP_SBC_SYNC_LOST, sbc_header[0]);
    }
}

void get_samples_in_packet(RTP_DECODE_OP_DATA *opx_data, RTP_FRAME_DECODE_DATA* frame_data)
{
8420115e:	17 00       	r5 = r0 + Null;
84201160:	1e 00       	r4 = r1 + Null;
    tCbuffer *clone_buffer;
    unsigned payload_size;

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84201162:	78 b9       	Null = M[r5 + 116];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84201164:	7a a8       	r0 = M[r5 + 68];
    else
    {
        clone_buffer = opx_data->u.clone_op_buffer;
    }

    payload_size = cbuffer_calc_amount_data_ex(clone_buffer);
84201166:	03 f0 27 e2 	call (m) $_cbuffer_calc_amount_data_ex;
    frame_data->valid = FALSE;
8420116a:	30 ee       	M[r4 + Null] = Null;

    switch (opx_data->codec_type)
8420116c:	79 a0       	rMAC = MBS[r5 + 17];
8420116e:	1e 60       	if EQ jump (m) Lc_get_samples_in_packet_11;

84201170 <Lc_get_samples_in_packet_2>:
84201170:	48 24       	Null = rMAC - 1;
84201172:	17 60       	if EQ jump (m) Lc_get_samples_in_packet_10;

84201174 <Lc_get_samples_in_packet_3>:
84201174:	88 24       	Null = rMAC - 2;
84201176:	4a 68       	if LT jump (m) Lc_get_samples_in_packet_21;

84201178 <Lc_get_samples_in_packet_4>:
84201178:	c8 24       	Null = rMAC - 3;
8420117a:	4d 6c       	if LE jump (m) Lc_get_samples_in_packet_22;

8420117c <Lc_get_samples_in_packet_5>:
8420117c:	08 25       	Null = rMAC - 4;
8420117e:	06 62       	if NE jump (m) Lc_get_samples_in_packet_7;

84201180 <Lc_get_samples_in_packet_6>:
            frame_data->nr_of_frames = 1;
            break;
        }
        case AAC:
        {
            aac_sample_count(opx_data, payload_size, frame_data);
84201180:	34 00       	r2 = r4 + Null;
84201182:	13 00       	r1 = r0 + Null;
84201184:	3a 00       	r0 = r5 + Null;
84201186:	49 4e       	call (m) Lc_aac_sample_count_1;
            break;
84201188:	46 6e       	jump (m) Lc_get_samples_in_packet_22;

8420118a <Lc_get_samples_in_packet_7>:
    }

    payload_size = cbuffer_calc_amount_data_ex(clone_buffer);
    frame_data->valid = FALSE;

    switch (opx_data->codec_type)
8420118a:	48 25       	Null = rMAC - 5;
8420118c:	24 60       	if EQ jump (m) Lc_get_samples_in_packet_16;

8420118e <Lc_get_samples_in_packet_8>:
8420118e:	88 25       	Null = rMAC - 6;
84201190:	3d 62       	if NE jump (m) Lc_get_samples_in_packet_21;

84201192 <Lc_get_samples_in_packet_9>:
            }
            break;
        }
        case APTXADAPTIVE:
        {
            frame_data->valid = TRUE;
84201192:	41 20       	rMAC = Null + 1;
84201194:	31 ee       	M[r4 + Null] = rMAC;
            /* Extract the number of samples from the RTP Timestamp */
            frame_data->frame_samples = RTP_TIMESTAMP_APTX_AD_GET_SAMPLES(frame_data->rtp_timestamp);
84201196:	31 89       	rMAC = M[r4 + 16];
84201198:	89 c6       	rMAC = rMAC AND 0xffff;
8420119a:	b1 8e       	M[r4 + 8] = rMAC;
            frame_data->frame_length = payload_size;
8420119c:	72 8e       	M[r4 + 4] = r0;
8420119e:	28 6e       	jump (m) Lc_get_samples_in_packet_18;

842011a0 <Lc_get_samples_in_packet_10>:

    switch (opx_data->codec_type)
    {
        case SBC:
        {
            sbc_sample_count(opx_data, payload_size, frame_data);
842011a0:	34 00       	r2 = r4 + Null;
842011a2:	13 00       	r1 = r0 + Null;
842011a4:	3a 00       	r0 = r5 + Null;
842011a6:	55 4e       	call (m) Lc_sbc_sample_count_1;
            break;
842011a8:	36 6e       	jump (m) Lc_get_samples_in_packet_22;

842011aa <Lc_get_samples_in_packet_11>:
        {
            break;
        }
        case APTX:
        {
            frame_data->valid = TRUE;
842011aa:	41 20       	rMAC = Null + 1;
842011ac:	31 ee       	M[r4 + Null] = rMAC;
            /* For aptX, the generated samples is the same as the number of encoded octets,
             * as long as the input number of octets is a multiple of 4.
             * This is assumed to always be the case here. */
            payload_size = payload_size >> 2;
842011ae:	52 50       	r0 = r0 LSHIFT -2;
            payload_size = payload_size << 2;
            if (payload_size != 0)
842011b0:	52 54       	r0 = r0 LSHIFT 2;
842011b2:	05 60       	if EQ jump (m) Lc_get_samples_in_packet_13;

842011b4 <Lc_get_samples_in_packet_12>:
            {
                frame_data->frame_length = payload_size;
842011b4:	72 8e       	M[r4 + 4] = r0;
                frame_data->nr_of_frames = 1;
842011b6:	f1 8e       	M[r4 + 12] = rMAC;
                frame_data->frame_samples = payload_size;
842011b8:	b2 8e       	M[r4 + 8] = r0;
842011ba:	2d 6e       	jump (m) Lc_get_samples_in_packet_22;

842011bc <Lc_get_samples_in_packet_13>:
            }
            else
            {
                L4_DBG_MSG("RTP decode APTX classic: Not enough data to create a tag.");
842011bc:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842011c0:	08 25       	Null = rMAC - 4;
842011c2:	07 68       	if LT jump (m) Lc_get_samples_in_packet_15;

842011c4 <Lc_get_samples_in_packet_14>:
842011c4:	55 f1 02 f0 	r0 = Null + 357565331;
842011c8:	93 43 
842011ca:	ef fd fb ff 	call (m) 0x9a2;
842011ce:	39 ee 

842011d0 <Lc_get_samples_in_packet_15>:
                frame_data->nr_of_frames = 0;
842011d0:	f0 8e       	M[r4 + 12] = Null;
842011d2:	21 6e       	jump (m) Lc_get_samples_in_packet_22;

842011d4 <Lc_get_samples_in_packet_16>:
            }
            break;
        }
        case APTXHD:
        {
            frame_data->valid = TRUE;
842011d4:	41 20       	rMAC = Null + 1;
842011d6:	31 ee       	M[r4 + Null] = rMAC;
            /* For aptXHD, every 6 input octets generates 4 output samples. */
            frame_data->frame_samples = payload_size / 3;
842011d8:	c3 20       	r1 = Null + 3;
842011da:	ff fd af f0 	call (m) 0x171b8;
842011de:	3f ee 
            frame_data->frame_samples >>= 1;
842011e0:	12 50       	r0 = r0 LSHIFT -1;
            if (frame_data->frame_samples != 0)
842011e2:	b2 8e       	M[r4 + 8] = r0;
842011e4:	08 60       	if EQ jump (m) Lc_get_samples_in_packet_19;

842011e6 <Lc_get_samples_in_packet_17>:
            {
                frame_data->frame_length = frame_data->frame_samples * 6;
842011e6:	91 41       	rMAC = r0 * 6 (int);
842011e8:	71 8e       	M[r4 + 4] = rMAC;
                frame_data->frame_samples <<= 2;
842011ea:	52 54       	r0 = r0 LSHIFT 2;
842011ec:	b2 8e       	M[r4 + 8] = r0;

842011ee <Lc_get_samples_in_packet_18>:
        {
            frame_data->valid = TRUE;
            /* Extract the number of samples from the RTP Timestamp */
            frame_data->frame_samples = RTP_TIMESTAMP_APTX_AD_GET_SAMPLES(frame_data->rtp_timestamp);
            frame_data->frame_length = payload_size;
            frame_data->nr_of_frames = 1;
842011ee:	41 20       	rMAC = Null + 1;
842011f0:	f1 8e       	M[r4 + 12] = rMAC;
842011f2:	11 6e       	jump (m) Lc_get_samples_in_packet_22;

842011f4 <Lc_get_samples_in_packet_19>:
                /* If the size of the payload received is not a multiple of 6 the remaining
                 * octets will be part of the next payload. */
            }
            else
            {
                L4_DBG_MSG("RTP decode APTX hd: Not enough data to create a tag.");
842011f4:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842011f8:	08 25       	Null = rMAC - 4;
842011fa:	eb 69       	if LT jump (m) Lc_get_samples_in_packet_15;

842011fc <Lc_get_samples_in_packet_20>:
842011fc:	55 f1 02 f0 	r0 = Null + 357565389;
84201200:	cd 43 
84201202:	ef fd fb ff 	call (m) 0x9a2;
84201206:	21 ed 
84201208:	e4 6f       	jump (m) Lc_get_samples_in_packet_15;

8420120a <Lc_get_samples_in_packet_21>:
            break;
        }
        default:
        {
            /*mode not supported yet*/
            panic(PANIC_AUDIO_RTP_UNSUPPORTED_CODEC);
8420120a:	02 f0 7a 40 	r0 = Null + 122;
8420120e:	ff fd 96 f0 	call (m) 0x13f08;
84201212:	3b e7 

84201214 <Lc_get_samples_in_packet_22>:
            break;
        }
    }
}
84201214:	f2 48       	popm <FP, r4, r5, rLink>;
84201216:	d8 4c       	rts;

84201218 <Lc_aac_sample_count_1>:
 * \param payload_size Pointer to the RTP operator data.
 * \param frame_data Pointer to the frame data structure.
 */
static void aac_sample_count(RTP_DECODE_OP_DATA *opx_data, unsigned payload_size,
        RTP_FRAME_DECODE_DATA *frame_decode_data)
{
84201218:	c8 1e       	pushm <FP(=SP), rLink>, SP = SP + 0x20;
    tCbuffer *clone_buffer;
    DECODER *aac_codec_struc = (DECODER *)opx_data->aac_codec;
8420121a:	55 89       	r3 = M[r0 + 20];
    dummy_decoder aac_decoder;

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
8420121c:	50 b9       	Null = M[r0 + 116];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
8420121e:	51 a8       	rMAC = M[r0 + 68];
    }


    /* Initialise the input parameters for the codec.*/
    /* Set the  main decoder's structure.*/
    aac_decoder.codec_struc = aac_codec_struc;
84201220:	15 de       	M[FP + 8] = r3;
    /* Set the return structure. */
    aac_decoder.frame_dec_struc = frame_decode_data;
84201222:	2c de       	M[FP + 20] = r2;

    /* Set the payload size which is all the available data. */
    aac_decoder.payload_size = payload_size;
84201224:	23 de       	M[FP + 16] = r1;

    /* Set the input buffer. */
    aac_decoder.in_cbuffer = clone_buffer;
84201226:	19 de       	M[FP + 12] = rMAC;

    /* Set the bit position. */
    if ((((uintptr_t)(clone_buffer->read_ptr)) & 0x1) == 1)
    {
        /* Second octet from the word. */
        aac_decoder.bit_position = 8;
84201228:	49 88       	rMAC = M[rMAC + 4];
8420122a:	03 22       	r1 = Null + 8;
8420122c:	04 28       	r2 = Null + 16;
8420122e:	09 c0       	rMAC = rMAC AND 0x1;
84201230:	01 f3 04 c0 	if NE r2 = r1 + Null;
84201234:	34 de       	M[FP + 24] = r2;
    {
        /* First octet from the word. */
        aac_decoder.bit_position = 16;
    }

    if (opx_data->aac_utility_select == AAC_LC_OVER_LATM)
84201236:	11 b0       	rMAC = MBS[r0 + 24];
84201238:	06 62       	if NE jump (m) Lc_aac_sample_count_3;

8420123a <Lc_aac_sample_count_2>:
    {
        aacdec_samples_in_packet_lc(&aac_decoder);
8420123a:	82 10       	r0 = FP + 8;
8420123c:	ff fd f1 f2 	call 0x5f468;
84201240:	2c e1 
84201242:	05 6e       	jump (m) Lc_aac_sample_count_4;

84201244 <Lc_aac_sample_count_3>:
    }
    else
    {
        aacdec_samples_in_packet(&aac_decoder);
84201244:	82 10       	r0 = FP + 8;
84201246:	ff fd f2 f2 	call 0x5f670;
8420124a:	2a e1 

8420124c <Lc_aac_sample_count_4>:
    }

}
8420124c:	c8 4a       	SP = SP - 0x20, popm <FP, rLink>;
8420124e:	d8 4c       	rts;

84201250 <Lc_sbc_sample_count_1>:
 * \param payload_size Pointer to the RTP operator data.
 * \param frame_data Pointer to the frame data structure.
 */
static void sbc_sample_count(RTP_DECODE_OP_DATA* opx_data, unsigned payload_size,
        RTP_FRAME_DECODE_DATA* frame_data)
{
84201250:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84201252:	1a 09       	r8 = r1 + Null;
84201254:	21 09       	r7 = r2 + Null;
    tCbuffer *clone_buffer;
    unsigned sbc_header[SBC_SAMPLE_COUNT_HEADER_SIZE];

    /* Select the internal buffers based on the packing */
    if (opx_data->pack_latency_buffer)
84201256:	50 b9       	Null = M[r0 + 116];
    {
        clone_buffer = opx_data->u.pack.clone_frame_buffer;
84201258:	53 a8       	r1 = M[r0 + 68];
    {
        clone_buffer = opx_data->u.clone_op_buffer;
    }
    /* Read and unpack the sbc header. */
    unpack_cbuff_to_array_from_offset((int*) &sbc_header, clone_buffer, 0,
            SBC_SAMPLE_COUNT_HEADER_SIZE);
8420125a:	c5 20       	r3 = Null + 3;
8420125c:	c2 11       	r0 = FP + 28;
8420125e:	04 00       	r2 = Null + Null;
84201260:	77 4e       	call (m) $_unpack_cbuff_to_array_from_offset;
    if (sbc_header[0] == SBC_HEADER0_SYNC)
84201262:	3b d8       	r1 = M[FP + 28];
84201264:	30 f0 9c 24 	Null = r1 - 156;
84201268:	4a 62       	if NE jump (m) Lc_sbc_sample_count_12;

8420126a <Lc_sbc_sample_count_2>:
    {
        unsigned mode = sbc_header[1] & SBC_HEADER1_CHANNEL_MASK;
8420126a:	42 d8       	r0 = M[FP + 32];
8420126c:	21 f0 0c 00 	rMAC = r0 AND 0xc;
        unsigned nrof_blocks = SBC_HEADER1_GET_NROF_BLOCKS(sbc_header[1]);
84201270:	d3 50       	r1 = r0 LSHIFT -4;
84201272:	9b c0       	r1 = r1 AND 0x3;
84201274:	5b 20       	r1 = r1 + 1;
84201276:	5f 54       	r5 = r1 LSHIFT 2;
        unsigned nrof_subbands = SBC_HEADER1_GET_NROF_SUBBANDS(sbc_header[1]);
84201278:	12 c0       	r0 = r0 AND 0x1;
8420127a:	52 20       	r0 = r0 + 1;
8420127c:	56 54       	r4 = r0 LSHIFT 2;
        unsigned bitpool = SBC_HEADER2_BITPOOL(sbc_header[2]);
8420127e:	4a d8       	r0 = M[FP + 36];
84201280:	92 c3       	r0 = r0 AND 0xff;
        unsigned frame_length = 0;
        unsigned sbc_frames_in_payload = 0;

        switch (mode)
84201282:	08 04       	Null = rMAC - Null;
84201284:	0d 60       	if EQ jump (m) Lc_sbc_sample_count_6;

84201286 <Lc_sbc_sample_count_3>:
84201286:	08 25       	Null = rMAC - 4;
84201288:	13 60       	if EQ jump (m) Lc_sbc_sample_count_7;

8420128a <Lc_sbc_sample_count_4>:
8420128a:	08 26       	Null = rMAC - 8;
8420128c:	19 60       	if EQ jump (m) Lc_sbc_sample_count_8;

8420128e <Lc_sbc_sample_count_5>:
            case SBC_HEADER1_CHANNEL_JOINT:
            {
                /* nrof_channels = 2;
                 * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_subbands + nrof_blocks *  bitpool)) / 8); */
                frame_length = 4 + nrof_subbands
                        + ((nrof_subbands + nrof_blocks * bitpool) + 7) / 8;
8420128e:	d1 1b       	rMAC = r0 * r5 (int);
84201290:	71 00       	rMAC = r4 + rMAC;
84201292:	ca 21       	r0 = rMAC + 7;
84201294:	92 50       	r0 = r0 LSHIFT -3;
84201296:	91 01       	rMAC = r0 + r4;
84201298:	18 f0 04 20 	r6 = rMAC + 4;
                break;
8420129c:	17 6e       	jump (m) Lc_sbc_sample_count_9;

8420129e <Lc_sbc_sample_count_6>:
            case SBC_HEADER1_CHANNEL_MONO:
            {
                /* nrof_channels = 1;
                 * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * nrof_channels * bitpool) / 8); */
                frame_length = 4 + (nrof_subbands) / 2
                        + ((nrof_blocks * bitpool) + 7) / 8;
8420129e:	d1 1b       	rMAC = r0 * r5 (int);
842012a0:	33 50       	r1 = r4 LSHIFT -1;
842012a2:	ca 21       	r0 = rMAC + 7;
842012a4:	92 50       	r0 = r0 LSHIFT -3;
842012a6:	d1 00       	rMAC = r0 + r1;
842012a8:	18 f0 04 20 	r6 = rMAC + 4;
                break;
842012ac:	0f 6e       	jump (m) Lc_sbc_sample_count_9;

842012ae <Lc_sbc_sample_count_7>:
            case SBC_HEADER1_CHANNEL_DUAL:
            {
                /* nrof_channels = 2;
                 * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * nrof_channels * bitpool) / 8); */
                frame_length = 4 + nrof_subbands
                        + ((nrof_blocks * 2 * bitpool) + 7) / 8;
842012ae:	3b 54       	r1 = r5 LSHIFT 1;
842012b0:	99 1a       	rMAC = r1 * r0 (int);
842012b2:	ca 21       	r0 = rMAC + 7;
842012b4:	92 50       	r0 = r0 LSHIFT -3;
842012b6:	91 01       	rMAC = r0 + r4;
842012b8:	18 f0 04 20 	r6 = rMAC + 4;
                break;
842012bc:	07 6e       	jump (m) Lc_sbc_sample_count_9;

842012be <Lc_sbc_sample_count_8>:
            case SBC_HEADER1_CHANNEL_STEREO:
            {
                /* nrof_channels = 2;
                 * frame_length = 4 + (4 * nrof_subbands * nrof_channels) / 8 +  ceil((nrof_blocks * bitpool) / 8); */
                frame_length = 4 + nrof_subbands
                        + ((nrof_blocks * bitpool) + 7) / 8;
842012be:	d1 1b       	rMAC = r0 * r5 (int);
842012c0:	ca 21       	r0 = rMAC + 7;
842012c2:	92 50       	r0 = r0 LSHIFT -3;
842012c4:	91 01       	rMAC = r0 + r4;
842012c6:	18 f0 04 20 	r6 = rMAC + 4;

842012ca <Lc_sbc_sample_count_9>:
                break;
            }
        }
        if (frame_length != 0)
        {
            if (payload_size % frame_length == 0)
842012ca:	52 08       	r0 = r8 + Null;
842012cc:	43 08       	r1 = r6 + Null;
842012ce:	ff fd af f0 	call (m) 0x171d6;
842012d2:	29 e8 
842012d4:	10 04       	Null = r0 - Null;
842012d6:	18 62       	if NE jump (m) Lc_sbc_sample_count_13;

842012d8 <Lc_sbc_sample_count_10>:
            {
                frame_data->frame_length = frame_length;
842012d8:	98 f0 01 8e 	M[r7 + 4] = r6;
                sbc_frames_in_payload = payload_size / frame_length;
842012dc:	52 08       	r0 = r8 + Null;
842012de:	43 08       	r1 = r6 + Null;
842012e0:	ff fd af f0 	call (m) 0x171b8;
842012e4:	39 e6 
                 * frames in the packet have different sizes. */
                sbc_frames_in_payload = 0;
            }
        }

        if (sbc_frames_in_payload != 0)
842012e6:	10 04       	Null = r0 - Null;
842012e8:	0f 60       	if EQ jump (m) Lc_sbc_sample_count_13;

842012ea <Lc_sbc_sample_count_11>:
        {
            frame_data->valid = TRUE;
842012ea:	41 20       	rMAC = Null + 1;
842012ec:	91 f0 00 ee 	M[r7 + Null] = rMAC;
            frame_data->nr_of_frames = sbc_frames_in_payload;
842012f0:	92 f0 03 8e 	M[r7 + 12] = r0;
            /* frame_samples =  nrof_subbands * nrof_blocks. */
            frame_data->frame_samples = nrof_subbands * nrof_blocks;
842012f4:	f1 1b       	rMAC = r4 * r5 (int);
842012f6:	91 f0 02 8e 	M[r7 + 8] = rMAC;
842012fa:	06 6e       	jump (m) Lc_sbc_sample_count_13;

842012fc <Lc_sbc_sample_count_12>:
        }
    }
    else
    {
        fault_diatribe(FAULT_RTP_SBC_SYNC_LOST, sbc_header[0]);
842012fc:	02 f0 4c 40 	r0 = Null + 76;
84201300:	ff fd 94 f0 	call (m) 0x13bcc;
84201304:	2d e6 

84201306 <Lc_sbc_sample_count_13>:
    }
}
84201306:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84201308:	d8 4c       	rts;

8420130a <$_unpack_cbuff_to_array>:
8420130a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
Private Function Definitions
*/

/* unpack_cbuff_to_array */
unsigned int unpack_cbuff_to_array(int *dest, tCbuffer *cbuffer_src, unsigned int amount_to_copy)
{
8420130c:	10 09       	r6 = r0 + Null;
8420130e:	1f 00       	r5 = r1 + Null;
84201310:	26 00       	r4 = r2 + Null;
    unsigned int available;
    unsigned int usable_octets;

    usable_octets = cbuffer_get_usable_octets(cbuffer_src);
84201312:	3a 00       	r0 = r5 + Null;
84201314:	d9 4e       	call (m) $_cbuffer_get_usable_octets;
84201316:	11 09       	r7 = r0 + Null;

    /* check amount */
    available = cbuffer_calc_amount_data_ex(cbuffer_src);
84201318:	3a 00       	r0 = r5 + Null;
8420131a:	02 f0 33 e4 	call (m) $_cbuffer_calc_amount_data_ex;
    if (available < amount_to_copy)
8420131e:	90 05       	Null = r0 - r4;
84201320:	02 f0 87 e0 	if C jump (m) Lc_unpack_cbuff_to_array_3;

84201324 <Lc_unpack_cbuff_to_array_2>:
    {
        amount_to_copy = available;
84201324:	16 00       	r4 = r0 + Null;

84201326 <Lc_unpack_cbuff_to_array_3>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
84201326:	30 04       	Null = r4 - Null;
84201328:	09 60       	if EQ jump (m) Lc_unpack_cbuff_to_array_6;

8420132a <Lc_unpack_cbuff_to_array_4>:
    {
        return amount_to_copy;
    }

    if(usable_octets == 2)
8420132a:	90 f0 02 24 	Null = r7 - 2;
8420132e:	08 62       	if NE jump (m) Lc_unpack_cbuff_to_array_7;

84201330 <Lc_unpack_cbuff_to_array_5>:
    {
        /* 16-bit unpacked buffers */
        unpack_cbuff_to_array_16bit(dest, cbuffer_src, amount_to_copy);
84201330:	34 00       	r2 = r4 + Null;
84201332:	3b 00       	r1 = r5 + Null;
84201334:	42 08       	r0 = r6 + Null;
84201336:	01 f0 31 e0 	call (m) $_unpack_cbuff_to_array_16bit;

8420133a <Lc_unpack_cbuff_to_array_6>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
    {
        return amount_to_copy;
8420133a:	32 00       	r0 = r4 + Null;
8420133c:	07 6e       	jump (m) Lc_unpack_cbuff_to_array_8;

8420133e <Lc_unpack_cbuff_to_array_7>:
        unpack_cbuff_to_array_16bit(dest, cbuffer_src, amount_to_copy);
    }
    else
    {
        /* 32-bit packed buffers */
        unpack_cbuff_to_array_32bit(dest, cbuffer_src, amount_to_copy);
8420133e:	34 00       	r2 = r4 + Null;
84201340:	3b 00       	r1 = r5 + Null;
84201342:	42 08       	r0 = r6 + Null;
84201344:	01 f0 2f e8 	call (m) $_unpack_cbuff_to_array_32bit;
84201348:	f9 6f       	jump (m) Lc_unpack_cbuff_to_array_6;

8420134a <Lc_unpack_cbuff_to_array_8>:
    }


    return amount_to_copy;
}
8420134a:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420134c:	d8 4c       	rts;

8420134e <$_unpack_cbuff_to_array_from_offset>:

/* unpack_cbuff_to_array_from_offset */
unsigned int unpack_cbuff_to_array_from_offset(int *dest, tCbuffer *cbuffer_src,
        unsigned int offset, unsigned int amount_to_copy)
{
8420134e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201350:	12 09       	r8 = r0 + Null;
84201352:	18 09       	r6 = r1 + Null;
84201354:	26 00       	r4 = r2 + Null;
84201356:	2f 00       	r5 = r3 + Null;
    unsigned int available;
    unsigned int usable_octets;

    usable_octets = cbuffer_get_usable_octets(cbuffer_src);
84201358:	42 08       	r0 = r6 + Null;
8420135a:	b6 4e       	call (m) $_cbuffer_get_usable_octets;
8420135c:	11 09       	r7 = r0 + Null;

    /* check amount */
    available = cbuffer_calc_amount_data_ex(cbuffer_src);
8420135e:	42 08       	r0 = r6 + Null;
84201360:	02 f0 2d e2 	call (m) $_cbuffer_calc_amount_data_ex;

    if (available <= offset)
84201364:	90 05       	Null = r0 - r4;
84201366:	08 f0 89 e0 	if HI jump (m) Lc_unpack_cbuff_to_array_from_offset_3;

8420136a <Lc_unpack_cbuff_to_array_from_offset_2>:
    {
        return 0;
8420136a:	02 00       	r0 = Null + Null;
8420136c:	1a 6e       	jump (m) Lc_unpack_cbuff_to_array_from_offset_10;

8420136e <Lc_unpack_cbuff_to_array_from_offset_3>:
    }

    if (available < amount_to_copy + offset)
8420136e:	b9 01       	rMAC = r5 + r4;
84201370:	50 04       	Null = r0 - rMAC;
84201372:	02 f0 87 e0 	if C jump (m) Lc_unpack_cbuff_to_array_from_offset_5;

84201376 <Lc_unpack_cbuff_to_array_from_offset_4>:
    {
        amount_to_copy = available - offset;
84201376:	97 05       	r5 = r0 - r4;

84201378 <Lc_unpack_cbuff_to_array_from_offset_5>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
84201378:	38 04       	Null = r5 - Null;
8420137a:	0a 60       	if EQ jump (m) Lc_unpack_cbuff_to_array_from_offset_8;

8420137c <Lc_unpack_cbuff_to_array_from_offset_6>:
    {
        return amount_to_copy;
    }

    if(usable_octets == 2)
8420137c:	90 f0 02 24 	Null = r7 - 2;
84201380:	09 62       	if NE jump (m) Lc_unpack_cbuff_to_array_from_offset_9;

84201382 <Lc_unpack_cbuff_to_array_from_offset_7>:
    {
        /* 16-bit unpacked buffers */
        unpack_cbuff_to_array_from_offset_16bit(dest, cbuffer_src, amount_to_copy,
                                                offset);
84201382:	35 00       	r3 = r4 + Null;
84201384:	3c 00       	r2 = r5 + Null;
84201386:	43 08       	r1 = r6 + Null;
84201388:	52 08       	r0 = r8 + Null;
8420138a:	01 f0 3d e1 	call (m) $_unpack_cbuff_to_array_from_offset_16bit;

8420138e <Lc_unpack_cbuff_to_array_from_offset_8>:
    }

    /* nothing to copy */
    if (amount_to_copy == 0)
    {
        return amount_to_copy;
8420138e:	3a 00       	r0 = r5 + Null;
84201390:	08 6e       	jump (m) Lc_unpack_cbuff_to_array_from_offset_10;

84201392 <Lc_unpack_cbuff_to_array_from_offset_9>:
    }
    else
    {
        /* 32-bit packed buffers */
        unpack_cbuff_to_array_from_offset_32bit(dest, cbuffer_src, amount_to_copy,
                                                offset);
84201392:	35 00       	r3 = r4 + Null;
84201394:	3c 00       	r2 = r5 + Null;
84201396:	43 08       	r1 = r6 + Null;
84201398:	52 08       	r0 = r8 + Null;
8420139a:	01 f0 3d e8 	call (m) $_unpack_cbuff_to_array_from_offset_32bit;
8420139e:	f8 6f       	jump (m) Lc_unpack_cbuff_to_array_from_offset_8;

842013a0 <Lc_unpack_cbuff_to_array_from_offset_10>:
    }
    return amount_to_copy;
}
842013a0:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842013a2:	d8 4c       	rts;

842013a4 <$_cbuffer_get_read_offset_ex>:
842013a4:	c8 1c       	pushm <FP(=SP), rLink>;
 */
unsigned int cbuffer_get_read_offset_ex(tCbuffer *cbuffer)
{
    int *read_ptr;

    read_ptr = cbuffer->read_ptr;
842013a6:	51 88       	rMAC = M[r0 + 4];

    PL_ASSERT(!BUF_DESC_IS_REMOTE_MMU(cbuffer->descriptor) &&
              !BUF_DESC_RD_PTR_TYPE_MMU(cbuffer->descriptor));
842013a8:	53 89       	r1 = M[r0 + 20];
842013aa:	5c c0       	r2 = r1 AND 0x2;
842013ac:	06 62       	if NE jump (m) Lc_cbuffer_get_read_offset_ex_4;

842013ae <Lc_cbuffer_get_read_offset_ex_2>:
842013ae:	db c0       	r1 = r1 AND 0x4;
842013b0:	04 62       	if NE jump (m) Lc_cbuffer_get_read_offset_ex_4;

842013b2 <Lc_cbuffer_get_read_offset_ex_3>:

    return ((uintptr_t)read_ptr - (uintptr_t)cbuffer->base_addr);
842013b2:	d2 88       	r0 = M[r0 + 12];
842013b4:	8a 04       	r0 = rMAC - r0;
842013b6:	07 6e       	jump (m) Lc_cbuffer_get_read_offset_ex_5;

842013b8 <Lc_cbuffer_get_read_offset_ex_4>:
    int *read_ptr;

    read_ptr = cbuffer->read_ptr;

    PL_ASSERT(!BUF_DESC_IS_REMOTE_MMU(cbuffer->descriptor) &&
              !BUF_DESC_RD_PTR_TYPE_MMU(cbuffer->descriptor));
842013b8:	c3 3a       	r1 = Null + 59;
842013ba:	02 f0 13 60 	r0 = Null + 4115;
842013be:	ff fd 95 f0 	call (m) 0x13f12;
842013c2:	35 ea 

842013c4 <Lc_cbuffer_get_read_offset_ex_5>:

    return ((uintptr_t)read_ptr - (uintptr_t)cbuffer->base_addr);
}
842013c4:	c8 48       	popm <FP, rLink>;
842013c6:	d8 4c       	rts;

842013c8 <$_cbuffer_copy_ex>:
 *      The number of copied octets. (NOTE: the ASM implementation does not
 *      return the copied octets)
 */
unsigned cbuffer_copy_ex(tCbuffer * dst, tCbuffer *src, unsigned num_octets);
unsigned cbuffer_copy_ex(tCbuffer * dst, tCbuffer *src, unsigned num_octets)
{
842013c8:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842013ca:	11 09       	r7 = r0 + Null;
842013cc:	1f 00       	r5 = r1 + Null;
842013ce:	22 09       	r8 = r2 + Null;
    unsigned src_data, dest_space, octets_to_copy, r_octet_offset, w_octet_offset;
    unsigned us_octets_source = cbuffer_get_usable_octets(src);
842013d0:	3a 00       	r0 = r5 + Null;
842013d2:	7a 4e       	call (m) $_cbuffer_get_usable_octets;
842013d4:	13 09       	r9 = r0 + Null;
    unsigned us_octets_dest = cbuffer_get_usable_octets(dst);
842013d6:	4a 08       	r0 = r7 + Null;
842013d8:	77 4e       	call (m) $_cbuffer_get_usable_octets;
842013da:	10 09       	r6 = r0 + Null;

    /* Only 2 or 4 usable octets are supported. */
    PL_ASSERT((us_octets_source == 2) || (us_octets_source == 4));
842013dc:	b0 f0 02 24 	Null = r9 - 2;
842013e0:	04 60       	if EQ jump (m) Lc_cbuffer_copy_ex_3;

842013e2 <Lc_cbuffer_copy_ex_2>:
842013e2:	b0 f0 04 24 	Null = r9 - 4;
842013e6:	13 62       	if NE jump (m) Lc_cbuffer_copy_ex_7;

842013e8 <Lc_cbuffer_copy_ex_3>:
    PL_ASSERT((us_octets_dest == 2) || (us_octets_dest == 4));
842013e8:	80 f0 02 24 	Null = r6 - 2;
842013ec:	04 60       	if EQ jump (m) Lc_cbuffer_copy_ex_5;

842013ee <Lc_cbuffer_copy_ex_4>:
842013ee:	80 f0 04 24 	Null = r6 - 4;
842013f2:	15 62       	if NE jump (m) Lc_cbuffer_copy_ex_8;

842013f4 <Lc_cbuffer_copy_ex_5>:

    src_data = cbuffer_calc_amount_data_ex(src);
842013f4:	3a 00       	r0 = r5 + Null;
842013f6:	01 f0 37 ed 	call (m) $_cbuffer_calc_amount_data_ex;
842013fa:	16 00       	r4 = r0 + Null;
    dest_space = cbuffer_calc_amount_space_ex(dst);
842013fc:	4a 08       	r0 = r7 + Null;
842013fe:	01 f0 3f ef 	call (m) $_cbuffer_calc_amount_space_ex;

    octets_to_copy = MIN(src_data, num_octets);
84201402:	af f6 00 c2 	Null = r4 - r8;
84201406:	02 f0 a7 e0 	if C jump (m) Lc_cbuffer_copy_ex_9;

8420140a <Lc_cbuffer_copy_ex_6>:
8420140a:	12 6e       	jump (m) Lc_cbuffer_copy_ex_10;

8420140c <Lc_cbuffer_copy_ex_7>:
    unsigned src_data, dest_space, octets_to_copy, r_octet_offset, w_octet_offset;
    unsigned us_octets_source = cbuffer_get_usable_octets(src);
    unsigned us_octets_dest = cbuffer_get_usable_octets(dst);

    /* Only 2 or 4 usable octets are supported. */
    PL_ASSERT((us_octets_source == 2) || (us_octets_source == 4));
8420140c:	03 f0 94 40 	r1 = Null + 148;
84201410:	02 f0 13 60 	r0 = Null + 4115;
84201414:	ff fd 95 f0 	call (m) 0x13f12;
84201418:	3f e7 
8420141a:	4e 6e       	jump (m) Lc_cbuffer_copy_ex_26;

8420141c <Lc_cbuffer_copy_ex_8>:
    PL_ASSERT((us_octets_dest == 2) || (us_octets_dest == 4));
8420141c:	03 f0 95 40 	r1 = Null + 149;
84201420:	02 f0 13 60 	r0 = Null + 4115;
84201424:	ff fd 95 f0 	call (m) 0x13f12;
84201428:	2f e7 
8420142a:	46 6e       	jump (m) Lc_cbuffer_copy_ex_26;

8420142c <Lc_cbuffer_copy_ex_9>:

    src_data = cbuffer_calc_amount_data_ex(src);
    dest_space = cbuffer_calc_amount_space_ex(dst);

    octets_to_copy = MIN(src_data, num_octets);
8420142c:	56 08       	r4 = r8 + Null;

8420142e <Lc_cbuffer_copy_ex_10>:
    octets_to_copy = MIN(octets_to_copy, dest_space);
8420142e:	b0 04       	Null = r4 - r0;
84201430:	02 64       	if NC jump (m) Lc_cbuffer_copy_ex_12;

84201432 <Lc_cbuffer_copy_ex_11>:
84201432:	16 00       	r4 = r0 + Null;

84201434 <Lc_cbuffer_copy_ex_12>:

    if (octets_to_copy == 0)
84201434:	30 04       	Null = r4 - Null;
84201436:	03 62       	if NE jump (m) Lc_cbuffer_copy_ex_14;

84201438 <Lc_cbuffer_copy_ex_13>:
    {
        return 0;
84201438:	02 00       	r0 = Null + Null;
8420143a:	3e 6e       	jump (m) Lc_cbuffer_copy_ex_26;

8420143c <Lc_cbuffer_copy_ex_14>:
    }

    cbuffer_get_read_address_ex(src, &r_octet_offset);
8420143c:	03 12       	r1 = FP + 32;
8420143e:	3a 00       	r0 = r5 + Null;
84201440:	01 f0 25 e8 	call (m) $_cbuffer_get_read_address_ex;
    cbuffer_get_write_address_ex(dst, &w_octet_offset);
84201444:	43 12       	r1 = FP + 36;
84201446:	4a 08       	r0 = r7 + Null;
84201448:	01 f0 2f ea 	call (m) $_cbuffer_get_write_address_ex;

    if(us_octets_source == 2)
8420144c:	b0 f0 02 24 	Null = r9 - 2;
84201450:	1a 62       	if NE jump (m) Lc_cbuffer_copy_ex_20;

84201452 <Lc_cbuffer_copy_ex_15>:
    {
        if(us_octets_dest == 2)
84201452:	80 f0 02 24 	Null = r6 - 2;
84201456:	11 62       	if NE jump (m) Lc_cbuffer_copy_ex_19;

84201458 <Lc_cbuffer_copy_ex_16>:
        {
            /* the unaligned version is MIPS heavier, so keep the aligned variant separate */
           if (r_octet_offset == w_octet_offset)
84201458:	41 d8       	rMAC = M[FP + 32];
8420145a:	4a d8       	r0 = M[FP + 36];
8420145c:	88 04       	Null = rMAC - r0;
8420145e:	07 62       	if NE jump (m) Lc_cbuffer_copy_ex_18;

84201460 <Lc_cbuffer_copy_ex_17>:
           {
               cbuffer_copy_aligned_16bit_be_zero_shift_ex(dst, src, octets_to_copy);
84201460:	34 00       	r2 = r4 + Null;
84201462:	3b 00       	r1 = r5 + Null;
84201464:	4a 08       	r0 = r7 + Null;
84201466:	02 f0 25 e9 	call (m) $_cbuffer_copy_aligned_16bit_be_zero_shift_ex;
8420146a:	25 6e       	jump (m) Lc_cbuffer_copy_ex_25;

8420146c <Lc_cbuffer_copy_ex_18>:
           }
           else
           {
               cbuffer_copy_unaligned_16bit_be_zero_shift_ex(dst, src, octets_to_copy);
8420146c:	34 00       	r2 = r4 + Null;
8420146e:	3b 00       	r1 = r5 + Null;
84201470:	4a 08       	r0 = r7 + Null;
84201472:	02 f0 3d ed 	call (m) $_cbuffer_copy_unaligned_16bit_be_zero_shift_ex;
84201476:	1f 6e       	jump (m) Lc_cbuffer_copy_ex_25;

84201478 <Lc_cbuffer_copy_ex_19>:
           }
        }
        else
        {
            cbuffer_copy_unpacked_to_packed_ex(dst, src, octets_to_copy);
84201478:	34 00       	r2 = r4 + Null;
8420147a:	3b 00       	r1 = r5 + Null;
8420147c:	4a 08       	r0 = r7 + Null;
8420147e:	04 f0 2d e6 	call (m) $_cbuffer_copy_unpacked_to_packed_ex;
84201482:	19 6e       	jump (m) Lc_cbuffer_copy_ex_25;

84201484 <Lc_cbuffer_copy_ex_20>:
        }
    }
    else
    {
        if(us_octets_dest == 2)
84201484:	80 f0 02 24 	Null = r6 - 2;
84201488:	07 62       	if NE jump (m) Lc_cbuffer_copy_ex_22;

8420148a <Lc_cbuffer_copy_ex_21>:
        {
            cbuffer_copy_packed_to_unpacked_ex(dst, src, octets_to_copy);
8420148a:	34 00       	r2 = r4 + Null;
8420148c:	3b 00       	r1 = r5 + Null;
8420148e:	4a 08       	r0 = r7 + Null;
84201490:	04 f0 31 ed 	call (m) $_cbuffer_copy_packed_to_unpacked_ex;
84201494:	10 6e       	jump (m) Lc_cbuffer_copy_ex_25;

84201496 <Lc_cbuffer_copy_ex_22>:
        }
        else
        {
            /* the unaligned version is MIPS heavier, so keep the aligned variant separate */
            if (r_octet_offset == w_octet_offset)
84201496:	41 d8       	rMAC = M[FP + 32];
84201498:	4a d8       	r0 = M[FP + 36];
8420149a:	88 04       	Null = rMAC - r0;
8420149c:	07 62       	if NE jump (m) Lc_cbuffer_copy_ex_24;

8420149e <Lc_cbuffer_copy_ex_23>:
            {
                cbuffer_copy_aligned_32bit_be_zero_shift_ex(dst, src, octets_to_copy);
8420149e:	34 00       	r2 = r4 + Null;
842014a0:	3b 00       	r1 = r5 + Null;
842014a2:	4a 08       	r0 = r7 + Null;
842014a4:	03 f0 37 e3 	call (m) $_cbuffer_copy_aligned_32bit_be_zero_shift_ex;
842014a8:	06 6e       	jump (m) Lc_cbuffer_copy_ex_25;

842014aa <Lc_cbuffer_copy_ex_24>:
            }
            else
            {
                cbuffer_copy_unaligned_32bit_be_zero_shift_ex(dst, src, octets_to_copy);
842014aa:	34 00       	r2 = r4 + Null;
842014ac:	3b 00       	r1 = r5 + Null;
842014ae:	4a 08       	r0 = r7 + Null;
842014b0:	03 f0 3f ed 	call (m) $_cbuffer_copy_unaligned_32bit_be_zero_shift_ex;

842014b4 <Lc_cbuffer_copy_ex_25>:
            }
        }
    }

    /* TODO currently the asm implementation doesn't supply octets_copied */
    return octets_to_copy;
842014b4:	32 00       	r0 = r4 + Null;

842014b6 <Lc_cbuffer_copy_ex_26>:
}
842014b6:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842014b8:	d8 4c       	rts;

842014ba <$_cbuffer_set_usable_octets>:
    usable_octets = buff_metadata_get_usable_octets(buff);
    return (usable_octets == 0 ? 4 : usable_octets);
}

void cbuffer_set_usable_octets(tCbuffer *buff, unsigned usable_octets)
{
842014ba:	c8 1c       	pushm <FP(=SP), rLink>;
    buff_metadata_set_usable_octets(buff, usable_octets);
842014bc:	ff fd 83 f0 	call (m) 0x11c28;
842014c0:	2d eb 

842014c2 <Lc_cbuffer_set_usable_octets_2>:
}
842014c2:	c8 48       	popm <FP, rLink>;
842014c4:	d8 4c       	rts;

842014c6 <$_cbuffer_get_usable_octets>:

/****************************************************************************
Public Function Definitions
*/
unsigned cbuffer_get_usable_octets(tCbuffer *buff)
{
842014c6:	c8 1c       	pushm <FP(=SP), rLink>;
    unsigned usable_octets;
    usable_octets = buff_metadata_get_usable_octets(buff);
842014c8:	ff fd 83 f0 	call (m) 0x11c9a;
842014cc:	33 ee 
    return (usable_octets == 0 ? 4 : usable_octets);
842014ce:	10 04       	Null = r0 - Null;
842014d0:	03 62       	if NE jump (m) Lc_cbuffer_get_usable_octets_3;

842014d2 <Lc_cbuffer_get_usable_octets_2>:
842014d2:	02 21       	r0 = Null + 4;
842014d4:	01 6e       	jump (m) Lc_cbuffer_get_usable_octets_3;

842014d6 <Lc_cbuffer_get_usable_octets_3>:
842014d6:	c8 48       	popm <FP, rLink>;
842014d8:	d8 4c       	rts;

842014da <$_opmgr_op_is_running>:
842014da:	01 00       	rMAC = Null + Null;
 *
 * \param op_data The data structure of the operator to query
 */
bool opmgr_op_is_running(OPERATOR_DATA *op_data)
{
    return op_data->state == OP_RUNNING;
842014dc:	10 b0       	Null = MBS[r0 + 24];
842014de:	20 f0 41 ce 	if EQ rMAC = Null + 1;
842014e2:	0a 00       	r0 = rMAC + Null;

842014e4 <Lc_opmgr_op_is_running_2>:
842014e4:	d8 4c       	rts;

842014e6 <$_base_op_get_sched_info_ex>:
{
    return op_data->cap_data->id;
}

OP_SCHED_INFO_RSP* base_op_get_sched_info_ex(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id)
{
842014e6:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842014e8:	16 00       	r4 = r0 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = xzpnew(OP_SCHED_INFO_RSP);
842014ea:	c3 20       	r1 = Null + 3;
842014ec:	02 29       	r0 = Null + 20;
842014ee:	ff fd 1d f0 	call (m) 0x4f2a;
842014f2:	3d e1 
    if (resp == NULL)
842014f4:	10 04       	Null = r0 - Null;
842014f6:	03 62       	if NE jump (m) Lc_base_op_get_sched_info_ex_3;

842014f8 <Lc_base_op_get_sched_info_ex_2>:
    {
        return NULL;
842014f8:	02 00       	r0 = Null + Null;
842014fa:	04 6e       	jump (m) Lc_base_op_get_sched_info_ex_4;

842014fc <Lc_base_op_get_sched_info_ex_3>:
    }

    resp->op_id = op_data->id;
842014fc:	71 88       	rMAC = M[r4 + 4];
842014fe:	11 ee       	M[r0 + Null] = rMAC;
    resp->status = STATUS_OK;
84201500:	50 8e       	M[r0 + 4] = Null;

84201502 <Lc_base_op_get_sched_info_ex_4>:

    return resp;
84201502:	f1 48       	popm <FP, r4, rLink>;
84201504:	d8 4c       	rts;

84201506 <$_base_op_build_std_response_ex>:
    return op_data->state == OP_RUNNING;
}

/* will allocate and create a success message, with zeroed error_code field */
bool base_op_build_std_response_ex(OPERATOR_DATA *op_data, STATUS_KYMERA status, void **response_data)
{
84201506:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84201508:	16 00       	r4 = r0 + Null;
8420150a:	1f 00       	r5 = r1 + Null;
8420150c:	20 09       	r6 = r2 + Null;
    OP_STD_RSP* resp = xzpnew(OP_STD_RSP);
8420150e:	c3 20       	r1 = Null + 3;
84201510:	02 23       	r0 = Null + 12;
84201512:	ff fd 1d f0 	call (m) 0x4f2a;
84201516:	39 e0 

    if (resp == NULL)
84201518:	10 04       	Null = r0 - Null;
8420151a:	03 62       	if NE jump (m) Lc_base_op_build_std_response_ex_3;

8420151c <Lc_base_op_build_std_response_ex_2>:
    {
        return FALSE;
8420151c:	02 00       	r0 = Null + Null;
8420151e:	08 6e       	jump (m) Lc_base_op_build_std_response_ex_4;

84201520 <Lc_base_op_build_std_response_ex_3>:
    }

    resp->op_id = op_data->id;
84201520:	71 88       	rMAC = M[r4 + 4];
84201522:	11 ee       	M[r0 + Null] = rMAC;
    resp->resp_data.err_code = 0;
84201524:	90 8e       	M[r0 + 8] = Null;
    resp->status = status;
84201526:	57 8e       	M[r0 + 4] = r5;

    *response_data = resp;
84201528:	82 f0 00 ee 	M[r6 + Null] = r0;
    return TRUE;
8420152c:	42 20       	r0 = Null + 1;

8420152e <Lc_base_op_build_std_response_ex_4>:
}
8420152e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84201530:	d8 4c       	rts;

84201532 <$_base_op_get_instance_data>:

void* base_op_get_instance_data(OPERATOR_DATA *op_data)
{
    return op_data->extra_op_data;
84201532:	12 99       	r0 = M[r0 + 48];

84201534 <Lc_base_op_get_instance_data_2>:
84201534:	d8 4c       	rts;

84201536 <$_base_op_get_cap_id>:
}

CAP_ID base_op_get_cap_id(OPERATOR_DATA *op_data)
{
    return op_data->cap_data->id;
84201536:	51 89       	rMAC = M[r0 + 20];
84201538:	0a e8       	r0 = M[rMAC + Null];

8420153a <Lc_base_op_get_cap_id_2>:
8420153a:	d8 4c       	rts;

8420153c <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_rtp_decode_cap_data;
8420153c:	07 f0 02 f0 	r0 = Null + 7340032;
84201540:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84201542:	20 f0 b0 41 	Null = Null + 16816;

84201546 <$_unpack_cbuff_to_array_16bit>:
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
// trashed r3
$_unpack_cbuff_to_array_16bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r5, r7, rLink>;
84201546:	29 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
8420154a:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // uset the dest as a buffer with size of the amount
   I4 = r0;
8420154e:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
84201550:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
84201552:	26 0b       	L4 = r2 + Null;
   push r0;
84201554:	00 f0 32 cf 	push r0;
   pop B4;
84201558:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
8420155c:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
8420155e:	e4 4e       	call (m) $cbuffer.get_read_address_ex;
   I0 = r0;
84201560:	10 0a       	I0 = r0 + Null;
   L0 = r2;
84201562:	24 0b       	L0 = r2 + Null;
   push r3;
84201564:	00 f0 35 cf 	push r3;
   pop B0;
84201568:	00 f6 3a cf 	pop B0;

   r7 =  M[FP + 3*ADDR_PER_WORD];       // copy amount
8420156c:	e9 f0 03 88 	r7 = M[FP + 12];
   Null = r1;                           // r1 is the read offset
84201570:	18 00       	Null = r1 + Null;

   if Z jump copy_unpacked_no_read_offset;
84201572:	08 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpacked_no_read_offset;
   // read the first byte
   r5 = M[I0, ADDR_PER_WORD];
84201574:	71 f0 30 c0 	Null = Null + Null, r5 = M[I0,4];
   r5 = r5 AND 0xff;
84201578:	bf c3       	r5 = r5 AND 0xff;
   M[I4, ADDR_PER_WORD] = r5;
8420157a:	f1 f0 30 d0 	Null = Null + Null, M[I4,4] = r5;
   r7 = r7 - 1;                         // one octet was read so subtract it
8420157e:	99 f0 01 24 	r7 = r7 - 1;

84201582 <$M.unpack_cbuff_to_array_c_stubs.copy_unpacked_no_read_offset>:

   copy_unpacked_no_read_offset:

   r10 = r7 LSHIFT -1;                  // translate to words
84201582:	7f f9 dc d8 	r10 = r7 LSHIFT -1;

   r0 = 0xFF;                           // set r0 to a constant for masking the bottom octets
84201586:	02 f0 ff 40 	r0 = Null + 255;
   r1 = M[I0, M1];                      // read the first word
8420158a:	31 f0 20 c0 	Null = Null + Null, r1 = M[I0,M1];

   do copy_unpack_loop;
8420158e:	07 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop;
      r2 = r1 LSHIFT -8;                // set r2 as the higher octet from the read word
84201590:	dc 51       	r2 = r1 LSHIFT -8;
      r1 = r1 AND r0,                   // set r1 as the lower octet from the read word
       M[I4, M1] = r2;                  // write the higher octet to the memory
84201592:	00 f0 c1 f2 	r1 = r1 AND r0, M[I4,M1] = r2;
84201596:	23 c8 
      M[I4, M1] = r1,                   // write the lower octet to the memory
       r1 = M[I0, M1];                  // read the next word
84201598:	b1 f1 23 d0 	Null = Null + Null, r1 = M[I0,M1], M[I4,M1] = r1;

8420159c <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop>:
   copy_unpack_loop:

   r1 = M[I0, M2];                       // compensate for the additional read
8420159c:	32 f0 20 c0 	Null = Null + Null, r1 = M[I0,M2];

   // write the carry over if neccessary
   Null = r7 AND 0x1;
842015a0:	90 f0 01 00 	Null = r7 AND 0x1;
   if Z jump copy_unpack_copy_done;
842015a4:	06 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_copy_done;

   r2 = M[I0, 0];
842015a6:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
   r2 = r2 LSHIFT -8;
842015aa:	e4 51       	r2 = r2 LSHIFT -8;
   M[I4,ADDR_PER_WORD] = r2;
842015ac:	c1 f0 30 d0 	Null = Null + Null, M[I4,4] = r2;

842015b0 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_copy_done>:

   copy_unpack_copy_done:


   // Update the read address
   r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
842015b0:	12 d8       	r0 = M[FP + 8];
   r1 = I0;
842015b2:	83 08       	r1 = I0 + Null;
   r2 = r7 AND 0x1;                             // offset
842015b4:	94 f0 01 00 	r2 = r7 AND 0x1;
   call $cbuffer.set_read_address_ex;
842015b8:	01 f0 2b e5 	call (m) $_cbuffer_set_read_address_ex;

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
842015bc:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r5, r7, rLink>;
842015c0:	29 f2 6d e0 	popm <FP, r0, r1, r2, r5, r7, rLink>;
   rts;
842015c4:	d8 4c       	rts;

842015c6 <$_unpack_cbuff_to_array_from_offset_16bit>:
// (int *dest, tCbuffer *src, unsigned int amount_to_copy, unsigned offset);
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
$_unpack_cbuff_to_array_from_offset_16bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
842015c6:	2b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
842015ca:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // use the dest as a buffer with size of the amount
   I4 = r0;
842015ce:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
842015d0:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
842015d2:	26 0b       	L4 = r2 + Null;
   push r0;
842015d4:	00 f0 32 cf 	push r0;
   pop B4;
842015d8:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
842015dc:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
842015de:	a4 4e       	call (m) $cbuffer.get_read_address_ex;
   I0 = r0;
842015e0:	10 0a       	I0 = r0 + Null;
   L0 = r2;
842015e2:	24 0b       	L0 = r2 + Null;
   push r3;
842015e4:	00 f0 35 cf 	push r3;
   pop B0;
842015e8:	00 f6 3a cf 	pop B0;

   // Advance the read pointer
   r7 = M[FP + 4*ADDR_PER_WORD];        // offset input
842015ec:	e9 f0 04 88 	r7 = M[FP + 16];
   r7 = r7 + r1;
842015f0:	19 0d       	r7 = r1 + r7;
   r1 = r7 AND 0x1;                     // get the new offset
842015f2:	93 f0 01 00 	r1 = r7 AND 0x1;
   r7 = r7 LSHIFT -1;                   // get the words
842015f6:	7f f9 d9 d8 	r7 = r7 LSHIFT -1;
   r7 = r7 LSHIFT LOG2_ADDR_PER_WORD;   // get the octets from words - only 16bit unpacked
842015fa:	01 f9 d9 c8 	r7 = r7 LSHIFT 2;
   M3 = r7;
842015fe:	4b 0b       	M3 = r7 + Null;
   r0 = M[I0, M3];  // advancing the read pointer.
84201600:	23 f0 20 c0 	Null = Null + Null, r0 = M[I0,M3];


   r7 =  M[FP + 3*ADDR_PER_WORD];              // copy amount
84201604:	e9 f0 03 88 	r7 = M[FP + 12];
   Null = r1;                                  // r1 is the read offset
84201608:	18 00       	Null = r1 + Null;

   if Z jump copy_unpack_from_offset_no_read_offset;
8420160a:	08 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_no_read_offset;
   // read the first byte
   r5 = M[I0, ADDR_PER_WORD];
8420160c:	71 f0 30 c0 	Null = Null + Null, r5 = M[I0,4];
   r5 = r5 AND 0xff;
84201610:	bf c3       	r5 = r5 AND 0xff;
   M[I4, ADDR_PER_WORD] = r5;
84201612:	f1 f0 30 d0 	Null = Null + Null, M[I4,4] = r5;
   r7 = r7 - 1;                                 // one octet copied so subtract it
84201616:	99 f0 01 24 	r7 = r7 - 1;

8420161a <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_no_read_offset>:

   copy_unpack_from_offset_no_read_offset:

   r10 = r7 LSHIFT -1;                          // translate to words
8420161a:	7f f9 dc d8 	r10 = r7 LSHIFT -1;

   r0 = 0xFF;                            // set r0 to a constant for masking the bottom octets
8420161e:	02 f0 ff 40 	r0 = Null + 255;
   r1 = M[I0, M1];                       // read the first word
84201622:	31 f0 20 c0 	Null = Null + Null, r1 = M[I0,M1];

   do copy_unpack_from_offset_loop;
84201626:	07 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop;
      r2 = r1 LSHIFT -8;                // set r2 as the higher octet from the read word
84201628:	dc 51       	r2 = r1 LSHIFT -8;
      r1 = r1 AND r0,                   // set r1 as the lower octet from the read word
       M[I4, M1] = r2;                  // write the higher octet to the memory
8420162a:	00 f0 c1 f2 	r1 = r1 AND r0, M[I4,M1] = r2;
8420162e:	23 c8 

      M[I4, M1] = r1,                   // write the lower octet to the memory
       r1 = M[I0, M1];                  // read the next word
84201630:	b1 f1 23 d0 	Null = Null + Null, r1 = M[I0,M1], M[I4,M1] = r1;

84201634 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop>:
   copy_unpack_from_offset_loop:

   r1 = M[I0, M2];                      // compensate for the additional read
84201634:	32 f0 20 c0 	Null = Null + Null, r1 = M[I0,M2];

   // write the carry over if neccessary
   Null = r7 AND 0x1;
84201638:	90 f0 01 00 	Null = r7 AND 0x1;
   if Z jump copy_unpack_from_offset_copy_done;
8420163c:	06 60       	if EQ jump (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_copy_done;

   r2 = M[I0, 0];
8420163e:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
   r2 = r2 LSHIFT -8;
84201642:	e4 51       	r2 = r2 LSHIFT -8;
   M[I4, ADDR_PER_WORD] = r2;
84201644:	c1 f0 30 d0 	Null = Null + Null, M[I4,4] = r2;

84201648 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_copy_done>:

   copy_unpack_from_offset_copy_done:

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
84201648:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
8420164c:	2b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
   rts;
84201650:	d8 4c       	rts;

84201652 <$_unpack_cbuff_to_array_32bit>:
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
// trashed r3
$_unpack_cbuff_to_array_32bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, rLink>;
84201652:	0b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, rLink>;
   pushm <I0, I4, L0, L4>;
84201656:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // uset the dest as a buffer with size of the amount
   I4 = r0;
8420165a:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
8420165c:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
8420165e:	26 0b       	L4 = r2 + Null;
   push r0;
84201660:	00 f0 32 cf 	push r0;
   pop B4;
84201664:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                // cbuffer_src
84201668:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
8420166a:	5e 4e       	call (m) $cbuffer.get_read_address_ex;
   I0 = r0;
8420166c:	10 0a       	I0 = r0 + Null;
   L0 = r2;
8420166e:	24 0b       	L0 = r2 + Null;
   push r3;
84201670:	00 f0 35 cf 	push r3;
   pop B0;
84201674:	00 f6 3a cf 	pop B0;

   r3 = 0x3;
84201678:	c5 20       	r3 = Null + 3;
   r10 =  M[FP + 3*ADDR_PER_WORD];    // copy amount
8420167a:	ec f0 03 88 	r10 = M[FP + 12];
   r0 = 0xFF;
8420167e:	02 f0 ff 40 	r0 = Null + 255;
   do copy_unpack_loop_32bit;
84201682:	11 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop_32bit;
       r5 = r3 - r1;
84201684:	ef 04       	r5 = r3 - r1;
       r5 = r5 LSHIFT 3;
84201686:	bf 54       	r5 = r5 LSHIFT 3;
       r5 = -r5;                      // shift amount for source word
84201688:	c7 05       	r5 = Null - r5;

       r2 = M[I0, 0];
8420168a:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
       r2 = r2 LSHIFT r5;             // shift octet left to LS position
8420168e:	e4 17       	r2 = r2 LSHIFT r5;
       r1 = r1 + 1;
84201690:	5b 20       	r1 = r1 + 1;
       Null = ADDR_PER_WORD - r1;
84201692:	02 f3 50 c6 	Null = 4 - r1;
       if NZ jump continue_masking;
84201696:	04 62       	if NE jump (m) $M.unpack_cbuff_to_array_c_stubs.continue_masking;
           r1 = 0;
84201698:	03 00       	r1 = Null + Null;
           r5 = M[I0, M1];            // advance one word
8420169a:	71 f0 20 c0 	Null = Null + Null, r5 = M[I0,M1];

8420169e <$M.unpack_cbuff_to_array_c_stubs.continue_masking>:

       continue_masking:
       r2 = r2 AND r0;
8420169e:	a4 10       	r2 = r2 AND r0;

       M[I4, M1] = r2;
842016a0:	c1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r2;

842016a4 <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_loop_32bit>:

   copy_unpack_loop_32bit:

   // Update the read address
   r0 = M[FP + 2*ADDR_PER_WORD];      // cbuffer_src
842016a4:	12 d8       	r0 = M[FP + 8];
   r2 = r1;                           // offset
842016a6:	1c 00       	r2 = r1 + Null;
   r1 = I0;
842016a8:	83 08       	r1 = I0 + Null;
   call $cbuffer.set_read_address_ex;
842016aa:	dc 4e       	call (m) $_cbuffer_set_read_address_ex;

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
842016ac:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, rLink>;
842016b0:	0b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, rLink>;
   rts;
842016b4:	d8 4c       	rts;

842016b6 <$_unpack_cbuff_to_array_from_offset_32bit>:
// (int *dest, tCbuffer *src, unsigned int amount_to_copy, unsigned offset);
// M1 = ADDR_PER_WORD
// M2 = -ADDR_PER_WORD
$_unpack_cbuff_to_array_from_offset_32bit:
   // save the input paramerters for later
   pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
842016b6:	2b f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r5, r7, rLink>;
   pushm <I0, I4, L0, L4>;
842016ba:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

   // use the dest as a buffer with size of the amount
   I4 = r0;
842016be:	14 0a       	I4 = r0 + Null;
   r2 = r2 LSHIFT LOG2_ADDR_PER_WORD;
842016c0:	64 54       	r2 = r2 LSHIFT 2;
   L4 = r2;
842016c2:	26 0b       	L4 = r2 + Null;
   push r0;
842016c4:	00 f0 32 cf 	push r0;
   pop B4;
842016c8:	00 f6 3c cf 	pop B4;

   // get src buffer read address and size
   r0 = r1;                           // cbuffer_src
842016cc:	1a 00       	r0 = r1 + Null;
   // get the read address and save it to the stack
   call $cbuffer.get_read_address_ex;
842016ce:	2c 4e       	call (m) $cbuffer.get_read_address_ex;
   I0 = r0;
842016d0:	10 0a       	I0 = r0 + Null;
   L0 = r2;
842016d2:	24 0b       	L0 = r2 + Null;
   push r3;
842016d4:	00 f0 35 cf 	push r3;
   pop B0;
842016d8:	00 f6 3a cf 	pop B0;


   // Advance the read pointer
   r7 = M[FP + 4*ADDR_PER_WORD];      // offset input
842016dc:	e9 f0 04 88 	r7 = M[FP + 16];
   r7 = r7 + r1;
842016e0:	19 0d       	r7 = r1 + r7;

   r3 = 0x3;
842016e2:	c5 20       	r3 = Null + 3;
   r1 = r7 AND r3;                    // get the new offset
842016e4:	5f f9 03 c8 	r1 = r7 AND r3;

   r7 = r7 AND 0xFFFFFFFC;            // remove the offset from the octets
842016e8:	99 ff fc 1f 	r7 = r7 AND 0xfffffffc;
   M3 = r7;
842016ec:	4b 0b       	M3 = r7 + Null;
   r0 = M[I0, M3];                    // advancing the read pointer.
842016ee:	23 f0 20 c0 	Null = Null + Null, r0 = M[I0,M3];

   r10 =  M[FP + 3*ADDR_PER_WORD];    // copy amount
842016f2:	ec f0 03 88 	r10 = M[FP + 12];
   r0 = 0xFF;
842016f6:	02 f0 ff 40 	r0 = Null + 255;
   do copy_unpack_from_offset_loop_32bit;
842016fa:	11 4c       	do (m) $M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop_32bit;
       r5 = r3 - r1;
842016fc:	ef 04       	r5 = r3 - r1;
       r5 = r5 LSHIFT 3;
842016fe:	bf 54       	r5 = r5 LSHIFT 3;
       r5 = -r5;                      // shift amount for source word
84201700:	c7 05       	r5 = Null - r5;

       r2 = M[I0, 0];
84201702:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
       r2 = r2 LSHIFT r5;             // shift octet left to LS position
84201706:	e4 17       	r2 = r2 LSHIFT r5;
       r1 = r1 + 1;
84201708:	5b 20       	r1 = r1 + 1;
       Null = ADDR_PER_WORD - r1;
8420170a:	02 f3 50 c6 	Null = 4 - r1;
       if NZ jump continue_masking_from_offset;
8420170e:	04 62       	if NE jump (m) $M.unpack_cbuff_to_array_c_stubs.continue_masking_from_offset;
           r1 = 0;
84201710:	03 00       	r1 = Null + Null;
           r5 = M[I0, M1];
84201712:	71 f0 20 c0 	Null = Null + Null, r5 = M[I0,M1];

84201716 <$M.unpack_cbuff_to_array_c_stubs.continue_masking_from_offset>:

       continue_masking_from_offset:
       r2 = r2 AND r0;
84201716:	a4 10       	r2 = r2 AND r0;

       M[I4, M1] = r2;
84201718:	c1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r2;

8420171c <$M.unpack_cbuff_to_array_c_stubs.copy_unpack_from_offset_loop_32bit>:

   copy_unpack_from_offset_loop_32bit:

   // Restore index & length registers
   popm <I0, I4, L0, L4>;
8420171c:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
   popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
84201720:	2b f2 6d e0 	popm <FP, r0, r1, r2, r3, r5, r7, rLink>;
   rts;
84201724:	d8 4c       	rts;

84201726 <$cbuffer.get_read_address_ex>:
//     r1 octet offset
//     r2 size in addresses
//     r3 buffer start address
// trashed - none
$cbuffer.get_read_address_ex:
    r1 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
84201726:	53 89       	r1 = M[r0 + 20];
    Null = r1 AND $cbuffer.BUFFER_TYPE_MASK;
84201728:	18 c0       	Null = r1 AND 0x1;
    if Z jump its_a_sw_rd_ptr;
8420172a:	06 60       	if EQ jump (m) $M.cbuffer.get_read_address_ex.its_a_sw_rd_ptr;
        Null = r1 AND $cbuffer.READ_PTR_TYPE_MASK;
8420172c:	d8 c0       	Null = r1 AND 0x4;
    if Z jump its_a_sw_rd_ptr;
8420172e:	04 60       	if EQ jump (m) $M.cbuffer.get_read_address_ex.its_a_sw_rd_ptr;
        jump $mmu.get_read_address_local_buff_ex;
84201730:	7c ff cf f5 	jump (m) 0x2f880;
84201734:	d1 e2 

84201736 <$M.cbuffer.get_read_address_ex.its_a_sw_rd_ptr>:

    its_a_sw_rd_ptr:
    r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
84201736:	d5 88       	r3 = M[r0 + 12];
    BUFFER_GET_SIZE_IN_ADDRS_ASM(r2, r0);
84201738:	14 88       	r2 = M[r0 + 0];
    r0 = M[r0 + $cbuffer.READ_ADDR_FIELD];
8420173a:	52 88       	r0 = M[r0 + 4];
    r1 = r0 AND BUFFER_EX_OFFSET_MASK;
8420173c:	93 c0       	r1 = r0 AND 0x3;
    BUFFER_MASK_READ_ADDR(r0);
8420173e:	22 ff fc 1f 	r0 = r0 AND 0xfffffffc;
    rts;
84201742:	d8 4c       	rts;

84201744 <$_cbuffer_get_read_address_ex>:
//in r0 cbuffer address
//in r1 pointer to octet offset
//out r0 read address
//trashed r2, r3
$_cbuffer_get_read_address_ex:
    push rLink;
84201744:	00 f0 3d cf 	push rLink;
    push r1;
84201748:	00 f0 33 cf 	push r1;
    call $cbuffer.get_read_address_ex;
8420174c:	ed 4f       	call (m) $cbuffer.get_read_address_ex;
    pop r2;
8420174e:	00 f4 34 cf 	pop r2;
    M[r2] = r1;
84201752:	03 ef       	M[Null + r2] = r1;
    pop rLink;
84201754:	00 f4 3d cf 	pop rLink;
    rts;
84201758:	d8 4c       	rts;

8420175a <$cbuffer.get_write_address_ex>:
// out r1 write octet offset
// out r2 size in locations
// out r3 base address
// trashed B0
$cbuffer.get_write_address_ex:
    r1 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
8420175a:	53 89       	r1 = M[r0 + 20];
    Null = r1 AND $cbuffer.BUFFER_TYPE_MASK;
8420175c:	18 c0       	Null = r1 AND 0x1;
    if Z jump its_a_sw_wr_ptr;
8420175e:	06 60       	if EQ jump (m) $M.cbuffer.get_write_address_ex.its_a_sw_wr_ptr;
        // mmu only if it's not a SW pointer
        Null = r1 AND $cbuffer.WRITE_PTR_TYPE_MASK;
84201760:	58 c1       	Null = r1 AND 0x8;
    if Z jump its_a_sw_wr_ptr;
84201762:	04 60       	if EQ jump (m) $M.cbuffer.get_write_address_ex.its_a_sw_wr_ptr;
        // write address is an MMU buffer
        jump $mmu.get_write_address_local_buff_ex;
84201764:	7c ff cf f5 	jump (m) 0x2f8b0;
84201768:	cd e2 

8420176a <$M.cbuffer.get_write_address_ex.its_a_sw_wr_ptr>:
    its_a_sw_wr_ptr:
    r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
8420176a:	d5 88       	r3 = M[r0 + 12];
    BUFFER_GET_SIZE_IN_ADDRS_ASM(r2, r0);
8420176c:	14 88       	r2 = M[r0 + 0];
    r0 = M[r0 + $cbuffer.WRITE_ADDR_FIELD];
8420176e:	92 88       	r0 = M[r0 + 8];
    r1 = r0 AND BUFFER_EX_OFFSET_MASK;
84201770:	93 c0       	r1 = r0 AND 0x3;
    if Z rts;
84201772:	00 fd c0 cd 	if EQ rts;
        BUFFER_MASK_WRITE_ADDR(r0);     // returns word aligned no offset
84201776:	22 ff fc 1f 	r0 = r0 AND 0xfffffffc;
        pushm <I0, L0>;
8420177a:	00 f1 41 e4 	pushm <I0, L0>;
        I0 = r0;
8420177e:	10 0a       	I0 = r0 + Null;
        L0 = r2;
84201780:	24 0b       	L0 = r2 + Null;
        push r3;
84201782:	00 f0 35 cf 	push r3;
        pop B0;
84201786:	00 f6 3a cf 	pop B0;
        r0 = M[I0, -ADDR_PER_WORD];
8420178a:	23 f0 30 c0 	Null = Null + Null, r0 = M[I0,-4];
        r0 = I0;                        // go back one word
8420178e:	82 08       	r0 = I0 + Null;
        popm <I0, L0>;
84201790:	00 f1 61 e4 	popm <I0, L0>;
        rts;
84201794:	d8 4c       	rts;

84201796 <$_cbuffer_get_write_address_ex>:
//in r0 cbuffer address
//in r1 pointer to octet offset
//out r0 true write address
//trashed r2, r3, B0
$_cbuffer_get_write_address_ex:
    push rLink;
84201796:	00 f0 3d cf 	push rLink;
    push r1;
8420179a:	00 f0 33 cf 	push r1;
    call $cbuffer.get_write_address_ex;
8420179e:	de 4f       	call (m) $cbuffer.get_write_address_ex;
    pop r2;
842017a0:	00 f4 34 cf 	pop r2;
    M[r2] = r1;
842017a4:	03 ef       	M[Null + r2] = r1;
    pop rLink;
842017a6:	00 f4 3d cf 	pop rLink;
    rts;
842017aa:	d8 4c       	rts;

842017ac <$_cbuffer_calc_amount_data_ex>:
//only supports 16-bit unpacked/32-bit packed modes
.MODULE $M.cbuffer.calc_amount_data_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.calc_amount_data_ex:
$_cbuffer_calc_amount_data_ex:
    pushm <r4, r5, r6, rLink>;
842017ac:	b3 1c       	pushm <r4, r5, r6, rLink>;

    BUFFER_GET_USABLE_OCTETS(r6, r0);
842017ae:	14 1c       	pushm <r0, r1, r2, r3>;
842017b0:	82 00       	r0 = Null + r0;
842017b2:	fe ff 35 e8 	call (m) $_cbuffer_get_usable_octets;
842017b6:	10 09       	r6 = r0 + Null;
842017b8:	14 48       	popm <r0, r1, r2, r3>;
    Null = r6 - ADDR_PER_WORD;         // usable_octets
842017ba:	80 f0 04 24 	Null = r6 - 4;
    if Z r6 = 0;// this function relies on 0 when usable octets is 4. Diff between stre rom and stre dev
842017be:	00 f0 08 c0 	if EQ r6 = Null + Null;

    push r0;
842017c2:	00 f0 32 cf 	push r0;
    call $cbuffer.get_write_address_ex;
842017c6:	ca 4f       	call (m) $cbuffer.get_write_address_ex;
    r4 = r0;
842017c8:	16 00       	r4 = r0 + Null;
    r5 = r1;
842017ca:	1f 00       	r5 = r1 + Null;
    pop r0;
842017cc:	00 f4 32 cf 	pop r0;
    call $cbuffer.get_read_address_ex;
842017d0:	ab 4f       	call (m) $cbuffer.get_read_address_ex;
    // side-effect returns r2 = buffer_size
    r3 = r4 - r0;       // data = wrp - rdp
842017d2:	b5 04       	r3 = r4 - r0;
    if NEG r3 = r3 + r2;
842017d4:	44 f5 05 c0 	if NEG r3 = r3 + r2;

    r4 = -1;
842017d8:	46 24       	r4 = Null - 1;
    Null = r6;
842017da:	40 08       	Null = r6 + Null;
    if Z jump check_if_rd_eq_wr;
842017dc:	02 60       	if EQ jump (m) $M.cbuffer.calc_amount_data_ex.check_if_rd_eq_wr;
        r3 = r3 LSHIFT r4;
842017de:	ad 17       	r3 = r3 LSHIFT r4;

842017e0 <$M.cbuffer.calc_amount_data_ex.check_if_rd_eq_wr>:

    check_if_rd_eq_wr:
    Null = r3;
842017e0:	28 00       	Null = r3 + Null;
    if Z jump rd_equals_wr;
842017e2:	04 60       	if EQ jump (m) $M.cbuffer.calc_amount_data_ex.rd_equals_wr;
        r0 = r3 - r1;   // subtract read octets
842017e4:	ea 04       	r0 = r3 - r1;
        r0 = r0 + r5;   // add written octets
842017e6:	ba 00       	r0 = r5 + r0;
        jump end;
842017e8:	08 6e       	jump (m) $M.cbuffer.calc_amount_data_ex.end;

842017ea <$M.cbuffer.calc_amount_data_ex.rd_equals_wr>:
    rd_equals_wr:
    r0 = r5 - r1;
842017ea:	fa 04       	r0 = r5 - r1;
    if POS jump end;
842017ec:	05 f0 8d e0 	if POS jump (m) $M.cbuffer.calc_amount_data_ex.end;
        // This is expected only if the buffer has an MMU write/read handle
        // For normal software buffers there will always be a gap of at least 2 octets.
        // This is because how much we allow to write into the buffer is completely
        //  under the control of SW running on the DSP.
        // For MMU buffers written to or read by other sub-systems this gap can be just 1 octet.
        Null = r6;
842017f0:	40 08       	Null = r6 + Null;
        if Z jump subtract_mmu_gap;
842017f2:	02 60       	if EQ jump (m) $M.cbuffer.calc_amount_data_ex.subtract_mmu_gap;
            r2 = r2 LSHIFT r4;  // divide by ADDR_PER_WORD - transform in usable_octets size
842017f4:	a4 17       	r2 = r2 LSHIFT r4;

842017f6 <$M.cbuffer.calc_amount_data_ex.subtract_mmu_gap>:
        subtract_mmu_gap:
        r0 = r2 + r4;
842017f6:	a2 01       	r0 = r2 + r4;

842017f8 <$M.cbuffer.calc_amount_data_ex.end>:
    end:
    popm <r4, r5, r6, rLink>;
842017f8:	b3 48       	popm <r4, r5, r6, rLink>;
    rts;
842017fa:	d8 4c       	rts;

842017fc <$_cbuffer_calc_amount_space_ex>:
// only supports 16-bit unpacked/32-bit packed modes
.MODULE $M.cbuffer.calc_amount_space_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.calc_amount_space_ex:
$_cbuffer_calc_amount_space_ex:
    pushm <r4, r5, r6, rLink>;
842017fc:	b3 1c       	pushm <r4, r5, r6, rLink>;

    BUFFER_GET_USABLE_OCTETS(r6, r0);
842017fe:	14 1c       	pushm <r0, r1, r2, r3>;
84201800:	82 00       	r0 = Null + r0;
84201802:	fe ff 25 e6 	call (m) $_cbuffer_get_usable_octets;
84201806:	10 09       	r6 = r0 + Null;
84201808:	14 48       	popm <r0, r1, r2, r3>;
    Null = r6 - ADDR_PER_WORD;         // usable_octets
8420180a:	80 f0 04 24 	Null = r6 - 4;
    if Z r6 = 0;
8420180e:	00 f0 08 c0 	if EQ r6 = Null + Null;

    push r0;
84201812:	00 f0 32 cf 	push r0;
    call $cbuffer.get_write_address_ex;
84201816:	a2 4f       	call (m) $cbuffer.get_write_address_ex;
    r4 = r0;
84201818:	16 00       	r4 = r0 + Null;
    r5 = r1;
8420181a:	1f 00       	r5 = r1 + Null;

    // check if the buffer is part of an in-place chain.
    pop r0;
8420181c:	00 f4 32 cf 	pop r0;
    r1 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
84201820:	53 89       	r1 = M[r0 + 20];
    Null = r1 AND $cbuffer.IN_PLACE_MASK;
84201822:	d8 c6       	Null = r1 AND 0x10000;
    if Z jump get_rd_addr;
84201824:	04 60       	if EQ jump (m) $M.cbuffer.calc_amount_space_ex.get_rd_addr;
        // its_in_place
        r2 = M[r0 + $cbuffer.AUX_ADDR_FIELD];
84201826:	14 89       	r2 = M[r0 + 16];
        if NZ r0 = r2;  // use the rdp of the head of the in-place chain
84201828:	01 f4 02 c0 	if NE r0 = r2 + Null;

8420182c <$M.cbuffer.calc_amount_space_ex.get_rd_addr>:
    get_rd_addr:
    call $cbuffer.get_read_address_ex;
8420182c:	7d 4f       	call (m) $cbuffer.get_read_address_ex;
    // side-effect, the asm API returns r2 = buffer_size
    r0 = r0 - r4;               // space = rdp - wrp
8420182e:	92 05       	r0 = r0 - r4;
    if Z jump rd_equals_wr;
84201830:	09 60       	if EQ jump (m) $M.cbuffer.calc_amount_space_ex.rd_equals_wr;
        if NEG r0 = r0 + r2;
84201832:	44 f2 02 c0 	if NEG r0 = r0 + r2;

        Null = r6;
84201836:	40 08       	Null = r6 + Null;
        if Z jump account_for_offsets;
84201838:	02 60       	if EQ jump (m) $M.cbuffer.calc_amount_space_ex.account_for_offsets;
            r0 = r0 LSHIFT -1;
8420183a:	12 50       	r0 = r0 LSHIFT -1;

8420183c <$M.cbuffer.calc_amount_space_ex.account_for_offsets>:
        account_for_offsets:
        r0 = r0 + r1;           // add read octets
8420183c:	9a 00       	r0 = r1 + r0;
        r0 = r0 - r5;           // subtract written octets
8420183e:	d2 05       	r0 = r0 - r5;
        jump end;
84201840:	08 6e       	jump (m) $M.cbuffer.calc_amount_space_ex.end;

84201842 <$M.cbuffer.calc_amount_space_ex.rd_equals_wr>:

    rd_equals_wr:
        r0 = r1 - r5;
84201842:	da 05       	r0 = r1 - r5;
        if GT r0 = -1;          /* Buffer_empty:
84201844:	3c f0 42 ce 	if GT r0 = Null - 1;
            2 octets.
            This is because how much we allow to write into the buffer is
            completely under the control of SW running on the DSP.
            For MMU buffers written to or read by hardware this gap can be
            just 1 octet. */
        Null = r6;
84201848:	40 08       	Null = r6 + Null;
        if Z jump add_octets;
8420184a:	02 60       	if EQ jump (m) $M.cbuffer.calc_amount_space_ex.add_octets;
            r2 = r2 LSHIFT -1;
8420184c:	24 50       	r2 = r2 LSHIFT -1;

8420184e <$M.cbuffer.calc_amount_space_ex.add_octets>:
        add_octets:
        r0 = r0 + r2;
8420184e:	a2 00       	r0 = r2 + r0;

84201850 <$M.cbuffer.calc_amount_space_ex.end>:

    end:
    Null = r6;
84201850:	40 08       	Null = r6 + Null;
    if Z r6 = ADDR_PER_WORD;
84201852:	b0 f0 48 ce 	if EQ r6 = Null + 4;
    // space in octets -2/4, clipped to zero
    r0 = r0 - r6;
84201856:	00 f8 32 c2 	r0 = r0 - r6;
    if NEG r0 = 0;
8420185a:	04 f0 02 c0 	if NEG r0 = Null + Null;
    // it is possible that at this point r0 is zero. See note
    // in cbuffer.calc_amount_data_ex. Therefore we need to clip
    // the return value to zero so we don't return a negative value, ie: -1.


    popm <r4, r5, r6, rLink>;
8420185e:	b3 48       	popm <r4, r5, r6, rLink>;
    rts;
84201860:	d8 4c       	rts;

84201862 <$_cbuffer_set_read_address_ex>:
//trashed r3, (r10 if mmu buffer)
.MODULE $M.cbuffer.set_read_address_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.set_read_address_ex:
$_cbuffer_set_read_address_ex:
    r3 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
84201862:	55 89       	r3 = M[r0 + 20];
    Null = r3 AND $cbuffer.BUFFER_TYPE_MASK;
84201864:	28 c0       	Null = r3 AND 0x1;
    if Z jump its_a_sw_wr_ptr;
84201866:	09 60       	if EQ jump (m) $M.cbuffer.set_read_address_ex.its_a_sw_wr_ptr;
        Null = r3 AND $cbuffer.READ_PTR_TYPE_MASK;
84201868:	e8 c0       	Null = r3 AND 0x4;
        if Z jump its_a_sw_wr_ptr;
8420186a:	07 60       	if EQ jump (m) $M.cbuffer.set_read_address_ex.its_a_sw_wr_ptr;
            r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
8420186c:	d5 88       	r3 = M[r0 + 12];
            r1 = r1 - r3;
8420186e:	5b 05       	r1 = r1 - r3;
            r0 = M[r0 + $cbuffer.READ_ADDR_FIELD];
84201870:	52 88       	r0 = M[r0 + 4];
            jump $mmu.set_byte_offset_from_address_ex;
84201872:	7c ff cf f5 	jump (m) 0x2f8e0;
84201876:	ef e0 

84201878 <$M.cbuffer.set_read_address_ex.its_a_sw_wr_ptr>:

    its_a_sw_wr_ptr:
    r1 = r1 OR r2;
84201878:	1b 13       	r1 = r1 OR r2;
    M[r0 + $cbuffer.READ_ADDR_FIELD] = r1;
8420187a:	53 8e       	M[r0 + 4] = r1;
    rts;
8420187c:	d8 4c       	rts;

8420187e <$_cbuffer_set_write_address_ex>:
//trashed r3, B0, (r10 if mmu buffer)
.MODULE $M.cbuffer.set_write_address_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.set_write_address_ex:
$_cbuffer_set_write_address_ex:
    r3 = M[r0 + $cbuffer.DESCRIPTOR_FIELD];
8420187e:	55 89       	r3 = M[r0 + 20];
    Null = r3 AND $cbuffer.BUFFER_TYPE_MASK;
84201880:	28 c0       	Null = r3 AND 0x1;
    if Z jump its_a_sw_wr_ptr;
84201882:	09 60       	if EQ jump (m) $M.cbuffer.set_write_address_ex.its_a_sw_wr_ptr;
        Null = r3 AND $cbuffer.WRITE_PTR_TYPE_MASK;
84201884:	68 c1       	Null = r3 AND 0x8;
        if Z jump its_a_sw_wr_ptr;
84201886:	07 60       	if EQ jump (m) $M.cbuffer.set_write_address_ex.its_a_sw_wr_ptr;
            r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
84201888:	d5 88       	r3 = M[r0 + 12];
            r1 = r1 - r3;
8420188a:	5b 05       	r1 = r1 - r3;
            r0 = M[r0 + $cbuffer.WRITE_ADDR_FIELD];
8420188c:	92 88       	r0 = M[r0 + 8];
            jump $mmu.set_byte_offset_from_address_ex;
8420188e:	7c ff cf f5 	jump (m) 0x2f8e0;
84201892:	d3 e0 

84201894 <$M.cbuffer.set_write_address_ex.its_a_sw_wr_ptr>:

    its_a_sw_wr_ptr:
    Null = r2 AND BUFFER_EX_OFFSET_MASK;
84201894:	a0 c0       	Null = r2 AND 0x3;
    if Z jump no_round_up;
84201896:	11 60       	if EQ jump (m) $M.cbuffer.set_write_address_ex.no_round_up;
        pushm <I0, L0>;
84201898:	00 f1 41 e4 	pushm <I0, L0>;
        I0 = r1;
8420189c:	18 0a       	I0 = r1 + Null;
        BUFFER_GET_SIZE_IN_ADDRS_ASM(L0, r0);
8420189e:	2c f8 00 88 	L0 = M[r0 + 0];
        r3 = M[r0 + $cbuffer.START_ADDR_FIELD];
842018a2:	d5 88       	r3 = M[r0 + 12];
        push r3;
842018a4:	00 f0 35 cf 	push r3;
        pop B0;
842018a8:	00 f6 3a cf 	pop B0;
        r3 = M[I0, ADDR_PER_WORD];
842018ac:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];
        r1 = I0;
842018b0:	83 08       	r1 = I0 + Null;
        r1 = r1 OR r2;
842018b2:	1b 13       	r1 = r1 OR r2;
        popm <I0, L0>;
842018b4:	00 f1 61 e4 	popm <I0, L0>;

842018b8 <$M.cbuffer.set_write_address_ex.no_round_up>:
    no_round_up:
    M[r0 + $cbuffer.WRITE_ADDR_FIELD] = r1;
842018b8:	93 8e       	M[r0 + 8] = r1;
    rts;
842018ba:	d8 4c       	rts;

842018bc <$_cbuffer_advance_write_ptr_ex>:
//only supports 16-bit unpacked/32-bit packed modes
.MODULE $M.cbuffer_advance_write_ptr_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.advance_write_ptr_ex:
$_cbuffer_advance_write_ptr_ex:
    push rLink;
842018bc:	00 f0 3d cf 	push rLink;
    push M0;
842018c0:	00 f1 38 cf 	push M0;
    push r4;
842018c4:	00 f0 36 cf 	push r4;
    pushm <I0, L0>;
842018c8:	00 f1 41 e4 	pushm <I0, L0>;
    pushm <r0, r1>;
842018cc:	12 1c       	pushm <r0, r1>;

    BUFFER_GET_USABLE_OCTETS(r4, r0);
842018ce:	14 1c       	pushm <r0, r1, r2, r3>;
842018d0:	82 00       	r0 = Null + r0;
842018d2:	fd ff 35 ef 	call (m) $_cbuffer_get_usable_octets;
842018d6:	16 00       	r4 = r0 + Null;
842018d8:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4;         // usable_octets
842018da:	30 00       	Null = r4 + Null;
    if Z r4 = ADDR_PER_WORD;
842018dc:	b0 f0 46 ce 	if EQ r4 = Null + 4;

    call $cbuffer.get_write_address_ex;
842018e0:	3d 4f       	call (m) $cbuffer.get_write_address_ex;
    L0 = r2;
842018e2:	24 0b       	L0 = r2 + Null;

    push r3;
842018e4:	00 f0 35 cf 	push r3;
    pop B0;
842018e8:	00 f6 3a cf 	pop B0;
    I0 = r0;
842018ec:	10 0a       	I0 = r0 + Null;
    r2 = r1;            // existing octet offset
842018ee:	1c 00       	r2 = r1 + Null;
    popm <r0, r1>;      // get cbuffer address and octets to advance by
842018f0:	12 48       	popm <r0, r1>;
    r1 = r1 + r2;       // add existing octet offset and octets to advance by
842018f2:	e3 00       	r1 = r2 + r1;
    r3 = -1;
842018f4:	45 24       	r3 = Null - 1;
    r2 = r1 LSHIFT r3;  // get samples (for 16-bit unpacked)
842018f6:	5c 17       	r2 = r1 LSHIFT r3;
    Null = ADDR_PER_WORD - r4;
842018f8:	02 f6 50 c6 	Null = 4 - r4;
    if NZ jump prepare_offset_index;
842018fc:	02 62       	if NE jump (m) $M.cbuffer_advance_write_ptr_ex.prepare_offset_index;
        r2 = r2 LSHIFT r3;      // further divide by 2 for 32-bit packed
842018fe:	64 17       	r2 = r2 LSHIFT r3;

84201900 <$M.cbuffer_advance_write_ptr_ex.prepare_offset_index>:

    prepare_offset_index:
    r2 = r2 ASHIFT LOG2_ADDR_PER_WORD;  // *4 to restore the initial write ptr without offset
84201900:	64 5c       	r2 = r2 ASHIFT 2;
    M0 = r2;
84201902:	20 0b       	M0 = r2 + Null;
    r4 = r4 + r3;    // mask for offset: max 1 for 16-bit and max 3 for 32-bit
84201904:	ae 01       	r4 = r3 + r4;

    r2 = r1 AND r4; // get the offset
84201906:	9c 11       	r2 = r1 AND r4;
    r1 = M[I0, M0];
84201908:	30 f0 20 c0 	Null = Null + Null, r1 = M[I0,M0];

    r1 = I0;
8420190c:	83 08       	r1 = I0 + Null;
    call $cbuffer.set_write_address_ex;
8420190e:	b8 4f       	call (m) $_cbuffer_set_write_address_ex;
    popm <I0, L0>;
84201910:	00 f1 61 e4 	popm <I0, L0>;
    pop r4;
84201914:	00 f4 36 cf 	pop r4;
    pop M0;
84201918:	00 f5 38 cf 	pop M0;
    pop rLink;
8420191c:	00 f4 3d cf 	pop rLink;
    rts;
84201920:	d8 4c       	rts;

84201922 <$_cbuffer_advance_read_ptr_ex>:
//only supports 16-bit unpacked/32-bit packed modes
.MODULE $M.cbuffer_advance_read_ptr_ex;
   .CODESEGMENT BUFFER_PM;
$cbuffer.advance_read_ptr_ex:
$_cbuffer_advance_read_ptr_ex:
    push rLink;
84201922:	00 f0 3d cf 	push rLink;
    push r4;
84201926:	00 f0 36 cf 	push r4;
    push M0;
8420192a:	00 f1 38 cf 	push M0;
    pushm <I0, L0>;
8420192e:	00 f1 41 e4 	pushm <I0, L0>;
    pushm <r0, r1>;
84201932:	12 1c       	pushm <r0, r1>;

    BUFFER_GET_USABLE_OCTETS(r4, r0);
84201934:	14 1c       	pushm <r0, r1, r2, r3>;
84201936:	82 00       	r0 = Null + r0;
84201938:	fd ff 2f ec 	call (m) $_cbuffer_get_usable_octets;
8420193c:	16 00       	r4 = r0 + Null;
8420193e:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4;         // usable_octets
84201940:	30 00       	Null = r4 + Null;
    if Z r4 = ADDR_PER_WORD;
84201942:	b0 f0 46 ce 	if EQ r4 = Null + 4;

    call $cbuffer.get_read_address_ex;
84201946:	fe ff 21 ef 	call (m) $cbuffer.get_read_address_ex;
    L0 = r2;
8420194a:	24 0b       	L0 = r2 + Null;

    push r3;
8420194c:	00 f0 35 cf 	push r3;
    pop B0;
84201950:	00 f6 3a cf 	pop B0;
    I0 = r0;
84201954:	10 0a       	I0 = r0 + Null;
    r2 = r1;            // existing octet offset
84201956:	1c 00       	r2 = r1 + Null;
    popm <r0, r1>;      // get cbuffer address and octets to advance by
84201958:	12 48       	popm <r0, r1>;
    r1 = r1 + r2;       // add existing octet offset and octets to advance by
8420195a:	e3 00       	r1 = r2 + r1;
    r3 = -1;
8420195c:	45 24       	r3 = Null - 1;
    r2 = r4 + r3;
8420195e:	74 01       	r2 = r4 + r3;
    r2 = r1 AND r2;
84201960:	1c 11       	r2 = r1 AND r2;

    r1 = r1 LSHIFT r3;
84201962:	5b 17       	r1 = r1 LSHIFT r3;
    Null = ADDR_PER_WORD - r4;
84201964:	02 f6 50 c6 	Null = 4 - r4;
    if NZ jump set_mod_reg;
84201968:	02 62       	if NE jump (m) $M.cbuffer_advance_read_ptr_ex.set_mod_reg;
        r1 = r1 LSHIFT r3;
8420196a:	5b 17       	r1 = r1 LSHIFT r3;

8420196c <$M.cbuffer_advance_read_ptr_ex.set_mod_reg>:

    set_mod_reg:
    r1 = r1 ASHIFT LOG2_ADDR_PER_WORD;
8420196c:	5b 5c       	r1 = r1 ASHIFT 2;
    M0 = r1;
8420196e:	18 0b       	M0 = r1 + Null;
    r1 = M[I0, M0];
84201970:	30 f0 20 c0 	Null = Null + Null, r1 = M[I0,M0];
    r1 = I0;
84201974:	83 08       	r1 = I0 + Null;
    call $cbuffer.set_read_address_ex;
84201976:	76 4f       	call (m) $_cbuffer_set_read_address_ex;
    popm <I0, L0>;
84201978:	00 f1 61 e4 	popm <I0, L0>;
    pop M0;
8420197c:	00 f5 38 cf 	pop M0;
    pop r4;
84201980:	00 f4 36 cf 	pop r4;
    pop rLink;
84201984:	00 f4 3d cf 	pop rLink;
    rts;
84201988:	d8 4c       	rts;

8420198a <$_cbuffer_copy_aligned_16bit_be_zero_shift_ex>:
.MODULE $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_aligned_16bit_be_zero_shift_ex:
$_cbuffer_copy_aligned_16bit_be_zero_shift_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r5, rLink>;
8420198a:	09 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, rLink>;
    pushm <I0, I4, L0, L4>;
8420198e:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201992:	fe ff 29 ee 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201996:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201998:	26 0b       	L4 = r2 + Null;
    push r3;
8420199a:	00 f0 35 cf 	push r3;
    pop B4;
8420199e:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
842019a2:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
842019a4:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
842019a6:	fe ff 21 ec 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
842019aa:	10 0a       	I0 = r0 + Null;
    L0 = r2;
842019ac:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
842019ae:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
842019b0:	09 62       	if NE jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
842019b2:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
842019b4:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
842019b6:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
842019b8:	82 4f       	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
842019ba:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
842019bc:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
842019be:	b2 4f       	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
842019c0:	32 6e       	jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.cp_pop_and_exit;

842019c2 <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
842019c2:	00 f0 35 cf 	push r3;
    pop B0;
842019c6:	00 f6 3a cf 	pop B0;

    r5 =  M[FP + 3*ADDR_PER_WORD];               // copy amount
842019ca:	1f d8       	r5 = M[FP + 12];
    Null = r1;                                   // r1 is the octet offset
842019cc:	18 00       	Null = r1 + Null;

    if Z jump no_offset;
842019ce:	0c 60       	if EQ jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.no_offset;
        // read the second part of the word, combine it with the first one.
        r1 = M[I0, ADDR_PER_WORD];
842019d0:	31 f0 30 c0 	Null = Null + Null, r1 = M[I0,4];
        r1 = r1 AND 0xff;                        // The new octet is the LSB.
842019d4:	9b c3       	r1 = r1 AND 0xff;
        r2 = M[I4, 0];                           // Read the msb
842019d6:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND 0xff00;                      // Mask the lsb
842019da:	44 f7 00 1f 	r2 = r2 AND 0xff00;
        r1 = r1 + r2;                            // combine it
842019de:	e3 00       	r1 = r2 + r1;
        M[I4, ADDR_PER_WORD] = r1;               // write it to the buffer
842019e0:	b1 f0 30 d0 	Null = Null + Null, M[I4,4] = r1;
        r5 = r5 - 1;                             // one octet already written, decrement
842019e4:	7f 24       	r5 = r5 - 1;

842019e6 <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.no_offset>:
                                                 // the copy amount
    no_offset:
    r10 = r5 LSHIFT -1;                          // convert the copy amount to words
842019e6:	7f f7 dc d8 	r10 = r5 LSHIFT -1;
    if Z jump copy_aligned_write_last_octet;     // could be that only one octet we need to copy.
842019ea:	0a 60       	if EQ jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_write_last_octet;
        r10 = r10 - 1;                    // decrement the amount due to the initial read and last write
842019ec:	cc f0 01 24 	r10 = r10 - 1;
        r1 = M[I0,ADDR_PER_WORD];         // initial read
842019f0:	31 f0 30 c0 	Null = Null + Null, r1 = M[I0,4];
        do copy_aligned_loop;
842019f4:	03 4c       	do (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_loop;
            r1 = M[I0,ADDR_PER_WORD],
             M[I4,ADDR_PER_WORD] = r1;    // read and write
842019f6:	b1 f1 33 d0 	Null = Null + Null, r1 = M[I0,4], M[I4,4] = r1;

842019fa <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_loop>:
        copy_aligned_loop:
        M[I4,ADDR_PER_WORD] = r1;         // last write
842019fa:	b1 f0 30 d0 	Null = Null + Null, M[I4,4] = r1;

842019fe <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_write_last_octet>:

    copy_aligned_write_last_octet:

    Null = r5 AND 0x1;
842019fe:	38 c0       	Null = r5 AND 0x1;
    if Z jump copy_aligned_done;
84201a00:	0b 60       	if EQ jump (m) $M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_done;
        //read last word.
        r1 = M[I0, 0];
84201a02:	30 f0 30 c0 	Null = Null + Null, r1 = M[I0,0];
        r1 = r1 AND 0xff00;
84201a06:	33 f7 00 1f 	r1 = r1 AND 0xff00;
        r2 = M[I4,0];
84201a0a:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND 0xff;
84201a0e:	a4 c3       	r2 = r2 AND 0xff;
        r1 = r1 + r2;
84201a10:	e3 00       	r1 = r2 + r1;
        M[I4,0] = r1;
84201a12:	b0 f0 30 d0 	Null = Null + Null, M[I4,0] = r1;

84201a16 <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.copy_aligned_done>:

    copy_aligned_done:
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201a16:	0a d8       	r0 = M[FP + 4];
    r1 = I4;
84201a18:	a3 08       	r1 = I4 + Null;
    r2 = r5 AND 0x1;
84201a1a:	3c c0       	r2 = r5 AND 0x1;
    call $cbuffer.set_write_address_ex;
84201a1c:	31 4f       	call (m) $_cbuffer_set_write_address_ex;

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201a1e:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201a20:	83 08       	r1 = I0 + Null;
    call $cbuffer.set_read_address_ex;
84201a22:	20 4f       	call (m) $_cbuffer_set_read_address_ex;

84201a24 <$M.cbuffer_copy_aligned_16bit_be_zero_shift_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201a24:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r5, rLink>;
84201a28:	09 f2 6d e0 	popm <FP, r0, r1, r2, r5, rLink>;
    rts;
84201a2c:	d8 4c       	rts;

84201a2e <$_cbuffer_copy_unaligned_16bit_be_zero_shift_ex>:
.MODULE $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_unaligned_16bit_be_zero_shift_ex:
$_cbuffer_copy_unaligned_16bit_be_zero_shift_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r5, r6, r8, rLink>;
84201a2e:	59 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, r6, r8, rLink>;
    pushm <I0, I4, L0, L4>;
84201a32:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201a36:	fe ff 25 e9 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201a3a:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201a3c:	26 0b       	L4 = r2 + Null;
    r6 = r1;        // save write octet offset
84201a3e:	18 09       	r6 = r1 + Null;
    push r3;
84201a40:	00 f0 35 cf 	push r3;
    pop B4;
84201a44:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201a48:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201a4a:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201a4c:	fe ff 3b e6 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201a50:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201a52:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201a54:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201a56:	09 62       	if NE jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201a58:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201a5a:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201a5c:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201a5e:	2f 4f       	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201a60:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201a62:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201a64:	5f 4f       	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201a66:	55 6e       	jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_pop_and_exit;

84201a68 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201a68:	00 f0 35 cf 	push r3;
    pop B0;
84201a6c:	00 f6 3a cf 	pop B0;

    r3 = 0xFF;                         // mask for keeping LSByte
84201a70:	05 f0 ff 40 	r3 = Null + 255;
    r8 = 8;                            // shift value for faster access
84201a74:	42 71       	r8 = Null + 8;
    push r1;                           // save read octet offset
84201a76:	00 f0 33 cf 	push r1;
    r5 =  M[FP + 3*ADDR_PER_WORD];     // copy amount
84201a7a:	1f d8       	r5 = M[FP + 12];
    Null = r1;                         // read octet offset
84201a7c:	18 00       	Null = r1 + Null;
    if Z jump check_wr_offset;
84201a7e:	12 60       	if EQ jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.check_wr_offset;
        // unaligned: rd offset
        Null = r6;                     // check write octet offset
84201a80:	40 08       	Null = r6 + Null;
        if NZ call $error;  // same_offset should be captured by the caller
84201a82:	f1 fd 58 f1 	if NE call (m) 0x2cb9c;
84201a86:	3b e8 
                            // TODO grace fail, return octets_copied and make the caller check
        // unaligned, different offsets, rd offset (no wr offset)
        r1 = M[I0, ADDR_PER_WORD];      // read word to be copied
84201a88:	31 f0 30 c0 	Null = Null + Null, r1 = M[I0,4];
        r1 = r1 AND r3;                 // LSByte only to be mixed
84201a8c:	5b 11       	r1 = r1 AND r3;
        r1 = r1 LSHIFT r8,               // on the MSByte position
         r0 = M[I0, ADDR_PER_WORD];      // read in advance next word to be copied
84201a8e:	21 fa f3 c8 	r1 = r1 LSHIFT r8, r0 = M[I0,4];
        r2 = r0 AND r3;                 // keep LSByte to be mixed to next word
84201a92:	54 11       	r2 = r0 AND r3;
        r0 = r0 LSHIFT -8;              // on the LSByte position
84201a94:	d2 51       	r0 = r0 LSHIFT -8;
        r1 = r1 OR r0;                  // mix it
84201a96:	9b 12       	r1 = r1 OR r0;
        r2 = r2 LSHIFT r8,              // value to be mixed next on the MSByte position
         M[I4, ADDR_PER_WORD] = r1,      // write a whole word back
         r0 = M[I0, ADDR_PER_WORD];      // read next word to be copied
84201a98:	21 f0 b1 fa 	r2 = r2 LSHIFT r8, r0 = M[I0,4], M[I4,4] = r1;
84201a9c:	f4 c8 
        r5 = r5 - 2;                    // two octets already written
84201a9e:	bf 24       	r5 = r5 - 2;
        // keep in mind src buffer (rdp) runs ahead one word
        jump copy_unaligned_loop;
84201aa0:	10 6e       	jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.copy_unaligned_loop;

84201aa2 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.check_wr_offset>:

    check_wr_offset:
        // no rd offset
        Null = r6;                           // write octet offset
84201aa2:	40 08       	Null = r6 + Null;
        if Z call $error;   // same_offset should be captured by the caller TODO
84201aa4:	f0 fd 58 f1 	if EQ call (m) 0x2cb9c;
84201aa8:	39 e7 
            // unaligned, different offsets, no rd but wr
            r1 = M[I0, ADDR_PER_WORD],       // read word to be copied
             r0 = M[I4, 0];                   // read what's currently written
84201aaa:	20 f1 33 d0 	Null = Null + Null, r1 = M[I0,4], r0 = M[I4,0];
            r2 = r1 AND r3;                  // keep LSByte to be mixed to next word
84201aae:	5c 11       	r2 = r1 AND r3;
            r0 = r0 AND 0xFF00;              // mask out the LSByte of what's there
84201ab0:	22 f7 00 1f 	r0 = r0 AND 0xff00;
            r1 = r1 LSHIFT -8;               // octet to be written on LSByte position
84201ab4:	db 51       	r1 = r1 LSHIFT -8;
            r1 = r1 OR r0;                   // mix it
84201ab6:	9b 12       	r1 = r1 OR r0;
            r2 = r2 LSHIFT r8,               // value to be mixed next on the MSByte position
             M[I4, ADDR_PER_WORD] = r1,       // write it back
             r0 = M[I0, ADDR_PER_WORD];       // read next word to be copied
84201ab8:	21 f0 b1 fa 	r2 = r2 LSHIFT r8, r0 = M[I0,4], M[I4,4] = r1;
84201abc:	f4 c8 
            r5 = r5 - 1;                     // one octet already written
84201abe:	7f 24       	r5 = r5 - 1;

84201ac0 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.copy_unaligned_loop>:

        copy_unaligned_loop:
        r10 = r5 LSHIFT -1;              // convert the copy amount to words
84201ac0:	7f f7 dc d8 	r10 = r5 LSHIFT -1;
        if Z jump write_last_octet;      // could be that only one octet we need to copy.
84201ac4:	09 60       	if EQ jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_unld_loop;

        // next octet to be mixed in r2 on MSByte position
        do cp_unld_loop;
84201ac6:	08 4c       	do (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_unld_loop;
            r1 = r0 AND r3;              // keep LSByte to be mixed to next word
84201ac8:	53 11       	r1 = r0 AND r3;
            r0 = r0 LSHIFT -8;           // octet to be written on LSByte position
84201aca:	d2 51       	r0 = r0 LSHIFT -8;
            r0 = r0 OR r2;               // mix with octet stored in previous iteration
84201acc:	12 13       	r0 = r0 OR r2;
            r2 = r1 LSHIFT r8;            // on the MSByte position
84201ace:	af f3 c4 c8 	r2 = r1 LSHIFT r8;
            M[I4, ADDR_PER_WORD] = r0,   // write a whole word back
             r0 = M[I0, ADDR_PER_WORD];  // read next word to be copied
84201ad2:	a1 f1 32 d0 	Null = Null + Null, r0 = M[I0,4], M[I4,4] = r0;

84201ad6 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_unld_loop>:
        cp_unld_loop:

    write_last_octet:
        r1 = M[I0, -ADDR_PER_WORD]; // adjust back src buffer incremented in the last loop
84201ad6:	33 f0 30 c0 	Null = Null + Null, r1 = M[I0,-4];

    Null = r5 AND 0x01;         // check if doloop has copied even number of octets
84201ada:	38 c0       	Null = r5 AND 0x1;
    if Z jump adj_src_ptr;
84201adc:	08 60       	if EQ jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.adj_src_ptr;
        r0 = M[I4, 0];          // read what's currently written
84201ade:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
        // mix with LSByte stored in last doloop iteration
        r0 = r0 AND r3;         // keep only LSByte of what's there
84201ae2:	52 11       	r0 = r0 AND r3;
        r0 = r0 OR r2;          // mix
84201ae4:	12 13       	r0 = r0 OR r2;
        M[I4,0] = r0;           // and write a whole word back
84201ae6:	a0 f0 30 d0 	Null = Null + Null, M[I4,0] = r0;
        jump upd_ptrs;
84201aea:	03 6e       	jump (m) $M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.upd_ptrs;

84201aec <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.adj_src_ptr>:

    adj_src_ptr:
        r1 = M[I0, -ADDR_PER_WORD];   // adjust back src buffer when rdp was running ahead
84201aec:	33 f0 30 c0 	Null = Null + Null, r1 = M[I0,-4];

84201af0 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.upd_ptrs>:

    upd_ptrs:
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201af0:	0a d8       	r0 = M[FP + 4];
    r1 = I4;
84201af2:	a3 08       	r1 = I4 + Null;
    r5 = M[FP + 3*ADDR_PER_WORD];                // copy amount
84201af4:	1f d8       	r5 = M[FP + 12];
    r2 = r5 XOR r6;     // new offset is a combination of old one and amt_copied
84201af6:	8f f7 84 c8 	r2 = r5 XOR r6;
    r2 = r2 AND 0x01;   // play safe, only lsb
84201afa:	24 c0       	r2 = r2 AND 0x1;
    call $cbuffer.set_write_address_ex;
84201afc:	fe ff 23 ec 	call (m) $_cbuffer_set_write_address_ex;
    // r2 is not trashed

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201b00:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201b02:	83 08       	r1 = I0 + Null;
    pop r2;             // restore read offset
84201b04:	00 f4 34 cf 	pop r2;
    r2 = r2 XOR r5;     // new offset is a combination of old one and amt_copied
84201b08:	e4 15       	r2 = r2 XOR r5;
    r2 = r2 AND 0x01;   // play safe, only lsb
84201b0a:	24 c0       	r2 = r2 AND 0x1;
    call $cbuffer.set_read_address_ex;
84201b0c:	fe ff 37 ea 	call (m) $_cbuffer_set_read_address_ex;

84201b10 <$M.cbuffer_copy_unaligned_16bit_be_zero_shift_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201b10:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r5, r6, r8, rLink>;
84201b14:	59 f2 6d e0 	popm <FP, r0, r1, r2, r5, r6, r8, rLink>;
    rts;
84201b18:	d8 4c       	rts;

84201b1a <$_cbuffer_copy_aligned_32bit_be_zero_shift_ex>:
.MODULE $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_aligned_32bit_be_zero_shift_ex:
$_cbuffer_copy_aligned_32bit_be_zero_shift_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r5, r6, r7, r8, r9, rLink>;
84201b1a:	f9 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r5, r6, r7, r8, r9, rLink>;
    pushm <I0, I4, L0, L4>;
84201b1e:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    BUFFER_GET_USABLE_OCTETS(r8, r0);
84201b22:	14 1c       	pushm <r0, r1, r2, r3>;
84201b24:	82 00       	r0 = Null + r0;
84201b26:	fc ff 21 ed 	call (m) $_cbuffer_get_usable_octets;
84201b2a:	12 09       	r8 = r0 + Null;
84201b2c:	14 48       	popm <r0, r1, r2, r3>;
    Null = r8 - ADDR_PER_WORD;
84201b2e:	a0 f0 04 24 	Null = r8 - 4;
    if NZ call $error;      // usable octets must be 4
84201b32:	f1 fd 58 f1 	if NE call (m) 0x2cb9c;
84201b36:	2b e3 

    // r8 = ADDR_PER_WORD;     // usable_octets
    r9 = 0xFFFFFFFF;
84201b38:	0b f0 01 24 	r9 = Null - 1;

    call $cbuffer.get_write_address_ex;
84201b3c:	fe ff 3f e0 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201b40:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201b42:	26 0b       	L4 = r2 + Null;
    push r3;
84201b44:	00 f0 35 cf 	push r3;
    pop B4;
84201b48:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201b4c:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201b4e:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201b50:	fd ff 37 ee 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201b54:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201b56:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201b58:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201b5a:	0b 62       	if NE jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201b5c:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201b5e:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201b60:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201b62:	fe ff 3b ea 	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201b66:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201b68:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201b6a:	fe ff 39 ed 	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201b6e:	7b 6e       	jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.cp_pop_and_exit;

84201b70 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201b70:	00 f0 35 cf 	push r3;
    pop B0;
84201b74:	00 f6 3a cf 	pop B0;

    r5 =  M[FP + 3*ADDR_PER_WORD];               // copy amount
84201b78:	1f d8       	r5 = M[FP + 12];
    Null = r1;                                   // r1 is the octet offset
84201b7a:	18 00       	Null = r1 + Null;

    if Z jump no_offset;
84201b7c:	44 60       	if EQ jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.no_offset;
        r6 = r8 - r1;
84201b7e:	3f fa 08 c2 	r6 = r8 - r1;
        Null = r5 - r6;     // check if amount of data is smaller than the space in the current word
84201b82:	8f f7 00 c2 	Null = r5 - r6;
        if POS jump amount_data_greater;
84201b86:	05 f0 cd e0 	if POS jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.amount_data_greater;
            // less data to be copied than space
            r6 = r8 - r5;
84201b8a:	7f fa 08 c2 	r6 = r8 - r5;
            r6 = r6 LSHIFT 3;
84201b8e:	01 f8 d8 d8 	r6 = r6 LSHIFT 3;
            r6 = r9 LSHIFT r6;      // mask for source in the LSB
84201b92:	8f fb c8 c8 	r6 = r9 LSHIFT r6;

            r7 = r1 LSHIFT 3;
84201b96:	01 f3 d9 d8 	r7 = r1 LSHIFT 3;
            r7 = -r7;
84201b9a:	9f f0 09 c2 	r7 = Null - r7;
            r6 = r6 LSHIFT r7;      // mask source in the right position
84201b9e:	00 f9 f8 c8 	r6 = r6 LSHIFT r7;

            r2 = M[I0, 0];          // read the source word
84201ba2:	40 f0 30 c0 	Null = Null + Null, r2 = M[I0,0];
            r2 = r2 AND r6;
84201ba6:	00 f8 34 c8 	r2 = r2 AND r6;

            r3 = M[I4, 0];          // Read the dest
84201baa:	50 f0 30 d0 	Null = Null + Null, r3 = M[I4,0];
            r6 = r6 XOR r9;         // invert r6
84201bae:	00 fb b8 c8 	r6 = r6 XOR r9;
            r3 = r3 AND r6;         // zero only the bits that need to be copied
84201bb2:	00 f8 35 c8 	r3 = r3 AND r6;

            r2 = r3 + r2;
84201bb6:	2c 01       	r2 = r3 + r2;

            M[I4, 0] = r2;
84201bb8:	c0 f0 30 d0 	Null = Null + Null, M[I4,0] = r2;

            r7 = r1 + r5;
84201bbc:	7f f3 09 c0 	r7 = r1 + r5;
            Null = ADDR_PER_WORD - r7;
84201bc0:	02 f9 50 c6 	Null = 4 - r7;
            if NZ jump copy_aligned_done;
84201bc4:	47 62       	if NE jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_done;
                r7 = 0;
84201bc6:	01 09       	r7 = Null + Null;
                r3 = M[I4, ADDR_PER_WORD];
84201bc8:	51 f0 30 d0 	Null = Null + Null, r3 = M[I4,4];
                r3 = M[I0, ADDR_PER_WORD];
84201bcc:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];
                jump copy_aligned_done;
84201bd0:	41 6e       	jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_done;

84201bd2 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.amount_data_greater>:

        amount_data_greater:
        r5 = r5 - r6;               // decrement the copy amount
84201bd2:	00 f8 37 c2 	r5 = r5 - r6;
        r6 = r1 LSHIFT 3;
84201bd6:	01 f3 d8 d8 	r6 = r1 LSHIFT 3;
        r6 = -r6;
84201bda:	8f f0 08 c2 	r6 = Null - r6;
        r6 = r9 LSHIFT r6;          // mask for source
84201bde:	8f fb c8 c8 	r6 = r9 LSHIFT r6;

        r7 = r8 - r1;
84201be2:	3f fa 09 c2 	r7 = r8 - r1;
        r7 = r7 LSHIFT 3;
84201be6:	01 f9 d9 d8 	r7 = r7 LSHIFT 3;
        r7 = r9 LSHIFT r7;          // mask for destination
84201bea:	9f fb c9 c8 	r7 = r9 LSHIFT r7;

        // read the second part of the word, combine it with the first one.
        r2 = M[I0, ADDR_PER_WORD];
84201bee:	41 f0 30 c0 	Null = Null + Null, r2 = M[I0,4];
        r2 = r2 AND r6;                        // The new octets are in the LSBs.
84201bf2:	00 f8 34 c8 	r2 = r2 AND r6;

        r1 = M[I4, 0];                         // Read the msb
84201bf6:	30 f0 30 d0 	Null = Null + Null, r1 = M[I4,0];
        r1 = r1 AND r7;                        // Mask the lsb
84201bfa:	00 f9 33 c8 	r1 = r1 AND r7;
        r1 = r1 + r2;                          // combine it
84201bfe:	e3 00       	r1 = r2 + r1;
        M[I4, ADDR_PER_WORD] = r1;             // write it to the buffer
84201c00:	b1 f0 30 d0 	Null = Null + Null, M[I4,4] = r1;

84201c04 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.no_offset>:

    no_offset:
    r7 = r5 AND 0x3;
84201c04:	79 f0 03 00 	r7 = r5 AND 0x3;

    r10 = r5 LSHIFT -LOG2_ADDR_PER_WORD;         // convert the copy amount to words
84201c08:	7f f7 dc c8 	r10 = r5 LSHIFT -2;
    if Z jump copy_aligned_write_last_octet;     // maybe the copy amount is less than a word
84201c0c:	0a 60       	if EQ jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_write_last_octet;
        r10 = r10 - 1;                    // decrement the amount due to the initial read and last write
84201c0e:	cc f0 01 24 	r10 = r10 - 1;
        r1 = M[I0, ADDR_PER_WORD];         // initial read
84201c12:	31 f0 30 c0 	Null = Null + Null, r1 = M[I0,4];
        do copy_aligned_loop;
84201c16:	03 4c       	do (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_loop;
            r1 = M[I0, ADDR_PER_WORD],
             M[I4, ADDR_PER_WORD] = r1;    // read and write
84201c18:	b1 f1 33 d0 	Null = Null + Null, r1 = M[I0,4], M[I4,4] = r1;

84201c1c <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_loop>:
        copy_aligned_loop:
        M[I4, ADDR_PER_WORD] = r1;         // last write
84201c1c:	b1 f0 30 d0 	Null = Null + Null, M[I4,4] = r1;

84201c20 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_write_last_octet>:

    copy_aligned_write_last_octet:

    Null = r7;
84201c20:	48 08       	Null = r7 + Null;
    if Z jump copy_aligned_done;
84201c22:	18 60       	if EQ jump (m) $M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_done;
        r6 = r8 - r7;           // us_octets - amount_data left
84201c24:	9f fa 08 c2 	r6 = r8 - r7;
        r6 = r6 LSHIFT 3;
84201c28:	01 f8 d8 d8 	r6 = r6 LSHIFT 3;
        r6 = r9 LSHIFT r6;      // mask for source
84201c2c:	8f fb c8 c8 	r6 = r9 LSHIFT r6;

        r8 = r7 LSHIFT 3;
84201c30:	01 f9 da d8 	r8 = r7 LSHIFT 3;
        r8 = -r8;
84201c34:	af f0 0a c2 	r8 = Null - r8;
        r8 = r9 LSHIFT r8;      // mask for destination
84201c38:	af fb ca c8 	r8 = r9 LSHIFT r8;

        r1 = M[I0, 0];
84201c3c:	30 f0 30 c0 	Null = Null + Null, r1 = M[I0,0];
        r1 = r1 AND r6;
84201c40:	00 f8 33 c8 	r1 = r1 AND r6;
        r2 = M[I4, 0];
84201c44:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND r8;
84201c48:	00 fa 34 c8 	r2 = r2 AND r8;

        r1 = r1 + r2;
84201c4c:	e3 00       	r1 = r2 + r1;
        M[I4, 0] = r1;
84201c4e:	b0 f0 30 d0 	Null = Null + Null, M[I4,0] = r1;

84201c52 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.copy_aligned_done>:

    copy_aligned_done:
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201c52:	0a d8       	r0 = M[FP + 4];
    r1 = I4;
84201c54:	a3 08       	r1 = I4 + Null;
    r2 = r7;
84201c56:	4c 08       	r2 = r7 + Null;
    call $cbuffer.set_write_address_ex;
84201c58:	fe ff 27 e1 	call (m) $_cbuffer_set_write_address_ex;

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201c5c:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201c5e:	83 08       	r1 = I0 + Null;
    call $cbuffer.set_read_address_ex;
84201c60:	fe ff 23 e0 	call (m) $_cbuffer_set_read_address_ex;

84201c64 <$M.cbuffer_copy_aligned_32bit_be_zero_shift_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201c64:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r5, r6, r7, r8, r9, rLink>;
84201c68:	f9 f2 6d e0 	popm <FP, r0, r1, r2, r5, r6, r7, r8, r9, rLink>;
    rts;
84201c6c:	d8 4c       	rts;

84201c6e <$_cbuffer_copy_unaligned_32bit_be_zero_shift_ex>:
.MODULE $M.cbuffer_copy_unaligned_32bit_zero_shift_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_unaligned_32bit_be_zero_shift_ex:
$_cbuffer_copy_unaligned_32bit_be_zero_shift_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, rLink>;
84201c6e:	7d f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, rLink>;
    pushm <I0, I4, L0, L4>;
84201c72:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    BUFFER_GET_USABLE_OCTETS(r4, r0);
84201c76:	14 1c       	pushm <r0, r1, r2, r3>;
84201c78:	82 00       	r0 = Null + r0;
84201c7a:	fc ff 2d e2 	call (m) $_cbuffer_get_usable_octets;
84201c7e:	16 00       	r4 = r0 + Null;
84201c80:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4 - ADDR_PER_WORD;
84201c82:	30 25       	Null = r4 - 4;
    if NZ call $error;
84201c84:	f1 fd 57 f1 	if NE call (m) 0x2cb9c;
84201c88:	39 e8 
    // r4 = ADDR_PER_WORD;

    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201c8a:	fd ff 31 e6 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201c8e:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201c90:	26 0b       	L4 = r2 + Null;
    r6 = r1;        // save write octet offset
84201c92:	18 09       	r6 = r1 + Null;
    push r3;
84201c94:	00 f0 35 cf 	push r3;
    pop B4;
84201c98:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201c9c:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201c9e:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201ca0:	fd ff 27 e4 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201ca4:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201ca6:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201ca8:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201caa:	0b 62       	if NE jump (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201cac:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201cae:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201cb0:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201cb2:	fe ff 2b e0 	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201cb6:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201cb8:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201cba:	fe ff 29 e3 	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201cbe:	41 6e       	jump (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.cp_pop_and_exit;

84201cc0 <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201cc0:	00 f0 35 cf 	push r3;
    pop B0;
84201cc4:	00 f6 3a cf 	pop B0;
    //push r1;                            // save read octet offset
    r7 = 0xFF; // mask for destination
84201cc8:	09 f0 ff 40 	r7 = Null + 255;
    r8 = 0xFFFFFFFF;
84201ccc:	0a f0 01 24 	r8 = Null - 1;
    r10 = M[FP + 3*ADDR_PER_WORD];        // amount of data to be copied
84201cd0:	ec f0 03 88 	r10 = M[FP + 12];
    do copy_loop;
84201cd4:	2b 4c       	do (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.copy_loop;

        r2 = r4 - r1;                     // source
84201cd6:	f4 04       	r2 = r4 - r1;
        r2 = r2 - 1;
84201cd8:	64 24       	r2 = r2 - 1;
        r2 = r2 LSHIFT 3;
84201cda:	a4 54       	r2 = r2 LSHIFT 3;
        r2 = r7 LSHIFT r2;
84201cdc:	4f f9 c4 c8 	r2 = r7 LSHIFT r2;
        r5 = M[I0, 0];
84201ce0:	70 f0 30 c0 	Null = Null + Null, r5 = M[I0,0];
        r5 = r5 AND r2;                   // octet read
84201ce4:	3f 11       	r5 = r5 AND r2;

        r2 = r1 LSHIFT 3;
84201ce6:	9c 54       	r2 = r1 LSHIFT 3;
        r5 = r5 LSHIFT r2;                // move octet read into the LSB - shift right
84201ce8:	3f 17       	r5 = r5 LSHIFT r2;

        r3 = r6 LSHIFT 3;
84201cea:	01 f8 d5 d8 	r3 = r6 LSHIFT 3;
        r3 = -r3;
84201cee:	45 05       	r3 = Null - r3;
        r5 = r5 LSHIFT r3;                //source octet in the right position for source
84201cf0:	7f 17       	r5 = r5 LSHIFT r3;

        r3 = r4 - r6;                     // us_octets dest
84201cf2:	8f f6 05 c2 	r3 = r4 - r6;
        r3 = r3 - 1;
84201cf6:	6d 24       	r3 = r3 - 1;
        r3 = r3 LSHIFT 3;
84201cf8:	ad 54       	r3 = r3 LSHIFT 3;
        r3 = r7 LSHIFT r3;
84201cfa:	5f f9 c5 c8 	r3 = r7 LSHIFT r3;

        r3 = r3 XOR r8;                   // mask for source
84201cfe:	00 fa b5 c8 	r3 = r3 XOR r8;

        r2 = M[I4, 0];
84201d02:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND r3;                   // protect the bits that aren't to be changed
84201d06:	64 11       	r2 = r2 AND r3;

        r2 = r2 + r5;
84201d08:	3c 01       	r2 = r5 + r2;

        M[I4, 0] = r2;
84201d0a:	c0 f0 30 d0 	Null = Null + Null, M[I4,0] = r2;

        r1 = r1 + 1;
84201d0e:	5b 20       	r1 = r1 + 1;
        Null = r4 - r1;
84201d10:	f0 04       	Null = r4 - r1;
        if NZ jump check_dest_offset;
84201d12:	04 62       	if NE jump (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.check_dest_offset;
            r1 = 0;
84201d14:	03 00       	r1 = Null + Null;
            r3 = M[I0, ADDR_PER_WORD];
84201d16:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];

84201d1a <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.check_dest_offset>:

        check_dest_offset:
        r6 = r6 + 1;
84201d1a:	08 75       	r6 = r6 + 1;
        Null = r4 - r6;
84201d1c:	8f f6 00 c2 	Null = r4 - r6;
        if NZ jump loop_end;
84201d20:	04 62       	if NE jump (m) $M.cbuffer_copy_unaligned_32bit_zero_shift_ex.loop_end;
            r6 = 0;
84201d22:	00 09       	r6 = Null + Null;
            r3 = M[I4, ADDR_PER_WORD];
84201d24:	51 f0 30 d0 	Null = Null + Null, r3 = M[I4,4];

84201d28 <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.loop_end>:
	...

84201d2a <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.copy_loop>:
        loop_end:
        nop;
    copy_loop:

    upd_ptrs:
    r5 = r1;    // save final offset source
84201d2a:	1f 00       	r5 = r1 + Null;
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201d2c:	0a d8       	r0 = M[FP + 4];
    r2 = r6;
84201d2e:	44 08       	r2 = r6 + Null;
    r1 = I4;
84201d30:	a3 08       	r1 = I4 + Null;
    call $cbuffer.set_write_address_ex;
84201d32:	fd ff 2d ea 	call (m) $_cbuffer_set_write_address_ex;
    // r2 is not trashed

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201d36:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201d38:	83 08       	r1 = I0 + Null;
    r2 = r5;
84201d3a:	3c 00       	r2 = r5 + Null;
    call $cbuffer.set_read_address_ex;
84201d3c:	fd ff 27 e9 	call (m) $_cbuffer_set_read_address_ex;

84201d40 <$M.cbuffer_copy_unaligned_32bit_zero_shift_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201d40:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, rLink>;
84201d44:	7d f2 6d e0 	popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, rLink>;
    rts;
84201d48:	d8 4c       	rts;

84201d4a <$_cbuffer_copy_unpacked_to_packed_ex>:
.MODULE $M.cbuffer_copy_unpacked_to_packed_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_unpacked_to_packed_ex:
$_cbuffer_copy_unpacked_to_packed_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
84201d4a:	fd f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
    pushm <I0, I4, L0, L4>;
84201d4e:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    BUFFER_GET_USABLE_OCTETS(r9, r0);           // destination
84201d52:	14 1c       	pushm <r0, r1, r2, r3>;
84201d54:	82 00       	r0 = Null + r0;
84201d56:	fb ff 31 eb 	call (m) $_cbuffer_get_usable_octets;
84201d5a:	13 09       	r9 = r0 + Null;
84201d5c:	14 48       	popm <r0, r1, r2, r3>;
    Null = r9 - ADDR_PER_WORD;         // usable_octets destination
84201d5e:	b0 f0 04 24 	Null = r9 - 4;
    if NZ call $error;
84201d62:	f1 fd 57 f1 	if NE call (m) 0x2cb9c;
84201d66:	3b e1 
    // r9 = ADDR_PER_WORD;

    BUFFER_GET_USABLE_OCTETS(r4, r1);           //source
84201d68:	14 1c       	pushm <r0, r1, r2, r3>;
84201d6a:	1a 00       	r0 = r1 + Null;
84201d6c:	fb ff 3b ea 	call (m) $_cbuffer_get_usable_octets;
84201d70:	16 00       	r4 = r0 + Null;
84201d72:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4 - US_OCTETS_16BIT;
84201d74:	b0 24       	Null = r4 - 2;
    if NZ call $error;
84201d76:	f1 fd 57 f1 	if NE call (m) 0x2cb9c;
84201d7a:	27 e1 


    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201d7c:	fc ff 3f ee 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201d80:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201d82:	26 0b       	L4 = r2 + Null;
    r6 = r1;        // save write octet offset
84201d84:	18 09       	r6 = r1 + Null;
    push r3;
84201d86:	00 f0 35 cf 	push r3;
    pop B4;
84201d8a:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201d8e:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201d90:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201d92:	fc ff 35 ec 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201d96:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201d98:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201d9a:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201d9c:	0b 62       	if NE jump (m) $M.cbuffer_copy_unpacked_to_packed_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201d9e:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201da0:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201da2:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201da4:	fd ff 39 e8 	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201da8:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201daa:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201dac:	fd ff 37 eb 	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201db0:	43 6e       	jump (m) $M.cbuffer_copy_unpacked_to_packed_ex.cp_pop_and_exit;

84201db2 <$M.cbuffer_copy_unpacked_to_packed_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201db2:	00 f0 35 cf 	push r3;
    pop B0;
84201db6:	00 f6 3a cf 	pop B0;
    r7 = 0xFFFFFFFF;                // mask for destination
84201dba:	09 f0 01 24 	r7 = Null - 1;
    r8 = r9 - r4;                   // us_octets_dest - us_octets_source
84201dbe:	6f fb 0a c2 	r8 = r9 - r4;
    r10 = M[FP + 3*ADDR_PER_WORD];  // amount of data to be copied
84201dc2:	ec f0 03 88 	r10 = M[FP + 12];
    do copy_loop;
84201dc6:	2d 4c       	do (m) $M.cbuffer_copy_unpacked_to_packed_ex.copy_loop;

        r2 = r4 - 1;           // source
84201dc8:	74 24       	r2 = r4 - 1;
        r2 = r2 - r1;
84201dca:	e4 04       	r2 = r2 - r1;
        r2 = r2 LSHIFT 3;
84201dcc:	a4 54       	r2 = r2 LSHIFT 3;
        r2 = 0xFF LSHIFT r2;
84201dce:	7f f4 94 de 	r2 = 0xff LSHIFT r2;
        r5 = M[I0, 0];
84201dd2:	70 f0 30 c0 	Null = Null + Null, r5 = M[I0,0];
        r5 = r5 AND r2;        // octet read
84201dd6:	3f 11       	r5 = r5 AND r2;

        r2 = r8 + r1;
84201dd8:	3f fa 04 c0 	r2 = r8 + r1;
        r2 = r2 LSHIFT 3;
84201ddc:	a4 54       	r2 = r2 LSHIFT 3;
        r5 = r5 LSHIFT r2;     // move octet read into the LSB - shift left
84201dde:	3f 17       	r5 = r5 LSHIFT r2;

        r3 = r6 LSHIFT 3;
84201de0:	01 f8 d5 d8 	r3 = r6 LSHIFT 3;
        r3 = -r3;
84201de4:	45 05       	r3 = Null - r3;
        r5 = r5 LSHIFT r3;     //source octet in the right position for source
84201de6:	7f 17       	r5 = r5 LSHIFT r3;


        r3 = r9 - r6;          // us_octets dest
84201de8:	8f fb 05 c2 	r3 = r9 - r6;
        r3 = r3 - 1;
84201dec:	6d 24       	r3 = r3 - 1;
        r3 = r3 LSHIFT 3;
84201dee:	ad 54       	r3 = r3 LSHIFT 3;
        r3 = 0xFF LSHIFT r3;   // mask for octets before
84201df0:	7f f5 95 de 	r3 = 0xff LSHIFT r3;

        r3 = r3 XOR r7;
84201df4:	00 f9 b5 c8 	r3 = r3 XOR r7;

        r2 = M[I4, 0];
84201df8:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND r3;        // mask the source
84201dfc:	64 11       	r2 = r2 AND r3;

        r2 = r2 + r5;          // combine octet read with the source word partially masked
84201dfe:	3c 01       	r2 = r5 + r2;

        M[I4, 0] = r2;
84201e00:	c0 f0 30 d0 	Null = Null + Null, M[I4,0] = r2;

        r1 = r1 + 1;
84201e04:	5b 20       	r1 = r1 + 1;
        Null = r4 - r1;
84201e06:	f0 04       	Null = r4 - r1;
        if NZ jump check_dest_offset;
84201e08:	04 62       	if NE jump (m) $M.cbuffer_copy_unpacked_to_packed_ex.check_dest_offset;
            r1 = 0;
84201e0a:	03 00       	r1 = Null + Null;
            r3 = M[I0, ADDR_PER_WORD];
84201e0c:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];

84201e10 <$M.cbuffer_copy_unpacked_to_packed_ex.check_dest_offset>:

        check_dest_offset:
        r6 = r6 + 1;
84201e10:	08 75       	r6 = r6 + 1;
        Null = r9 - r6;
84201e12:	8f fb 00 c2 	Null = r9 - r6;
        if NZ jump loop_end;
84201e16:	04 62       	if NE jump (m) $M.cbuffer_copy_unpacked_to_packed_ex.loop_end;
            r6 = 0;
84201e18:	00 09       	r6 = Null + Null;
            r3 = M[I4, ADDR_PER_WORD];
84201e1a:	51 f0 30 d0 	Null = Null + Null, r3 = M[I4,4];

84201e1e <$M.cbuffer_copy_unpacked_to_packed_ex.loop_end>:
	...

84201e20 <$M.cbuffer_copy_unpacked_to_packed_ex.copy_loop>:
        loop_end:
        nop;
    copy_loop:

    upd_ptrs:
    r5 = r1;    // save final offset source
84201e20:	1f 00       	r5 = r1 + Null;
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201e22:	0a d8       	r0 = M[FP + 4];
    r2 = r6;
84201e24:	44 08       	r2 = r6 + Null;
    r1 = I4;
84201e26:	a3 08       	r1 = I4 + Null;
    call $cbuffer.set_write_address_ex;
84201e28:	fd ff 37 e2 	call (m) $_cbuffer_set_write_address_ex;
    // r2 is not trashed

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201e2c:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201e2e:	83 08       	r1 = I0 + Null;
    r2 = r5;
84201e30:	3c 00       	r2 = r5 + Null;
    call $cbuffer.set_read_address_ex;
84201e32:	fd ff 31 e1 	call (m) $_cbuffer_set_read_address_ex;

84201e36 <$M.cbuffer_copy_unpacked_to_packed_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201e36:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
84201e3a:	fd f2 6d e0 	popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
    rts;
84201e3e:	d8 4c       	rts;

84201e40 <$_cbuffer_copy_packed_to_unpacked_ex>:
.MODULE $M.cbuffer_copy_packed_to_unpacked_ex;
    .CODESEGMENT BUFFER_PM;
$cbuffer.copy_packed_to_unpacked_ex:
$_cbuffer_copy_packed_to_unpacked_ex:
    // save the input paramerters for later
    pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
84201e40:	fd f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
    pushm <I0, I4, L0, L4>;
84201e44:	01 f5 41 e4 	pushm <I0, I4, L0, L4>;

    BUFFER_GET_USABLE_OCTETS(r9, r0);           // destination
84201e48:	14 1c       	pushm <r0, r1, r2, r3>;
84201e4a:	82 00       	r0 = Null + r0;
84201e4c:	fb ff 3b e3 	call (m) $_cbuffer_get_usable_octets;
84201e50:	13 09       	r9 = r0 + Null;
84201e52:	14 48       	popm <r0, r1, r2, r3>;
    Null = r9 - US_OCTETS_16BIT;
84201e54:	b0 f0 02 24 	Null = r9 - 2;
    if NZ call $error;
84201e58:	f1 fd 56 f1 	if NE call (m) 0x2cb9c;
84201e5c:	25 ea 

    BUFFER_GET_USABLE_OCTETS(r4, r1);           // source
84201e5e:	14 1c       	pushm <r0, r1, r2, r3>;
84201e60:	1a 00       	r0 = r1 + Null;
84201e62:	fb ff 25 e3 	call (m) $_cbuffer_get_usable_octets;
84201e66:	16 00       	r4 = r0 + Null;
84201e68:	14 48       	popm <r0, r1, r2, r3>;
    Null = r4 - ADDR_PER_WORD;                                  // usable_octets destination
84201e6a:	30 25       	Null = r4 - 4;
    if NZ call $error;
84201e6c:	f1 fd 56 f1 	if NE call (m) 0x2cb9c;
84201e70:	31 e9 
    //r4 = ADDR_PER_WORD;

    // get dest buffer true write address and size
    call $cbuffer.get_write_address_ex;
84201e72:	fc ff 29 e7 	call (m) $cbuffer.get_write_address_ex;
    I4 = r0;
84201e76:	14 0a       	I4 = r0 + Null;
    L4 = r2;
84201e78:	26 0b       	L4 = r2 + Null;
    r6 = r1;        // save write octet offset
84201e7a:	18 09       	r6 = r1 + Null;
    push r3;
84201e7c:	00 f0 35 cf 	push r3;
    pop B4;
84201e80:	00 f6 3c cf 	pop B4;
    r5 = r3;        // prepare for checking for in-place
84201e84:	2f 00       	r5 = r3 + Null;

    // get src buffer read address and size
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201e86:	12 d8       	r0 = M[FP + 8];
    // get the read address and size
    call $cbuffer.get_read_address_ex;
84201e88:	fc ff 3f e4 	call (m) $cbuffer.get_read_address_ex;
    I0 = r0;
84201e8c:	10 0a       	I0 = r0 + Null;
    L0 = r2;
84201e8e:	24 0b       	L0 = r2 + Null;

    // check if cbuffer base addresses are the same
    Null = r5 - r3;
84201e90:	78 05       	Null = r5 - r3;
    if NZ jump not_in_place_copy;
84201e92:	0b 62       	if NE jump (m) $M.cbuffer_copy_packed_to_unpacked_ex.not_in_place_copy;
        // only advance pointers, no copy for in-place
        r5 = M[FP + 3*ADDR_PER_WORD];            // copy amount
84201e94:	1f d8       	r5 = M[FP + 12];
        r0 = M[FP + 1*ADDR_PER_WORD];            // cbuffer_dest
84201e96:	0a d8       	r0 = M[FP + 4];
        r1 = r5;
84201e98:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_write_ptr_ex;
84201e9a:	fd ff 23 e1 	call (m) $_cbuffer_advance_write_ptr_ex;

        r0 = M[FP + 2*ADDR_PER_WORD];            // cbuffer_src
84201e9e:	12 d8       	r0 = M[FP + 8];
        r1 = r5;
84201ea0:	3b 00       	r1 = r5 + Null;
        call $cbuffer.advance_read_ptr_ex;
84201ea2:	fd ff 21 e4 	call (m) $_cbuffer_advance_read_ptr_ex;

        jump cp_pop_and_exit;
84201ea6:	3f 6e       	jump (m) $M.cbuffer_copy_packed_to_unpacked_ex.cp_pop_and_exit;

84201ea8 <$M.cbuffer_copy_packed_to_unpacked_ex.not_in_place_copy>:

    not_in_place_copy:
    // init base for src ahead of doloop
    push r3;
84201ea8:	00 f0 35 cf 	push r3;
    pop B0;
84201eac:	00 f6 3a cf 	pop B0;
    r7 = 0xFF;
84201eb0:	09 f0 ff 40 	r7 = Null + 255;
    r8 = r9 - r4; // us_octets_dest - us_octets_source
84201eb4:	6f fb 0a c2 	r8 = r9 - r4;

    r10 = M[FP + 3*ADDR_PER_WORD];  // amount of data to be copied
84201eb8:	ec f0 03 88 	r10 = M[FP + 12];
    do copy_loop;
84201ebc:	29 4c       	do (m) $M.cbuffer_copy_packed_to_unpacked_ex.copy_loop;
        r2 = ADDR_PER_WORD - r1;    // source
84201ebe:	02 f3 54 c6 	r2 = 4 - r1;
        r2 = r2 - 1;
84201ec2:	64 24       	r2 = r2 - 1;
        r2 = r2 LSHIFT 3;
84201ec4:	a4 54       	r2 = r2 LSHIFT 3;
        r2 = r7 LSHIFT r2;
84201ec6:	4f f9 c4 c8 	r2 = r7 LSHIFT r2;
        r5 = M[I0, 0];
84201eca:	70 f0 30 c0 	Null = Null + Null, r5 = M[I0,0];
        r5 = r5 AND r2;             // octet read
84201ece:	3f 11       	r5 = r5 AND r2;

        r2 = r8 + r1;               // overwritten
84201ed0:	3f fa 04 c0 	r2 = r8 + r1;
        r2 = r2 LSHIFT 3;
84201ed4:	a4 54       	r2 = r2 LSHIFT 3;
        r5 = r5 LSHIFT r2;          // move octet read into the LSB - shift left
84201ed6:	3f 17       	r5 = r5 LSHIFT r2;

        r3 = r6 LSHIFT 3;
84201ed8:	01 f8 d5 d8 	r3 = r6 LSHIFT 3;
        r3 = -r3;
84201edc:	45 05       	r3 = Null - r3;
        r5 = r5 LSHIFT r3;          //source octet in the right position for source
84201ede:	7f 17       	r5 = r5 LSHIFT r3;

        r3 = -r3;
84201ee0:	45 05       	r3 = Null - r3;
        r3 = r7 LSHIFT r3;          // mask dest
84201ee2:	5f f9 c5 c8 	r3 = r7 LSHIFT r3;

        r2 = M[I4, 0];
84201ee6:	40 f0 30 d0 	Null = Null + Null, r2 = M[I4,0];
        r2 = r2 AND r3;
84201eea:	64 11       	r2 = r2 AND r3;

        r2 = r2 + r5;
84201eec:	3c 01       	r2 = r5 + r2;

        M[I4, 0] = r2;
84201eee:	c0 f0 30 d0 	Null = Null + Null, M[I4,0] = r2;

        r1 = r1 + 1;
84201ef2:	5b 20       	r1 = r1 + 1;
        Null = r4 - r1;
84201ef4:	f0 04       	Null = r4 - r1;
        if NZ jump check_dest_offset;
84201ef6:	04 62       	if NE jump (m) $M.cbuffer_copy_packed_to_unpacked_ex.check_dest_offset;
            r1 = 0;
84201ef8:	03 00       	r1 = Null + Null;
            r3 = M[I0, ADDR_PER_WORD];
84201efa:	51 f0 30 c0 	Null = Null + Null, r3 = M[I0,4];

84201efe <$M.cbuffer_copy_packed_to_unpacked_ex.check_dest_offset>:

        check_dest_offset:
        r6 = r6 + 1;
84201efe:	08 75       	r6 = r6 + 1;
        Null = r9 - r6;
84201f00:	8f fb 00 c2 	Null = r9 - r6;
        if NZ jump loop_end;
84201f04:	04 62       	if NE jump (m) $M.cbuffer_copy_packed_to_unpacked_ex.loop_end;
            r6 = 0;
84201f06:	00 09       	r6 = Null + Null;
            r3 = M[I4, ADDR_PER_WORD];
84201f08:	51 f0 30 d0 	Null = Null + Null, r3 = M[I4,4];

84201f0c <$M.cbuffer_copy_packed_to_unpacked_ex.loop_end>:
	...

84201f0e <$M.cbuffer_copy_packed_to_unpacked_ex.copy_loop>:
        loop_end:
        nop;
    copy_loop:

    upd_ptrs:
    r5 = r1;    // save final offset source
84201f0e:	1f 00       	r5 = r1 + Null;
    // Update the write address
    r0 = M[FP + 1*ADDR_PER_WORD];                // cbuffer_dest
84201f10:	0a d8       	r0 = M[FP + 4];
    r2 = r6;
84201f12:	44 08       	r2 = r6 + Null;
    r1 = I4;
84201f14:	a3 08       	r1 = I4 + Null;
    call $cbuffer.set_write_address_ex;
84201f16:	fc ff 29 eb 	call (m) $_cbuffer_set_write_address_ex;
    // r2 is not trashed

    // Update the read address
    r0 = M[FP + 2*ADDR_PER_WORD];                // cbuffer_src
84201f1a:	12 d8       	r0 = M[FP + 8];
    r1 = I0;
84201f1c:	83 08       	r1 = I0 + Null;
    r2 = r5;
84201f1e:	3c 00       	r2 = r5 + Null;
    call $cbuffer.set_read_address_ex;
84201f20:	fc ff 23 ea 	call (m) $_cbuffer_set_read_address_ex;

84201f24 <$M.cbuffer_copy_packed_to_unpacked_ex.cp_pop_and_exit>:

    cp_pop_and_exit:
    // Restore index & length registers
    popm <I0, I4, L0, L4>;
84201f24:	01 f5 61 e4 	popm <I0, I4, L0, L4>;
    popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
84201f28:	fd f2 6d e0 	popm <FP, r0, r1, r2, r4, r5, r6, r7, r8, r9, rLink>;
    rts;
84201f2c:	d8 4c       	rts;
